Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/z3_fpga.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/z3_fpga.c	2012-09-23 16:09:57.608322951 -0600
@@ -0,0 +1,2248 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/io.h>
+#include <linux/proc_fs.h>
+#include <linux/i2c.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <asm/uaccess.h>
+#include <mach/gpio.h>
+#include <mach/hardware.h>
+#include <mach/z3_app.h>
+#include <mach/z3_fpga.h>
+
+#include "mux.h"
+#include "cm81xx.h"
+#include "control.h"
+#include <plat/clock.h> // for recalculate_root_clocks()
+
+static void *__iomem z3_fpga_base_addr;
+static void *__iomem z3_latch_base_addr;
+static void *__iomem z3_tppss_gbl_base_addr;
+static void *__iomem z3_tppss_stc0_27mcnt;
+
+static u16 z3_fpga_latch1_value;
+static u16 z3_fpga_latch2_value;
+
+static int z3_fpga_latch1_offset = 0;
+static int z3_fpga_latch2_offset = 8;
+
+static enum z3_fpga_pll_setting z3_fpga_pll_setting = Z3_FPGA_PLL_VIDIN_74M176;
+
+//static int z3_fpga_audio_enable_value = 0;
+//static enum z3_fpga_audio_mode z3_fpga_audio_select_value = Z3_FPGA_AUDIO_TRISTATE;
+
+static int z3_fpga_aic_ext_master = 0;
+
+static struct timer_list z3_fpga_timer;
+static unsigned int z3_fpga_timeout_ms = 60000;
+
+/* Sample rate converter setting */
+static enum z3_fpga_audio_src   z3_fpga_audio_src = Z3_FPGA_AUDIO_SRC_ENABLE;
+
+static enum z3_fpga_audio_input z3_fpga_audio_input = Z3_FPGA_AUDIO_INPUT_1_2;
+
+static unsigned int z3_fpga_aic_ext_master_div_mask = 0x2000; // divide by 8 (48kHz)
+
+static unsigned int z3_fpga_pll_load_pf = 6;
+
+static unsigned int z3_fpga_pll_load_scanned = 0;
+
+static int z3_fpga_load_pf_min_lock = -1;
+static int z3_fpga_load_pf_max_lock = -1;
+
+
+#define z3_fpga_valid_board_id() \
+     (z3_fpga_board_id_value != 0xffff)
+
+#define z3_fpga_valid_sdi_board_id() \
+     (z3_fpga_board_id_value == Z3_BOARD_ID_APP_31)
+
+#define z3_fpga_valid_aic_disable_board_id() \
+     (z3_fpga_board_id_value == Z3_BOARD_ID_APP_31 || z3_fpga_board_id_value == Z3_BOARD_ID_APP_02)
+
+static u16 z3_fpga_board_id_value = 0xffff;
+
+
+static struct i2c_client *z3_fpga_pll_client = NULL;
+
+static struct mutex z3_fpga_pll_load_scan_mutex;
+
+static unsigned int z3_fpga_pll_ctrl_divide = 0;
+static unsigned int z3_fpga_pll_ctrl_vidin  = 0;
+
+static const char *z3_fpga_tso_pll_clk_name = "audio_pll_clk2_ck";
+static const char *z3_fpga_sdiout_audio_pll_clk_name = "audio_pll_clk3_ck";
+static const char *z3_fpga_sdiout_video_pll_clk_name = "video_pll_clk2_ck";
+
+
+/* I2C - for APP-03 and up */
+/*
+ */
+
+static int z3_fpga_pll_adapter_id = 1;
+static struct i2c_board_info pll_board_info = {
+        .type = "PLL",
+        .addr = 0x64,
+        .platform_data = NULL,
+};
+
+
+int z3_fpga_read(u32 offset)
+{
+        int retval;
+
+	if ( z3_fpga_base_addr != 0) {
+                if (offset < Z3_FPGA_ADDR_SIZE) {
+                        retval = __raw_readw(z3_fpga_base_addr + offset);
+//                        printk(KERN_ERR "read fpga offset x%x value x%x\n",
+//                               (unsigned int)offset, (unsigned int) retval);
+
+                        return retval;
+                }
+                else
+                        printk(KERN_ERR "offset exceeds Z3 fpga address space\n");
+	}
+	return -1;
+}
+EXPORT_SYMBOL(z3_fpga_read);
+
+int z3_fpga_latch_write(u16 *value)
+{
+	if ( z3_latch_base_addr != 0) {
+                if  ( value == &z3_fpga_latch1_value ) {
+                        __raw_writew(*value, z3_latch_base_addr + z3_fpga_latch1_offset);
+                } else {
+
+                        /* Latch2 only present on certain boards */
+                        if ( !z3_fpga_valid_sdi_board_id() )
+                                return 0;
+
+                        if ( cpu_is_ti816x() ) {
+                                omap_mux_init_signal( "gpmc_a3", TI81XX_MUX_PULLDIS );
+                        }
+
+                        __raw_writew(*value, z3_latch_base_addr + z3_fpga_latch2_offset);
+
+                        if ( cpu_is_ti816x() ) {
+                                if ( 0 == (Z3_APP31_Y2_FPGA_PROG & z3_fpga_latch1_value) ) {
+                                        omap_mux_init_signal( "gp0_io11", TI81XX_MUX_PULLDIS );
+                                }
+                        }
+                }
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(z3_fpga_write);
+
+
+int z3_fpga_latch1_read(u16 *value)
+{
+        int ret = -1;
+
+	if ( z3_latch_base_addr != 0 ) {
+                *value = __raw_readw(z3_latch_base_addr + z3_fpga_latch1_offset);
+                ret = 0;
+        }
+
+	return ret;
+}
+
+int z3_fpga_read_version(void)
+{
+	if (z3_fpga_base_addr != 0) {
+                return __raw_readw(z3_fpga_base_addr + Z3_FPGA_VERSION_READ_OFFSET);
+	}
+	return -1;
+}
+
+
+
+int z3_fpga_write(u16 val, u32 offset)
+{
+	if ( z3_fpga_base_addr != 0) {
+             if (offset < Z3_FPGA_ADDR_SIZE) {
+//                     printk(KERN_ERR "write fpga offset x%x value x%x\n",
+//                            (unsigned int)offset, (unsigned int) val );
+
+                     __raw_writew(val, z3_fpga_base_addr + offset);
+                     return val;
+             } else
+                  printk(KERN_ERR "offset exceeds Z3 fpga address space\n");
+	}
+	return -1;
+}
+
+
+int
+z3_fpga_i2c_pll_wr(u8 offset, u8 byte)
+{
+        int ret = 0;
+        struct i2c_msg msg[1];
+        unsigned char writedata[2];
+        int retries = 3;
+        int err;
+
+        if ( z3_fpga_pll_client == NULL ) {
+                ret = -ENODEV;
+        } else if ( z3_fpga_pll_client->adapter == NULL ) {
+                ret = -ENODEV;
+        }
+
+        if ( 0 == ret ) {
+                do {
+                        msg[0].addr = z3_fpga_pll_client->addr;
+                        msg[0].flags = 0;
+                        msg[0].len = 2;
+                        msg[0].buf = writedata;
+
+                        writedata[0] = offset | 0x80; //bit 7 is byte operation flag
+                        writedata[1] = byte;
+
+                        err = i2c_transfer(z3_fpga_pll_client->adapter, msg, 1);
+                        ret = (err<0) ? err : 0;
+
+                        if ( err < 0 ) {
+                                msleep(10);
+                        }
+                } while ( err < 0 && --retries > 0);
+        }
+
+        if ( retries <= 0 )
+                return -EIO;
+
+
+        printk( KERN_DEBUG "PLL %02x <= %02x ret %d\n", offset, byte, ret );
+        return ret;
+}
+EXPORT_SYMBOL(z3_fpga_i2c_pll_wr);
+
+
+int
+z3_fpga_pll_setup(enum z3_fpga_pll_setting pll_setting)
+{
+     int ret = 0;
+
+/* Setup CDCE925 PLL so that
+ Y0: 27.000 MHz
+ Y3: 12.288 MHz
+ Y5: 74.25 MHz or 74.176 MHz
+*/
+
+     switch ( pll_setting ) {
+     case Z3_FPGA_PLL_VIDOUT_74M176:
+          // SDI out needs a steady clock => disable VCXO
+          ret |= z3_fpga_i2c_pll_wr( 0x01, 0x00);
+          break;
+
+     default:
+          ret |= z3_fpga_i2c_pll_wr( 0x01, 0x04 );
+          break;
+     }
+
+     if ( Z3_FPGA_PLL_OUTPUT_DISABLE == pll_setting ) {
+             ret |= z3_fpga_i2c_pll_wr( 0x02, 0x80 );
+     } else {
+             ret |= z3_fpga_i2c_pll_wr( 0x02, 0x34 );
+     }
+     ret |= z3_fpga_i2c_pll_wr( 0x04, 0x02 );
+     ret |= z3_fpga_i2c_pll_wr( 0x05, z3_fpga_pll_load_pf*8 );	// Crystal load capacitance
+     ret |= z3_fpga_i2c_pll_wr( 0x06, 0x60 );
+
+     if ( Z3_FPGA_PLL_OUTPUT_DISABLE == pll_setting ) {
+             ret |= z3_fpga_i2c_pll_wr( 0x14, 0x80 );
+     } else {
+             ret |= z3_fpga_i2c_pll_wr( 0x14, 0x6d );
+     }
+     ret |= z3_fpga_i2c_pll_wr( 0x16, 0x29 );
+     ret |= z3_fpga_i2c_pll_wr( 0x17, 0x09 );
+     ret |= z3_fpga_i2c_pll_wr( 0x18, 0x60 );
+     ret |= z3_fpga_i2c_pll_wr( 0x19, 0x04 );
+     ret |= z3_fpga_i2c_pll_wr( 0x1a, 0x82 );
+
+
+     switch ( pll_setting ) {
+     case Z3_FPGA_PLL_VIDOUT_27M:
+          ret |= z3_fpga_i2c_pll_wr( 0x24, 0xef ); // PLL Bypass
+          ret |= z3_fpga_i2c_pll_wr( 0x26, 0x08 );
+          ret |= z3_fpga_i2c_pll_wr( 0x27, 0x01 ); // divisor of 1
+          break;
+
+     case Z3_FPGA_PLL_OUTPUT_DISABLE:
+          ret |= z3_fpga_i2c_pll_wr( 0x24, 0x80 ); // PLL Bypass
+          ret |= z3_fpga_i2c_pll_wr( 0x26, 0x08 );
+          ret |= z3_fpga_i2c_pll_wr( 0x27, 0x01 ); // divisor of 1
+          break;
+
+     case Z3_FPGA_PLL_VIDIN_148M5:
+     case Z3_FPGA_PLL_VIDIN_148M352:
+          ret |= z3_fpga_i2c_pll_wr( 0x24, 0x6f );
+          ret |= z3_fpga_i2c_pll_wr( 0x26, 0x00 );
+          ret |= z3_fpga_i2c_pll_wr( 0x27, 0x01 );
+          break;
+
+     default:
+          ret |= z3_fpga_i2c_pll_wr( 0x24, 0x6f );
+          ret |= z3_fpga_i2c_pll_wr( 0x26, 0x08 );
+          ret |= z3_fpga_i2c_pll_wr( 0x27, 0x03 );
+          break;
+     }
+
+     switch ( pll_setting ) {
+     case Z3_FPGA_PLL_VIDIN_74M25:
+          ret |= z3_fpga_i2c_pll_wr( 0x28, 0xff );
+          ret |= z3_fpga_i2c_pll_wr( 0x29, 0xc7 );
+          ret |= z3_fpga_i2c_pll_wr( 0x2a, 0xc2 );
+          ret |= z3_fpga_i2c_pll_wr( 0x2b, 0x07 );
+          break;
+
+     case Z3_FPGA_PLL_VIDIN_148M5:
+          ret |= z3_fpga_i2c_pll_wr( 0x28, 0xaf );
+          ret |= z3_fpga_i2c_pll_wr( 0x29, 0x50 );
+          ret |= z3_fpga_i2c_pll_wr( 0x2a, 0x02 );
+          ret |= z3_fpga_i2c_pll_wr( 0x2b, 0xc9 );
+          break;
+
+     case Z3_FPGA_PLL_VIDIN_148M352:
+          ret |= z3_fpga_i2c_pll_wr( 0x28, 0x9c );
+          ret |= z3_fpga_i2c_pll_wr( 0x29, 0x4d );
+          ret |= z3_fpga_i2c_pll_wr( 0x2a, 0xea );
+          ret |= z3_fpga_i2c_pll_wr( 0x2b, 0xa9 );
+          break;
+
+     default:
+          ret |= z3_fpga_i2c_pll_wr( 0x28, 0xea );
+          ret |= z3_fpga_i2c_pll_wr( 0x29, 0x66 );
+          ret |= z3_fpga_i2c_pll_wr( 0x2a, 0xe2 );
+          ret |= z3_fpga_i2c_pll_wr( 0x2b, 0x07 );
+          break;
+     }
+
+
+     switch ( pll_setting ) {
+     case Z3_FPGA_PLL_VIDIN_13M5:
+          z3_fpga_pll_ctrl_divide = 0x01;
+          break;
+
+     case Z3_FPGA_PLL_VIDIN_27M:
+          z3_fpga_pll_ctrl_divide = 0x11;
+          break;
+
+
+     case Z3_FPGA_PLL_VIDIN_148M5:
+     case Z3_FPGA_PLL_VIDIN_148M352:
+          z3_fpga_pll_ctrl_divide = 0x3b;
+          break;
+
+     default:
+          // PLL_PCLK reference
+          z3_fpga_pll_ctrl_divide = 0x2a;
+          break;
+     }
+
+     z3_fpga_write( z3_fpga_pll_ctrl_vidin|z3_fpga_pll_ctrl_divide, Z3_FPGA_PLL_CTRL_OFFSET);
+
+     if ( 0 == ret )
+          z3_fpga_pll_setting = pll_setting;
+
+     return ret;
+}
+EXPORT_SYMBOL(z3_fpga_pll_setup);
+
+
+int z3_fpga_si_20bit( int enable )
+{
+     if ( enable ) {
+             z3_fpga_latch2_value |=  Z3_APP31_Y3_SI_20BIT;
+     } else {
+             z3_fpga_latch2_value &=  ~Z3_APP31_Y3_SI_20BIT;
+     }
+
+     return z3_fpga_latch_write( &z3_fpga_latch2_value );
+}
+EXPORT_SYMBOL(z3_fpga_si_20bit);
+
+int z3_fpga_so_set( unsigned int value )
+{
+     value &= Z3_FPGA_LATCH_SO_MASK;
+
+     z3_fpga_latch2_value = (z3_fpga_latch2_value & ~Z3_FPGA_LATCH_SO_MASK) | value;
+
+     return z3_fpga_latch_write( &z3_fpga_latch2_value );
+}
+EXPORT_SYMBOL(z3_fpga_so_set);
+
+
+
+void z3_fpga_stc_read(u64 *base, u32 *ext, struct timespec *ptimespec, u64 *stc0_27mhz, u32 *gptimer_27mhz)
+{
+     int dummy_value=0;
+     unsigned long flags;
+
+     static u64 oldbase;
+     static u64 wrapcount;
+     static int oldbasevalid;
+     static u64 stc0_27mhz_wrapcount;
+     static u64 stc0_27mhz_old;
+     static int stc0_27mhz_valid;
+
+     u32    stc0_27mhz_current = 0;
+     int    has_tppss = 0;
+     int    is_ti816x_predicate = 0;
+     u32    gptimer2_27mhz_current = 0;
+
+     is_ti816x_predicate = cpu_is_ti816x();
+
+     if ( is_ti816x_predicate ) {
+             if ( z3_tppss_stc0_27mcnt != NULL
+                  && 0 == (__raw_readl(TI816X_CM_DEFAULT_TPPSS_CLKCTRL) & 0x30000 ) ) {
+                     has_tppss = 1;
+             }
+     }
+     local_irq_save(flags);
+
+     getnstimeofday(ptimespec);
+
+     /* Write to latch value */
+     z3_fpga_write( dummy_value, Z3_FPGA_STC_EXT_OFFSET );
+
+     if ( has_tppss ) {
+             stc0_27mhz_current = __raw_readl( z3_tppss_stc0_27mcnt );
+     }
+
+
+     if ( is_ti816x_predicate ) {
+             gptimer2_27mhz_current = __raw_readl( TI81XX_L4_SLOW_IO_ADDRESS(0x4804003c) );
+     }
+
+     /* Read values */
+     (*base) = (z3_fpga_read( Z3_FPGA_STC_BASE_H_OFFSET ) & Z3_FPGA_STC_BASE_H_MASK);
+     (*base) <<= 16;
+     (*base) |= z3_fpga_read( Z3_FPGA_STC_BASE_M_OFFSET );
+     (*base) <<= 16;
+     (*base) |= z3_fpga_read( Z3_FPGA_STC_BASE_L_OFFSET );
+
+     (*ext) = z3_fpga_read( Z3_FPGA_STC_EXT_OFFSET );
+
+     local_irq_restore(flags);
+
+
+     if ( oldbasevalid ) {
+          if ( ((oldbase >> 32) & 1) == 1
+               && (((*base) >> 32) & 1) == 0 ) {
+               wrapcount += (1ULL<<33);
+          }
+     }
+     oldbase = *base;
+     oldbasevalid = 1;
+
+     (*base) += wrapcount;
+
+     /* Now FPGA is restamping and comparing PCR to STC .... */
+     /* (*base) += 0x1feffffffULL; // detect wrap-around issues early */
+
+
+     if ( z3_tppss_stc0_27mcnt ) {
+             if ( stc0_27mhz_valid ) {
+                     if ( ((stc0_27mhz_old >> 31) & 1) == 1
+                          && ((stc0_27mhz_current >> 31) & 1) == 0 ) {
+                             stc0_27mhz_wrapcount += (1ULL<<32);
+                     }
+             }
+
+             stc0_27mhz_valid = 1;
+             stc0_27mhz_old = stc0_27mhz_current;
+
+             *stc0_27mhz = stc0_27mhz_current;
+             *stc0_27mhz += stc0_27mhz_wrapcount;
+     } else {
+             *stc0_27mhz = 0;
+     }
+
+
+     *gptimer_27mhz = gptimer2_27mhz_current;
+}
+EXPORT_SYMBOL(z3_fpga_stc_read);
+
+
+void z3_fpga_tso_pcr_delta_read(s64 *delta_27mhz_ticks)
+{
+        s16 high = 0;
+        u32 low  = 0;
+        s64 retval;
+
+	if ( z3_fpga_base_addr != 0) {
+                low = __raw_readl( z3_fpga_base_addr + Z3_FPGA_TSO_STC_PCR_DELTA_LOW );
+
+                high = __raw_readw( z3_fpga_base_addr + Z3_FPGA_TSO_STC_PCR_DELTA_HIGH );
+        }
+
+        retval = high;
+        retval <<= 16;
+        retval += low;
+
+        *delta_27mhz_ticks = retval;
+}
+EXPORT_SYMBOL(z3_fpga_tso_pcr_delta_read);
+
+void z3_fpga_set_pll_vidin_reference( enum z3_fpga_pll_vidin_reference ref)
+{
+        switch (ref)
+        {
+
+        case Z3_FPGA_PLL_VIDIN0_REFERENCE:
+        default:
+                z3_fpga_pll_ctrl_vidin = 0;
+                break;
+
+        case Z3_FPGA_PLL_VIDIN1_REFERENCE:
+                z3_fpga_pll_ctrl_vidin = 0x100;
+                break;
+        }
+
+        z3_fpga_write( z3_fpga_pll_ctrl_vidin|z3_fpga_pll_ctrl_divide, Z3_FPGA_PLL_CTRL_OFFSET);
+}
+EXPORT_SYMBOL(z3_fpga_set_pll_vidin_reference);
+
+
+
+#ifdef CONFIG_PROC_FS
+
+static int
+z3_fpga_tso_pcr_delta_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+     char *p = page;
+     int len;
+
+     int retries;
+
+     s64 val1;
+     s64 val2;
+
+
+     z3_fpga_tso_pcr_delta_read( &val1 );
+     for ( retries = 0, val2=val1^1;
+           val2 != val1 ;
+           retries++ ) {
+
+             if ( retries >= 3 ) {
+                     printk( KERN_ERR "%s: value not stable\n", __FUNCTION__ );
+
+                     return -EINVAL;
+             }
+
+             z3_fpga_tso_pcr_delta_read( &val2 );
+     }
+
+     p += sprintf(p, "%lld\n", val2 );
+     len = (p - page) - off;
+     if (len < 0)
+          len = 0;
+
+     *eof = (len <= count) ? 1 : 0;
+     *start = page + off;
+
+     return len;
+}
+
+static int
+z3_fpga_stc_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+     char *p = page;
+     int len;
+     u64 base;
+     u32 ext;
+     struct timespec ts;
+     u64 ns;
+
+     u64 stc0_27mhz;
+
+     u32 gptimer2_27mhz;
+
+     z3_fpga_stc_read(&base, &ext, &ts, &stc0_27mhz, &gptimer2_27mhz);
+
+     ns = ts.tv_sec;
+     ns *= NSEC_PER_SEC;
+     ns += ts.tv_nsec;
+
+     p += sprintf(p, "%10llu:%03u %llu %llu %lu\n", base, ext, ns, stc0_27mhz, (unsigned long)gptimer2_27mhz );
+     len = (p - page) - off;
+     if (len < 0)
+          len = 0;
+
+     *eof = (len <= count) ? 1 : 0;
+     *start = page + off;
+
+     return len;
+}
+
+
+
+static int
+z3_fpga_proc_read(u16 value, char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+	char *p = page;
+	int len;
+
+        p += sprintf(p, "0x%04x\n", value );
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int
+z3_fpga_proc_read_u32(u32 value, char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+	char *p = page;
+	int len;
+
+        p += sprintf(p, "0x%08x\n", value );
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int z3_fpga_proc_write(const char *reg_name, int reg_offset,
+                                 struct file *file, const char __user *buffer,
+                                 unsigned long count, void *data)
+{
+        char scanbuf[32];
+        int  len = 0;
+        int  status;
+        unsigned long new_latch_value;
+
+        len = count;
+        if ( len > sizeof(scanbuf)-1 ) {
+             len = sizeof(scanbuf)-1;
+        }
+
+        if ( copy_from_user( scanbuf, buffer, len ) ) {
+             return -EFAULT;
+        }
+
+        scanbuf[len] = '\0';
+
+        status = strict_strtoul( scanbuf, 0, &new_latch_value );
+        if ( status ) {
+             printk( KERN_ERR "/proc/fpga/%s: Invalid value %s\n", reg_name, scanbuf );
+             return status;
+        }
+
+        if ( new_latch_value >= 65536 ) {
+             printk( KERN_ERR "/proc/fpga/%s: Invalid value %s\n", reg_name, scanbuf );
+             return -EINVAL;
+        }
+
+        z3_fpga_write( (u16) new_latch_value, reg_offset);
+
+	return count;
+}
+
+
+static int
+z3_fpga_latch_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                        void *data, u16 *latch_value)
+{
+
+     return z3_fpga_proc_read( *latch_value,
+                               page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_latch_proc_write(const char *reg_name, struct file *file, const char __user *buffer,
+                         unsigned long count, void *data, u16 *latch_value)
+{
+        char scanbuf[32];
+        int  len = 0;
+        int  status;
+        unsigned long new_latch_value;
+
+        len = count;
+        if ( len > sizeof(scanbuf)-1 ) {
+             len = sizeof(scanbuf)-1;
+        }
+
+        if ( copy_from_user( scanbuf, buffer, len ) ) {
+             return -EFAULT;
+        }
+
+        scanbuf[len] = '\0';
+
+        status = strict_strtoul( scanbuf, 0, &new_latch_value );
+        if ( status ) {
+             printk( KERN_ERR "/proc/fpga/%s: Invalid value %s\n", reg_name, scanbuf );
+             return status;
+        }
+
+        if ( new_latch_value >= 65536 ) {
+             printk( KERN_ERR "/proc/fpga/%s: Invalid value %s\n", reg_name, scanbuf );
+             return -EINVAL;
+        }
+
+        *latch_value = new_latch_value;
+        z3_fpga_latch_write( latch_value );
+
+	return count;
+}
+
+static int
+z3_fpga_latch_proc_write_mask(const char *reg_name, struct file *file, const char __user *buffer,
+                              unsigned long count, void *data, u16 *latch_value, u16 mask)
+{
+        char scanbuf[32];
+        int  len = 0;
+        int  status;
+        unsigned long new_latch_value;
+
+        len = count;
+        if ( len > sizeof(scanbuf)-1 ) {
+             len = sizeof(scanbuf)-1;
+        }
+
+        if ( copy_from_user( scanbuf, buffer, len ) ) {
+             return -EFAULT;
+        }
+
+        scanbuf[len] = '\0';
+
+        status = strict_strtoul( scanbuf, 0, &new_latch_value );
+        if ( status ) {
+             printk( KERN_ERR "/proc/fpga/%s: Invalid value %s\n", reg_name, scanbuf );
+             return status;
+        }
+
+        if ( new_latch_value >= 65536 ) {
+             printk( KERN_ERR "/proc/fpga/%s: Invalid value %s\n", reg_name, scanbuf );
+             return -EINVAL;
+        }
+
+        new_latch_value = ((*latch_value) & ~mask) | (new_latch_value ? mask : 0 );
+
+        *latch_value = new_latch_value;
+        z3_fpga_latch_write( latch_value );
+
+	return count;
+}
+
+
+static int
+z3_fpga_latch1_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                         void *data)
+{
+        return z3_fpga_latch_proc_read( page, start, off,
+                                 count, eof, data, &z3_fpga_latch1_value );
+}
+
+static int
+z3_fpga_latch1_proc_write(struct file *file, const char __user *buffer,
+                         unsigned long count, void *data)
+{
+        return z3_fpga_latch_proc_write( "latch1", file, buffer,
+                                  count, data, &z3_fpga_latch1_value );
+}
+
+static int
+z3_fpga_latch2_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                         void *data)
+{
+        return z3_fpga_latch_proc_read( page, start, off,
+                                 count, eof, data, &z3_fpga_latch2_value );
+}
+
+
+static int
+z3_fpga_latch2_proc_write(struct file *file, const char __user *buffer,
+                         unsigned long count, void *data)
+{
+        return z3_fpga_latch_proc_write( "latch2", file, buffer,
+                                  count, data, &z3_fpga_latch2_value );
+}
+
+
+
+static int
+z3_fpga_gpio_proc_read(int gpio, char *page, char **start, off_t off, int count, int *eof,
+                       void *data)
+{
+        u16 value;
+
+        value = gpio_get_value( gpio);
+
+        return z3_fpga_proc_read( value,
+                               page, start, off, count, eof, data );
+
+}
+
+static int z3_fpga_gpio_proc_write(char *reg_name, int gpio,
+                                 struct file *file, const char __user *buffer,
+                                 unsigned long count, void *data)
+{
+        char scanbuf[32];
+        int  len = 0;
+        int  status;
+        unsigned long new_gpio_value;
+
+        len = count;
+        if ( len > sizeof(scanbuf)-1 ) {
+             len = sizeof(scanbuf)-1;
+        }
+
+        if ( copy_from_user( scanbuf, buffer, len ) ) {
+             return -EFAULT;
+        }
+
+        scanbuf[len] = '\0';
+
+        status = strict_strtoul( scanbuf, 0, &new_gpio_value );
+        if ( status ) {
+             printk( KERN_ERR "/proc/fpga/%s: Invalid value %s\n", reg_name, scanbuf );
+             return status;
+        }
+
+        gpio_set_value( gpio, new_gpio_value );
+
+	return count;
+}
+
+
+
+static int
+z3_fpga_fpga_initb_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+
+        return z3_fpga_gpio_proc_read( Z3_APP_31_GPIO_FPGA_INITB,
+                                  page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_fpga_initb_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+        return z3_fpga_gpio_proc_write( "fpga_initb", Z3_APP_31_GPIO_FPGA_INITB,
+                                   file, buffer, count, data );
+}
+
+
+static int
+z3_fpga_fpga_csb_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+
+        return z3_fpga_gpio_proc_read( Z3_APP_31_GPIO_FPGA_CSB,
+                                  page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_fpga_csb_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+        return z3_fpga_gpio_proc_write( "fpga_csb", Z3_APP_31_GPIO_FPGA_CSB,
+                                   file, buffer, count, data );
+}
+
+
+
+static int
+z3_fpga_asi_ctl_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+
+     return z3_fpga_proc_read( z3_fpga_read(Z3_FPGA_ASI_CTL_OFFSET),
+                                  page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_asi_ctl_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+     return z3_fpga_proc_write( "asi_ctl", Z3_FPGA_ASI_CTL_OFFSET,
+                                   file, buffer, count, data );
+}
+
+static int
+z3_fpga_tso_pcr_pid_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+
+     return z3_fpga_proc_read( z3_fpga_read(Z3_FPGA_TSO_PCR_PID_OFFSET),
+                                  page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_tso_pcr_pid_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+     return z3_fpga_proc_write( "tso_pcr_pid", Z3_FPGA_TSO_PCR_PID_OFFSET,
+                                   file, buffer, count, data );
+}
+
+
+static int
+z3_fpga_sdi_out_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+
+     return z3_fpga_proc_read( z3_fpga_read(Z3_FPGA_SDI_OUT_OFFSET),
+                                  page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_sdi_out_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+     return z3_fpga_proc_write( "sdi_out", Z3_FPGA_SDI_OUT_OFFSET,
+                                   file, buffer, count, data );
+}
+
+static int
+z3_fpga_fpga_prog_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+        u16 value;
+
+        value = (z3_fpga_latch1_value & Z3_APP31_Y2_FPGA_PROG) ? 1 : 0;
+
+        return z3_fpga_proc_read( value,
+                                  page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_fpga_prog_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+
+        char scanbuf[32];
+        int  len = 0;
+        int  status;
+        unsigned long new_latch_value;
+
+        len = count;
+        if ( len > sizeof(scanbuf)-1 ) {
+             len = sizeof(scanbuf)-1;
+        }
+
+        if ( copy_from_user( scanbuf, buffer, len ) ) {
+             return -EFAULT;
+        }
+
+        scanbuf[len] = '\0';
+
+        status = strict_strtoul( scanbuf, 0, &new_latch_value );
+        if ( status ) {
+             printk( KERN_ERR "/proc/fpga/fpga_prog: Invalid value %s\n", scanbuf );
+             return status;
+        }
+
+        if ( new_latch_value == 0 ) {
+          if ( cpu_is_ti816x() ) {
+                  /* Convert GPMC_A[3-6] to GPIO's for FPGA M[2:0] */
+                  omap_mux_init_signal( "gp0_io11", TI81XX_MUX_PULLDIS );
+                  omap_mux_init_signal( "gp0_io12", TI81XX_MUX_PULLDIS );
+                  omap_mux_init_signal( "gp0_io13", TI81XX_MUX_PULLDIS );
+                  omap_mux_init_signal( "gp0_io14", TI81XX_MUX_PULLDIS );
+          }
+        }
+
+        return z3_fpga_latch_proc_write_mask( "fpga_prog", file, buffer,
+                                              count, data, &z3_fpga_latch1_value, Z3_APP31_Y2_FPGA_PROG );
+
+}
+
+static int
+z3_fpga_fpga_done_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+        u16 value = 0;
+
+        z3_fpga_latch1_read(&value);
+        value = (value& Z3_APP31_Y4_FPGA_DONE) ? 1 : 0;
+
+        if ( value != 0 ) {
+          if ( cpu_is_ti816x() ) {
+                  omap_mux_init_signal( "gpmc_a3", TI81XX_MUX_PULLDIS );
+                  omap_mux_init_signal( "gpmc_a4", TI81XX_MUX_PULLDIS );
+                  omap_mux_init_signal( "gpmc_a5", TI81XX_MUX_PULLDIS );
+                  omap_mux_init_signal( "gpmc_a6", TI81XX_MUX_PULLDIS );
+          }
+        }
+
+        return z3_fpga_proc_read( value,
+                                  page, start, off, count, eof, data );
+}
+
+static const char *z3_pll_settings[] = {
+     [Z3_FPGA_PLL_NONE] = "none",
+     [Z3_FPGA_PLL_VIDIN_74M25]   = "vidin_74m25",
+     [Z3_FPGA_PLL_VIDIN_74M176]  = "vidin_74m176",
+     [Z3_FPGA_PLL_VIDIN_148M5]   = "vidin_148m5",
+     [Z3_FPGA_PLL_VIDIN_148M352]  = "vidin_148m352",
+     [Z3_FPGA_PLL_VIDIN_27M]     = "vidin_27m",
+     [Z3_FPGA_PLL_VIDIN_13M5]     = "vidin_13m5",
+     [Z3_FPGA_PLL_VIDOUT_74M176] = "vidout_74m176",
+     [Z3_FPGA_PLL_VIDOUT_27M]    = "vidout_27m",
+     [Z3_FPGA_PLL_OUTPUT_DISABLE] = "output_disable",
+};
+
+
+
+static const char *z3_fpga_pll_setting_to_string( enum z3_fpga_pll_setting setting )
+{
+     if ( setting < Z3_FPGA_PLL_SETTING_COUNT
+          && z3_pll_settings[setting] != NULL )
+     {
+          return z3_pll_settings[setting];
+     }
+     else
+     {
+          return "unknown";
+     }
+}
+
+static enum z3_fpga_pll_setting z3_fpga_pll_string_to_setting( const char *str )
+{
+     enum z3_fpga_pll_setting setting = Z3_FPGA_PLL_NONE;
+     int len;
+
+     for ( setting = 0;
+           setting < Z3_FPGA_PLL_SETTING_COUNT;
+           setting++ ) {
+          if ( NULL == z3_pll_settings[setting] )
+               continue;
+
+          len = strlen(z3_pll_settings[setting]);
+          if ( 0 == strnicmp( str, z3_pll_settings[setting], len ) ) {
+               break;
+          }
+     }
+
+     return setting;
+}
+
+static int
+z3_fpga_pll_setting_proc_read(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+	char *p = page;
+	int len;
+
+        p += sprintf(p, "%s\n", z3_fpga_pll_setting_to_string(z3_fpga_pll_setting) );
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int
+z3_fpga_pll_setting_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+     enum z3_fpga_pll_setting setting;
+     char scanbuf[32];
+     int len = 0;
+
+     len = count;
+     if ( len > sizeof(scanbuf)-1 ) {
+          len = sizeof(scanbuf)-1;
+     }
+
+     if ( copy_from_user( scanbuf, buffer, len ) ) {
+          return -EFAULT;
+     }
+
+     scanbuf[len] = '\0';
+
+     setting = z3_fpga_pll_string_to_setting(scanbuf);
+
+     if ( setting < Z3_FPGA_PLL_SETTING_COUNT ) {
+          if ( 0 == z3_fpga_pll_setup(setting) )
+               return count;
+          else
+               return -EIO;
+     } else {
+          return -EINVAL;
+     }
+}
+
+static int
+z3_fpga_version_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                              void *data)
+{
+        return z3_fpga_proc_read( z3_fpga_read_version(),
+                                     page, start, off, count, eof, data );
+}
+
+
+
+ static int
+z3_fpga_pll_load_pf_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+     char scanbuf[32];
+     int len = 0;
+     int status;
+     unsigned long new_value;
+
+     len = count;
+     if ( len > sizeof(scanbuf)-1 ) {
+          len = sizeof(scanbuf)-1;
+     }
+
+     if ( copy_from_user( scanbuf, buffer, len ) ) {
+          return -EFAULT;
+     }
+
+      scanbuf[len] = '\0';
+
+     if (scanbuf[0] == '0' && scanbuf[1] == 'x' ) {
+        status = strict_strtoul( scanbuf, 16, &new_value );
+     }
+     else {
+          status = strict_strtoul( scanbuf, 10, &new_value );
+     }
+     if ( status ) {
+          printk( KERN_ERR "/proc/fpga/pll_load_pf: Invalid value %s\n", scanbuf );
+          return status;
+     }
+
+     z3_fpga_pll_load_pf = (new_value & 0xffff);
+
+     if ( z3_fpga_pll_load_pf > 20 ) {
+             z3_fpga_pll_load_pf = 20;
+             printk( KERN_DEBUG "/proc/fpga/pll_load_pf: Value [%s] too large, set to max %u\n", scanbuf, z3_fpga_pll_load_pf );
+     }
+
+     if ( z3_fpga_pll_client != NULL ) {
+             status = z3_fpga_i2c_pll_wr( 0x05, z3_fpga_pll_load_pf*8 );	// Crystal load capacitance
+
+             if ( status < 0 )
+                     return status;
+     }
+
+     return count;
+}
+
+static int
+z3_fpga_pll_load_pf_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                              void *data)
+{
+	char *p = page;
+	int len;
+
+        p += sprintf(p, "%u\n", z3_fpga_pll_load_pf );
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int
+z3_fpga_pll_lock_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                              void *data)
+{
+	char *p = page;
+	int len;
+
+        int reg_value;
+        int lock_value;
+
+
+        reg_value = (z3_fpga_read(Z3_FPGA_PLL_CTRL_OFFSET)) ;
+        lock_value = (reg_value & Z3_FPGA_PLL_CTRL_LOCK_MASK) ? 1 : 0;
+
+        p += sprintf(p, "%u\n", lock_value );
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int z3_fpga_do_pll_load_scan(void)
+{
+        int load_pf;
+        int load_pf_min = 0;
+        int load_pf_max = 20;
+
+        int ret = 0;
+
+        int sleep_ms;
+        int sleep_factor;
+
+        int reg_value;
+
+        switch (z3_fpga_pll_setting)
+        {
+        case Z3_FPGA_PLL_VIDIN_148M5:
+        case Z3_FPGA_PLL_VIDIN_148M352:
+                /* Incoming clock is stable now, use normal wait */
+                sleep_factor = 1;
+                break;
+        default:
+                sleep_factor = 1;
+                break;
+        }
+
+        z3_fpga_load_pf_min_lock = -1;
+        z3_fpga_load_pf_max_lock = -1;
+        z3_fpga_pll_load_scanned = 0;
+
+        mutex_lock( &z3_fpga_pll_load_scan_mutex );
+
+        for (load_pf = load_pf_min, sleep_ms = 200*sleep_factor;
+             load_pf <= load_pf_max;
+             load_pf+=2, sleep_ms=100*sleep_factor ) {
+
+                ret |= z3_fpga_i2c_pll_wr( 0x05, load_pf*8 );
+                if ( msleep_interruptible( sleep_ms ) ) {
+                        ret =  -ERESTARTSYS;
+                        goto unlock_out;
+                }
+
+                reg_value = (z3_fpga_read(Z3_FPGA_PLL_CTRL_OFFSET)) ;
+                if  (reg_value & Z3_FPGA_PLL_CTRL_LOCK_MASK) {
+                        if ( z3_fpga_load_pf_min_lock < 0 ) {
+                                z3_fpga_load_pf_min_lock = load_pf;
+                        }
+
+                        if ( z3_fpga_load_pf_max_lock < load_pf ) {
+                                z3_fpga_load_pf_max_lock = load_pf;
+                        }
+                } else {
+                        /* Range must be continuous */
+                        if ( z3_fpga_load_pf_min_lock >= 0 ) {
+                                break;
+                        }
+                }
+        }
+
+
+        /* Restore load value */
+        ret |= z3_fpga_i2c_pll_wr( 0x05, z3_fpga_pll_load_pf*8 );
+        (void) msleep_interruptible( 100 );
+
+        z3_fpga_pll_load_scanned = 1;
+
+unlock_out:
+        mutex_unlock( &z3_fpga_pll_load_scan_mutex );
+        return ret;
+}
+
+static int
+z3_fpga_pll_load_scan_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+        int ret;
+
+        ret = z3_fpga_do_pll_load_scan();
+        if ( -ERESTARTSYS == ret )
+                return ret;
+        else if ( 0 == ret )
+                return count;
+        else
+                return -EIO;
+}
+
+
+static int
+z3_fpga_pll_load_scan_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                                   void *data)
+{
+	char *p = page;
+	int len;
+
+        p += sprintf(p, "%d %d\n",
+                     z3_fpga_load_pf_min_lock,
+                     z3_fpga_load_pf_max_lock
+                );
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+
+static int
+z3_fpga_clk_rate_proc_write(const char *clk_name, struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+        char scanbuf[32];
+        int len = 0;
+        int status;
+        struct clk *clk;
+        unsigned long target_rate;
+        const unsigned long target_rate_min = 64000;
+
+        len = count;
+        if ( len > sizeof(scanbuf)-1 ) {
+                len = sizeof(scanbuf)-1;
+        }
+
+        if ( copy_from_user( scanbuf, buffer, len ) ) {
+                return -EFAULT;
+        }
+
+        scanbuf[len] = '\0';
+
+        clk = clk_get( NULL, clk_name );
+        if ( NULL == clk )
+                return -EINVAL;
+
+        status = strict_strtoul( scanbuf, 10, &target_rate );
+        if ( status )
+        {
+                printk( KERN_ERR "%s: Invalid value %s\n", __FUNCTION__, scanbuf );
+        }
+        if ( target_rate < target_rate_min ) {
+                printk( KERN_ERR "%s: Value %lu too small\n", __FUNCTION__, target_rate );
+                count = -ERANGE;
+        } else {
+                clk_set_rate( clk, target_rate );
+        }
+
+        clk_put( clk );
+
+        return count;
+}
+
+static int
+z3_fpga_clk_rate_proc_read(const char *clk_name, char *page, char **start, off_t off, int count, int *eof,
+                                   void *data)
+{
+        struct clk *clk;
+        unsigned long rate;
+	char *p = page;
+	int len;
+
+        /* Make sure clocks are up-to-date */
+        recalculate_root_clocks();
+
+        clk = clk_get( NULL, clk_name );
+        if ( NULL == clk )
+                return -EINVAL;
+
+        rate = clk_get_rate( clk );
+
+        clk_put( clk );
+
+        p += sprintf(p, "%lu\n", rate );
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int
+z3_fpga_tso_pll_rate_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                                   void *data)
+{
+        return z3_fpga_clk_rate_proc_read( z3_fpga_tso_pll_clk_name,
+                                           page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_tso_pll_rate_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+        return z3_fpga_clk_rate_proc_write( z3_fpga_tso_pll_clk_name,
+                                            file,
+                                            buffer,
+                                            count,
+                                            data );
+}
+
+
+static int
+z3_fpga_sdiout_audio_rate_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                                   void *data)
+{
+        return z3_fpga_clk_rate_proc_read( z3_fpga_sdiout_audio_pll_clk_name,
+                                           page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_sdiout_audio_rate_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+        return z3_fpga_clk_rate_proc_write( z3_fpga_sdiout_audio_pll_clk_name,
+                                            file,
+                                            buffer,
+                                            count,
+                                            data );
+}
+
+static int
+z3_fpga_sdiout_video_rate_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                                   void *data)
+{
+        return z3_fpga_clk_rate_proc_read( z3_fpga_sdiout_video_pll_clk_name,
+                                           page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_sdiout_video_rate_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+        return z3_fpga_clk_rate_proc_write( z3_fpga_sdiout_video_pll_clk_name,
+                                            file,
+                                            buffer,
+                                            count,
+                                            data );
+}
+
+static int z3_fpga_pll_init( void )
+{
+     struct i2c_adapter *i2c_adap;
+
+     if ( z3_fpga_board_id_value == Z3_BOARD_ID_APP_31 ) {
+             if ( NULL == z3_fpga_pll_client ) {
+                     i2c_adap = i2c_get_adapter(z3_fpga_pll_adapter_id);
+                     if ( NULL != i2c_adap ) {
+                             z3_fpga_pll_client = i2c_new_device(i2c_adap, &pll_board_info);
+                     } else {
+                             printk( KERN_DEBUG "%s: ERROR: PLL adapter %d\n", __FUNCTION__, z3_fpga_pll_adapter_id );
+                     }
+
+                     if ( NULL != z3_fpga_pll_client ) {
+                             i2c_set_clientdata(z3_fpga_pll_client, NULL);
+
+                             z3_fpga_pll_setup(z3_fpga_pll_setting);
+                     }
+             }
+     }
+
+     return 0;
+}
+
+static int
+z3_fpga_board_id_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                              void *data)
+{
+
+     return z3_fpga_proc_read( z3_fpga_board_id_value,
+                                  page, start, off, count, eof, data );
+}
+
+static int
+z3_fpga_board_id_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+     char scanbuf[32];
+     int len = 0;
+     int status;
+     unsigned long new_value;
+
+     len = count;
+     if ( len > sizeof(scanbuf)-1 ) {
+          len = sizeof(scanbuf)-1;
+     }
+
+     if ( copy_from_user( scanbuf, buffer, len ) ) {
+          return -EFAULT;
+     }
+
+      scanbuf[len] = '\0';
+
+     if (scanbuf[0] == '0' && scanbuf[1] == 'x' ) {
+        status = strict_strtoul( scanbuf, 16, &new_value );
+     }
+     else {
+          status = strict_strtoul( scanbuf, 2, &new_value );
+     }
+     if ( status ) {
+          printk( KERN_ERR "/proc/fpga/board_id: Invalid value %s\n", scanbuf );
+          return status;
+     }
+
+     z3_fpga_board_id_value = (new_value & 0xffff);
+
+     z3_fpga_pll_init();
+
+     return count;
+}
+
+
+u16 z3_fpga_board_id(void)
+{
+        return z3_fpga_board_id_value;
+}
+EXPORT_SYMBOL(z3_fpga_board_id);
+
+
+static int
+z3_fpga_register_proc_write(u32 *reg, struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+     char scanbuf[32];
+     int len = 0;
+     int status;
+     unsigned long new_value;
+
+     len = count;
+     if ( len > sizeof(scanbuf)-1 ) {
+          len = sizeof(scanbuf)-1;
+     }
+
+     if ( copy_from_user( scanbuf, buffer, len ) ) {
+          return -EFAULT;
+     }
+
+      scanbuf[len] = '\0';
+
+     if (scanbuf[0] == '0' && scanbuf[1] == 'x' ) {
+        status = strict_strtoul( scanbuf, 16, &new_value );
+     }
+     else {
+          status = strict_strtoul( scanbuf, 2, &new_value );
+     }
+     if ( status ) {
+          printk( KERN_ERR "Invalid value %s\n", scanbuf );
+          return status;
+     }
+
+     *reg = new_value;
+
+     return count;
+}
+
+
+static const char *z3_fpga_audio_src_settings[] = {
+     [Z3_FPGA_AUDIO_SRC_DISABLE] = "disable",
+     [Z3_FPGA_AUDIO_SRC_ENABLE]  = "enable",
+};
+
+static const char *z3_fpga_audio_src_to_string( enum z3_fpga_audio_src setting )
+{
+     if ( setting < Z3_FPGA_AUDIO_SRC_SETTING_COUNT
+          && z3_fpga_audio_src_settings[setting] != NULL )
+     {
+          return z3_fpga_audio_src_settings[setting];
+     }
+     else
+     {
+          return "unknown";
+     }
+}
+
+static enum z3_fpga_audio_src z3_fpga_audio_src_string_to_setting( const char *str )
+{
+     enum z3_fpga_audio_src setting;
+     int len;
+
+     for ( setting = 0;
+           setting < Z3_FPGA_AUDIO_SRC_SETTING_COUNT;
+           setting++ ) {
+          if ( NULL == z3_fpga_audio_src_settings[setting] )
+               continue;
+
+          len = strlen(z3_fpga_audio_src_settings[setting]);
+          if ( 0 == strnicmp( str, z3_fpga_audio_src_settings[setting], len ) ) {
+               break;
+          }
+     }
+
+     return setting;
+}
+
+
+static int
+z3_fpga_audio_src_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                               void *data)
+{
+	char *p = page;
+	int len;
+
+        p += sprintf(p, "%s\n", z3_fpga_audio_src_to_string(z3_fpga_audio_src) );
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+static int z3_fpga_audio_update(void)
+{
+        u16 audio_src_mask;
+
+        if ( z3_fpga_get_aic_disable() ) {
+                if ( z3_fpga_audio_src == Z3_FPGA_AUDIO_SRC_ENABLE )
+                        audio_src_mask = 0x10;
+                else
+                        audio_src_mask = 0x00;
+
+                z3_fpga_write( 0x103|audio_src_mask, Z3_FPGA_AUDIO_HDMI_OFFSET );
+        } else {
+                if ( z3_fpga_aic_ext_master ) {
+                        /* Must set SRC to get master clocks */
+                        // SCLK = MCLK/8, drive MCLK+SCLK_LRCK, LRCLK = SCLK/32 (16 bits per sample)
+                        z3_fpga_write( (z3_fpga_aic_ext_master_div_mask|0x012), Z3_FPGA_AUDIO_HDMI_OFFSET );
+                } else {
+                        z3_fpga_write( 0x0, Z3_FPGA_AUDIO_HDMI_OFFSET );
+                }
+        }
+
+        return 0;
+}
+
+int
+z3_fpga_audio_src_setup(enum z3_fpga_audio_src setting)
+{
+     z3_fpga_audio_src = setting;
+
+     return z3_fpga_audio_update();
+}
+
+static int
+z3_fpga_audio_src_proc_write(struct file *file, const char __user *buffer,
+                                unsigned long count, void *data)
+{
+     enum z3_fpga_audio_src setting;
+
+     setting = z3_fpga_audio_src_string_to_setting(buffer);
+     if ( setting < Z3_FPGA_AUDIO_SRC_SETTING_COUNT ) {
+          if ( 0 == z3_fpga_audio_src_setup(setting) )
+               return count;
+          else
+               return -EIO;
+     } else {
+          return -EINVAL;
+     }
+}
+
+
+
+static const char *z3_fpga_audio_input_settings[] = {
+     [Z3_FPGA_AUDIO_INPUT_1_2] =  "1+2",
+     [Z3_FPGA_AUDIO_INPUT_3_4]  = "3+4",
+     [Z3_FPGA_AUDIO_INPUT_5_6]  = "5+6",
+     [Z3_FPGA_AUDIO_INPUT_7_8]  = "7+8",
+};
+
+static const char *z3_fpga_audio_input_to_string( enum z3_fpga_audio_input setting )
+{
+     if ( setting < Z3_FPGA_AUDIO_INPUT_SETTING_COUNT
+          && z3_fpga_audio_input_settings[setting] != NULL )
+     {
+          return z3_fpga_audio_input_settings[setting];
+     }
+     else
+     {
+          return "unknown";
+     }
+}
+
+static enum z3_fpga_audio_input z3_fpga_audio_input_string_to_setting( const char *str )
+{
+     enum z3_fpga_audio_input setting;
+     int len;
+
+     for ( setting = 0;
+           setting < Z3_FPGA_AUDIO_INPUT_SETTING_COUNT;
+           setting++ ) {
+          if ( NULL == z3_fpga_audio_input_settings[setting] )
+               continue;
+
+          len = strlen(z3_fpga_audio_input_settings[setting]);
+          if ( 0 == strnicmp( str, z3_fpga_audio_input_settings[setting], len ) ) {
+               break;
+          }
+     }
+
+     return setting;
+}
+
+
+static int
+z3_fpga_audio_input_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                               void *data)
+{
+	char *p = page;
+	int len;
+
+        p += sprintf(p, "%s\n", z3_fpga_audio_input_to_string(z3_fpga_audio_input) );
+	len = (p - page) - off;
+	if (len < 0)
+		len = 0;
+
+	*eof = (len <= count) ? 1 : 0;
+	*start = page + off;
+
+	return len;
+}
+
+int
+z3_fpga_audio_input_setup(enum z3_fpga_audio_input setting)
+{
+     z3_fpga_audio_input = setting;
+
+     return z3_fpga_audio_update();
+}
+
+static int
+z3_fpga_audio_input_proc_write(struct file *file, const char __user *buffer,
+                                unsigned long count, void *data)
+{
+     enum z3_fpga_audio_input setting;
+
+     setting = z3_fpga_audio_input_string_to_setting(buffer);
+     if ( setting < Z3_FPGA_AUDIO_INPUT_SETTING_COUNT ) {
+          if ( 0 == z3_fpga_audio_input_setup(setting) )
+               return count;
+          else
+               return -EIO;
+     } else {
+          return -EINVAL;
+     }
+}
+
+
+static u32 *z3_fpga_sdiout_audio_pll_fracfreq = (u32 *)TI816X_AUDIOPLL_FREQ3; // SYSCLK20
+static u32 *z3_fpga_sdiout_video_pll_fracfreq = (u32 *)TI816X_VIDEOPLL_FREQ2; // Video DCLK
+
+static int
+z3_fpga_sdiout_audio_pll_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                              void *data)
+{
+        return z3_fpga_proc_read_u32( *z3_fpga_sdiout_audio_pll_fracfreq,
+                                      page,
+                                      start,
+                                      off,
+                                      count,
+                                      eof,
+                                      data );
+}
+
+static int
+z3_fpga_sdiout_audio_pll_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+        int ret;
+
+        ret =  z3_fpga_register_proc_write( z3_fpga_sdiout_audio_pll_fracfreq,
+                                            file,
+                                            buffer,
+                                            count,
+                                            data );
+
+        recalculate_root_clocks();
+
+        return ret;
+}
+
+static int
+z3_fpga_sdiout_video_pll_proc_read(char *page, char **start, off_t off, int count, int *eof,
+                              void *data)
+{
+        return z3_fpga_proc_read_u32( *z3_fpga_sdiout_video_pll_fracfreq,
+                                      page,
+                                      start,
+                                      off,
+                                      count,
+                                      eof,
+                                      data );
+}
+
+static int
+z3_fpga_sdiout_video_pll_proc_write(struct file *file, const char __user *buffer,
+                            unsigned long count, void *data)
+{
+        int ret;
+
+        ret = z3_fpga_register_proc_write( z3_fpga_sdiout_video_pll_fracfreq,
+                                            file,
+                                            buffer,
+                                            count,
+                                            data );
+
+        recalculate_root_clocks();
+
+        return ret;
+}
+
+
+void
+z3_fpga_set_aic_ext_master( int value )
+{
+        z3_fpga_aic_ext_master = value;
+}
+EXPORT_SYMBOL( z3_fpga_set_aic_ext_master );
+
+int
+z3_fpga_get_aic_ext_master( void )
+{
+        return z3_fpga_aic_ext_master;
+}
+EXPORT_SYMBOL( z3_fpga_get_aic_ext_master );
+
+
+int z3_fpga_set_aic_ext_master_sample_rate(unsigned int rate)
+{
+        switch (rate) {
+
+        case 48000: // divide by 8
+                z3_fpga_aic_ext_master_div_mask = 0x2000;
+                break;
+        case 32000: // divide by 12
+                z3_fpga_aic_ext_master_div_mask = 0x3000;
+                break;
+        case 24000:
+                z3_fpga_aic_ext_master_div_mask = 0x4000;
+                break;
+        case 16000:
+                z3_fpga_aic_ext_master_div_mask = 0x5000;
+                break;
+        default:
+                return -EINVAL;
+        }
+
+        return 0;
+}
+
+void
+z3_fpga_set_aic_disable( int value )
+{
+        if ( !z3_fpga_valid_aic_disable_board_id() ) {
+                return;
+        }
+
+        if ( value ) {
+                z3_fpga_latch1_value |= Z3_APP31_Y2_AIC_DIS;
+        } else {
+                z3_fpga_latch1_value &= ~Z3_APP31_Y2_AIC_DIS;
+        }
+
+        z3_fpga_latch_write( &z3_fpga_latch1_value );
+
+        z3_fpga_audio_update();
+}
+EXPORT_SYMBOL( z3_fpga_set_aic_disable );
+
+
+int
+z3_fpga_get_aic_disable( void )
+{
+        if ( !z3_fpga_valid_aic_disable_board_id() ) {
+                return 0;
+        }
+
+        if ( 0 != (Z3_APP31_Y2_AIC_DIS & z3_fpga_latch1_value) ) {
+                return 1;
+        } else {
+                return 0;
+        }
+}
+EXPORT_SYMBOL( z3_fpga_get_aic_disable );
+
+#endif
+
+static void z3_fpga_timer_function(unsigned long data)
+{
+
+
+     mod_timer( &z3_fpga_timer, jiffies + msecs_to_jiffies( z3_fpga_timeout_ms ) );
+}
+
+
+int z3_fpga_init(int board_id_gpio)
+{
+#ifdef CONFIG_PROC_FS
+        struct proc_dir_entry *res_dir;
+        struct proc_dir_entry *res_file;
+#endif
+        int ret = 0;
+        int cnt;
+
+        unsigned int id_mask, led_mask;
+
+        int i,j;
+
+        static u8 z3_fpga_board_ids[1024];
+
+        z3_latch_base_addr = ioremap_nocache(Z3_LATCH_BASE_ADDR,
+                                             Z3_LATCH_ADDR_SIZE);
+        if (!z3_latch_base_addr) {
+                printk(KERN_ERR "Couldn't io map Z3 LATCH registers\n");
+                return -ENXIO;
+        }
+
+#if 0
+        if ( cpu_is_ti816x() && ti81xx_has_tppss() ) {
+                z3_tppss_gbl_base_addr = ioremap_nocache( 0x4a080000,
+                                                          4096 );
+                if ( z3_tppss_gbl_base_addr ) {
+                        z3_tppss_stc0_27mcnt = z3_tppss_gbl_base_addr + 0x818;
+                }
+        }
+#endif
+        mutex_init(&z3_fpga_pll_load_scan_mutex);
+
+
+        /* Read board id */
+
+        if (cpu_is_ti814x())
+                z3_fpga_latch1_value = Z3_APP31_Y2_DM814X|Z3_APP31_Y2_FPGA_PROG;
+        else
+                z3_fpga_latch1_value = Z3_APP31_Y2_FPGA_PROG;
+
+
+        memset( z3_fpga_board_ids, '\0', sizeof(z3_fpga_board_ids) );
+
+        cnt = 0;
+        while ( cnt < 8 ) {
+                z3_fpga_board_id_value = 0;
+                cnt++;
+
+                for ( id_mask = 0x8, led_mask=Z3_APP31_Y2_LED1_R;
+                      id_mask != 0;
+                      id_mask >>= 1, led_mask>>= 1 ) {
+
+                        z3_fpga_latch1_value |= led_mask;
+                        z3_fpga_latch_write(&z3_fpga_latch1_value);
+                        mdelay(50);
+
+                        if ( gpio_get_value( board_id_gpio ) ) {
+                                z3_fpga_board_id_value |= id_mask;
+                        }
+
+                        z3_fpga_latch1_value &= ~led_mask;
+                        z3_fpga_latch_write(&z3_fpga_latch1_value);
+
+                }
+
+                id_mask = 0x10;
+                for ( i = 0x8;
+                      i>1;
+                      i >>= 1 ) {
+                        for ( j = i>>1;
+                              j > 0;
+                              j >>= 1, id_mask <<= 1 ) {
+
+                                led_mask = ((i|j) << 8);
+                                if ( 0 == (z3_fpga_board_id_value & (i|j)) ) {
+                                        z3_fpga_latch1_value |= led_mask;
+                                        z3_fpga_latch_write(&z3_fpga_latch1_value);
+                                        mdelay(50);
+
+                                        if ( gpio_get_value( board_id_gpio ) ) {
+                                                z3_fpga_board_id_value |= id_mask;
+                                        }
+
+                                        z3_fpga_latch1_value &= ~led_mask;
+                                        z3_fpga_latch_write(&z3_fpga_latch1_value);
+                                }
+
+                        }
+
+                }
+
+                z3_fpga_board_id_value &= 0x3ff;
+
+                z3_fpga_board_ids[z3_fpga_board_id_value]++;
+
+                if ( z3_fpga_board_ids[z3_fpga_board_id_value] >= 3 )
+                        break;
+
+//                  printk( KERN_EMERG "Read board id try %d value [%u]\n", cnt,
+//                          z3_fpga_board_id_value
+//                          );
+        }
+
+        for ( cnt=0; cnt<1024; cnt++ ) {
+                if ( z3_fpga_board_ids[cnt] > z3_fpga_board_ids[z3_fpga_board_id_value] ) {
+                        z3_fpga_board_id_value = cnt;
+                }
+        }
+
+
+
+#ifdef CONFIG_PROC_FS
+        res_dir = proc_mkdir("fpga", NULL);
+        if (!res_dir)
+                return -ENOMEM;
+
+        res_file = create_proc_entry("latch1", S_IWUSR | S_IRUGO, res_dir);
+
+        if (!res_file)
+                return -ENOMEM;
+
+        res_file->read_proc  = z3_fpga_latch1_proc_read;
+        res_file->write_proc = z3_fpga_latch1_proc_write;
+
+        res_file = create_proc_entry( "board_id", S_IWUSR | S_IRUGO, res_dir );
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_board_id_proc_read;
+        res_file->write_proc = z3_fpga_board_id_proc_write;
+#endif
+
+        if ( z3_fpga_board_id_value != Z3_BOARD_ID_APP_31 ) {
+                return 0;
+        }
+
+
+        z3_fpga_base_addr = ioremap_nocache(Z3_FPGA_BASE_ADDR,
+                                            Z3_FPGA_ADDR_SIZE);
+        if (!z3_fpga_base_addr) {
+                printk(KERN_ERR "Couldn't io map Z3 FPGA registers\n");
+                return -ENXIO;
+        }
+
+
+        init_timer( &z3_fpga_timer );
+
+        z3_fpga_timer.function = z3_fpga_timer_function;
+        z3_fpga_timer.data     = 0;
+
+        /* Wait until FPGA is loaded before reading STC */
+        mod_timer( &z3_fpga_timer, jiffies + msecs_to_jiffies( 60000 ) );
+
+
+#ifdef CONFIG_PROC_FS
+        res_file = create_proc_entry("latch2", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_latch2_proc_read;
+        res_file->write_proc = z3_fpga_latch2_proc_write;
+
+
+        res_file = create_proc_entry( "stc", S_IRUGO, res_dir );
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_stc_proc_read;
+
+        res_file = create_proc_entry("asi_ctl", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_asi_ctl_proc_read;
+        res_file->write_proc = z3_fpga_asi_ctl_proc_write;
+
+        res_file = create_proc_entry("sdi_out", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_sdi_out_proc_read;
+        res_file->write_proc = z3_fpga_sdi_out_proc_write;
+
+        res_file = create_proc_entry("pll_setting", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_pll_setting_proc_read;
+        res_file->write_proc = z3_fpga_pll_setting_proc_write;
+
+        res_file = create_proc_entry("pll_load_pf", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_pll_load_pf_proc_read;
+        res_file->write_proc = z3_fpga_pll_load_pf_proc_write;
+
+
+        res_file = create_proc_entry("pll_lock", S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_pll_lock_proc_read;
+
+        res_file = create_proc_entry("version", S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_version_proc_read;
+
+        res_file = create_proc_entry("pll_load_scan", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_pll_load_scan_proc_read;
+        res_file->write_proc = z3_fpga_pll_load_scan_proc_write;
+
+        if ( cpu_is_ti816x() ) {
+                res_file = create_proc_entry("tso_pll_rate", S_IWUSR | S_IRUGO, res_dir);
+                if (!res_file)
+                        return -ENOMEM;
+                res_file->read_proc  = z3_fpga_tso_pll_rate_proc_read;
+                res_file->write_proc = z3_fpga_tso_pll_rate_proc_write;
+        }
+
+
+        res_file = create_proc_entry("tso_pcr_delta", S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_tso_pcr_delta_proc_read;
+
+        res_file = create_proc_entry("tso_pcr_pid", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_tso_pcr_pid_proc_read;
+        res_file->write_proc = z3_fpga_tso_pcr_pid_proc_write;
+
+        res_file = create_proc_entry("audio_src", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_audio_src_proc_read;
+        res_file->write_proc = z3_fpga_audio_src_proc_write;
+
+        res_file = create_proc_entry("audio_input", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_audio_input_proc_read;
+        res_file->write_proc = z3_fpga_audio_input_proc_write;
+
+        res_file = create_proc_entry("fpga_prog", S_IWUSR | S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_fpga_prog_proc_read;
+        res_file->write_proc = z3_fpga_fpga_prog_proc_write;
+
+        res_file = create_proc_entry("fpga_done", S_IRUGO, res_dir);
+        if (!res_file)
+                return -ENOMEM;
+        res_file->read_proc  = z3_fpga_fpga_done_proc_read;
+
+        ret = gpio_request(Z3_APP_31_GPIO_FPGA_INITB, "fpga_initb");
+        if ( ret == 0 ) {
+                ret = gpio_direction_input(Z3_APP_31_GPIO_FPGA_INITB);
+        }
+        if ( ret == 0 ) {
+                res_file = create_proc_entry("fpga_initb", S_IWUSR | S_IRUGO, res_dir);
+                if (!res_file)
+                        return -ENOMEM;
+                res_file->read_proc  = z3_fpga_fpga_initb_proc_read;
+                res_file->write_proc = z3_fpga_fpga_initb_proc_write;
+        }
+
+        ret = gpio_request(Z3_APP_31_GPIO_FPGA_CSB, "fpga_csb");
+        if ( ret == 0 ) {
+                ret = gpio_direction_output(Z3_APP_31_GPIO_FPGA_CSB, 1);
+        }
+        if ( ret == 0 ) {
+                res_file = create_proc_entry("fpga_csb", S_IWUSR | S_IRUGO, res_dir);
+                if (!res_file)
+                        return -ENOMEM;
+                res_file->read_proc  = z3_fpga_fpga_csb_proc_read;
+                res_file->write_proc = z3_fpga_fpga_csb_proc_write;
+        }
+
+
+        if ( cpu_is_ti816x() ) {
+                omap_mux_init_signal( "gp0_io26", TI81XX_MUX_PULLUP_ENABLE );
+                omap_mux_init_signal( "gp0_io5", TI81XX_MUX_PULLUP_ENABLE );
+        }
+
+        /* GPMC_A[] lines */
+        ret = gpio_request(Z3_APP_31_GPIO_FPGA_M1, "fpga_m1");
+        if ( ret == 0 ) {
+                ret = gpio_direction_output(Z3_APP_31_GPIO_FPGA_M1, 1);
+                if ( ret == 0 ) {
+                        /* Export to SYSFS */
+                        ret = gpio_export(Z3_APP_31_GPIO_FPGA_M1, true);
+                }
+
+        }
+
+        ret = gpio_request(Z3_APP_31_GPIO_FPGA_M0, "fpga_m0");
+        if ( ret == 0 ) {
+                ret = gpio_direction_output(Z3_APP_31_GPIO_FPGA_M0, 0);
+                if ( ret == 0 ) {
+                        /* Export to SYSFS */
+                        ret = gpio_export(Z3_APP_31_GPIO_FPGA_M0, true);
+                }
+        }
+
+        ret = gpio_request(Z3_APP_31_GPIO_FPGA_CSOUT_B, "fpga_csout");
+        if ( ret == 0 ) {
+                ret = gpio_direction_input(Z3_APP_31_GPIO_FPGA_CSOUT_B);
+                if ( ret == 0 ) {
+                        /* Export to SYSFS */
+                        ret = gpio_export(Z3_APP_31_GPIO_FPGA_CSOUT_B, true);
+                }
+        }
+
+        ret = gpio_request(Z3_APP_31_GPIO_FPGA_RDWR, "fpga_rdwr");
+        if ( ret == 0 ) {
+                ret = gpio_direction_output(Z3_APP_31_GPIO_FPGA_RDWR, 0);
+                if ( ret == 0 ) {
+                        /* Export to SYSFS */
+                        ret = gpio_export(Z3_APP_31_GPIO_FPGA_RDWR, true);
+                }
+        }
+#endif
+
+        if ( cpu_is_ti816x() ) {
+                res_file = create_proc_entry("sdiout_audio_fracfreq", S_IWUSR | S_IRUGO, res_dir);
+                if (!res_file)
+                        return -ENOMEM;
+                res_file->read_proc  = z3_fpga_sdiout_audio_pll_proc_read;
+                res_file->write_proc = z3_fpga_sdiout_audio_pll_proc_write;
+
+                res_file = create_proc_entry("sdiout_video_fracfreq", S_IWUSR | S_IRUGO, res_dir);
+                if (!res_file)
+                        return -ENOMEM;
+                res_file->read_proc  = z3_fpga_sdiout_video_pll_proc_read;
+                res_file->write_proc = z3_fpga_sdiout_video_pll_proc_write;
+
+                res_file = create_proc_entry("sdiout_audio_rate", S_IWUSR | S_IRUGO, res_dir);
+                if (!res_file)
+                        return -ENOMEM;
+                res_file->read_proc  = z3_fpga_sdiout_audio_rate_proc_read;
+                res_file->write_proc = z3_fpga_sdiout_audio_rate_proc_write;
+
+                res_file = create_proc_entry("sdiout_video_rate", S_IWUSR | S_IRUGO, res_dir);
+                if (!res_file)
+                        return -ENOMEM;
+                res_file->read_proc  = z3_fpga_sdiout_video_rate_proc_read;
+                res_file->write_proc = z3_fpga_sdiout_video_rate_proc_write;
+        }
+
+        if ( cpu_is_ti816x() ) {
+                omap_mux_init_signal( "gp0_io11", TI81XX_MUX_PULLDIS );
+                omap_mux_init_signal( "gp0_io12", TI81XX_MUX_PULLDIS );
+                omap_mux_init_signal( "gp0_io14", TI81XX_MUX_PULLDIS );
+        }
+
+        return 0;
+}
+
+void z3_fpga_cleanup(void)
+{
+     del_timer_sync( &z3_fpga_timer );
+}
+
+
+module_init(z3_fpga_pll_init);
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/include/mach/z3_fpga.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/include/mach/z3_fpga.h	2012-09-23 16:05:56.992322027 -0600
@@ -0,0 +1,123 @@
+#ifndef _Z3_FPGA_H
+#define _Z3_FPGA_H
+
+#include <linux/time.h>
+
+#define Z3_LATCH_BASE_ADDR	(0x01000000)
+#define Z3_LATCH_ADDR_SIZE	(0x00010000)
+#define Z3_FPGA_BASE_ADDR	(0x02000000)
+#define Z3_FPGA_ADDR_SIZE	(0x01000000)
+
+#define Z3_FPGA_LATCH_SO_MASK           (0xFF80)
+
+#define Z3_FPGA_VERSION_READ_OFFSET       (0x00)
+
+#define Z3_FPGA_SDI_OUT_OFFSET            (0x02)
+
+#define Z3_FPGA_AUDIO_HDMI_OFFSET         (0x04)
+
+#define Z3_FPGA_PLL_CTRL_OFFSET           (0x06)
+
+#define Z3_FPGA_PLL_CTRL_LOCK_MASK        (0x8000)
+
+#define Z3_FPGA_STC_EXT_OFFSET            (0x08)
+#define Z3_FPGA_STC_BASE_L_OFFSET         (0x0a)
+#define Z3_FPGA_STC_BASE_M_OFFSET         (0x0c)
+#define Z3_FPGA_STC_BASE_H_OFFSET         (0x0e)
+
+#define Z3_FPGA_STC_BASE_H_MASK           (0x0001)
+
+#define Z3_FPGA_ASI_CTL_OFFSET            (0x10)
+
+#define Z3_FPGA_TSO_STC_PCR_DELTA_LOW     (0x30)
+#define Z3_FPGA_TSO_STC_PCR_DELTA_MID     (0x32)
+#define Z3_FPGA_TSO_STC_PCR_DELTA_HIGH    (0x34)
+#define Z3_FPGA_TSO_PCR_PID_OFFSET        (0x36)
+
+enum z3_fpga_audio_mode {
+     Z3_FPGA_AUDIO_TRISTATE = 0,
+
+     Z3_FPGA_AUDIO_HDMI,
+     Z3_FPGA_AUDIO_SDI,
+     Z3_FPGA_AUDIO_GENERATE_48KHZ_32FS,
+     Z3_FPGA_AUDIO_GENERATE_32KHZ_32FS,
+     Z3_FPGA_AUDIO_GENERATE_48KHZ_64FS,
+     Z3_FPGA_AUDIO_GENERATE_32KHZ_64FS,
+};
+
+enum z3_fpga_audio_control {
+     Z3_FPGA_AUDIO_CONTROL_AIC_MASTER,
+     Z3_FPGA_AUDIO_CONTROL_FPGA_IN_MASTER,
+     Z3_FPGA_AUDIO_CONTROL_FPGA_GEN_MASTER,
+};
+
+
+enum z3_fpga_pll_setting {
+     Z3_FPGA_PLL_NONE,
+     Z3_FPGA_PLL_VIDIN_74M25,
+     Z3_FPGA_PLL_VIDIN_74M176,
+     Z3_FPGA_PLL_VIDIN_148M5,
+     Z3_FPGA_PLL_VIDIN_148M352,
+     Z3_FPGA_PLL_VIDIN_27M,
+     Z3_FPGA_PLL_VIDIN_13M5,
+     Z3_FPGA_PLL_VIDOUT_74M176,
+     Z3_FPGA_PLL_VIDOUT_27M,
+     Z3_FPGA_PLL_OUTPUT_DISABLE,
+     Z3_FPGA_PLL_SETTING_COUNT
+};
+
+enum z3_fpga_audio_src {
+     Z3_FPGA_AUDIO_SRC_DISABLE,
+     Z3_FPGA_AUDIO_SRC_ENABLE,
+     Z3_FPGA_AUDIO_SRC_SETTING_COUNT,
+};
+
+enum z3_fpga_audio_input {
+     Z3_FPGA_AUDIO_INPUT_1_2 = 0,
+     Z3_FPGA_AUDIO_INPUT_3_4 = 1,
+     Z3_FPGA_AUDIO_INPUT_5_6 = 2,
+     Z3_FPGA_AUDIO_INPUT_7_8 = 3,
+     Z3_FPGA_AUDIO_INPUT_SETTING_COUNT,
+};
+
+enum z3_fpga_vcap {
+     Z3_FPGA_VCAP_TRISTATE,
+     Z3_FPGA_VCAP_VIDIN,
+     Z3_FPGA_VCAP_ASIIN,
+};
+
+enum z3_fpga_pll_vidin_reference {
+        Z3_FPGA_PLL_VIDIN0_REFERENCE,
+        Z3_FPGA_PLL_VIDIN1_REFERENCE,
+};
+
+int z3_fpga_read(u32 offset);
+int z3_fpga_write(u16 val, u32 offset);
+
+int z3_fpga_si_20bit( int enable );
+int z3_fpga_so_set( unsigned int value );
+
+int z3_fpga_audio_control(enum z3_fpga_audio_control);
+int z3_fpga_audio_select(enum z3_fpga_audio_mode);
+
+int z3_fpga_hdmi_hsync_counter(void);
+void z3_fpga_stc_read(u64 *base, u32 *ext, struct timespec *ptimespec, u64 *stc0_27mhz, u32 *gptimer_27mhz);
+
+void z3_fpga_set_aic_disable( int value );
+
+int z3_fpga_get_aic_disable( void );
+
+void z3_fpga_set_aic_ext_master( int value );
+
+int z3_fpga_get_aic_ext_master( void );
+
+int z3_fpga_set_aic_ext_master_sample_rate(unsigned int rate);
+
+void z3_fpga_set_pll_vidin_reference( enum z3_fpga_pll_vidin_reference ref);
+
+u16 z3_fpga_board_id(void);
+
+int z3_fpga_init(int board_id_gpio);
+
+
+#endif
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/mux81xx.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/mux81xx.h	2012-03-22 23:12:54.000000000 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/mux81xx.h	2012-09-23 16:05:56.992322027 -0600
@@ -358,4 +358,10 @@
 #define TI816X_CONTROL_PADCONF_MUX_SIZE				\
 		(TI816X_CONTROL_PADCONF_USB1_DRVVBUS_OFFSET + 0x4)
 
+
+#define TI81XX_MUX_PULLDIS         0x08
+#define TI81XX_MUX_PULLUP_ENABLE   0x10
+#define TI81XX_MUX_PULLDOWN_ENABLE 0x00
+
+
 #endif
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/Makefile
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/Makefile	2012-09-23 16:05:56.968322027 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/Makefile	2012-09-23 16:16:59.468324569 -0600
@@ -263,6 +263,7 @@
 					   board-flash.o
 obj-$(CONFIG_MACH_DM8168Z3)		+= board-dm8168z3.o \
 					   hsmmc.o \
+					   z3_fpga.o \
 					   board-flash.o
 # Platform specific device init code
 usbfs-$(CONFIG_ARCH_OMAP_OTG)		:= usb-fs.o
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/include/mach/z3_app.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/include/mach/z3_app.h	2012-09-23 16:05:56.992322027 -0600
@@ -0,0 +1,112 @@
+#ifndef _DM81xx_Z3_APP_H
+#define _DM81xx_Z3_APP_H
+
+#include <linux/bitops.h>
+
+/* APP-31 */
+
+/* Latch Y2# - A3 low Write  */
+#define Z3_APP31_Y2_RESETN            BIT(0)
+#define Z3_APP31_Y2_ASI_IN_ASI        BIT(1)
+#define Z3_APP31_Y2_ASI_OUT_ASI       BIT(2)
+
+#define Z3_APP31_Y2_LED0_G            BIT(8)
+#define Z3_APP31_Y2_LED0_R            BIT(9)
+#define Z3_APP31_Y2_LED1_G            BIT(10)
+#define Z3_APP31_Y2_LED1_R            BIT(11)
+
+#define Z3_APP31_Y2_FPGA_PROG         BIT(13)
+#define Z3_APP31_Y2_AIC_DIS           BIT(14)
+#define Z3_APP31_Y2_DM814X            BIT(15)
+
+
+#define Z3_APP02_LATCH_HI0RESETN      BIT(0)
+#define Z3_APP02_LATCH_ADC0RESETN     BIT(1)
+#define Z3_APP02_LATCH_ADC0POWERDN    BIT(2)
+#define Z3_APP02_LATCH_CVRESETN       BIT(3)
+#define Z3_APP02_LATCH_CVPOWERDN      BIT(4)
+#define Z3_APP02_LATCH_HI1RESETN      BIT(5)
+#define Z3_APP02_LATCH_ADC1RESETN     BIT(6)
+#define Z3_APP02_LATCH_ADC1POWERDN    BIT(7)
+
+#define Z3_APP02_LATCH_LED0_G         BIT(8)
+#define Z3_APP02_LATCH_LED0_R         BIT(9)
+#define Z3_APP02_LATCH_LED1_G         BIT(10)
+#define Z3_APP02_LATCH_LED1_R         BIT(11)
+#define Z3_APP02_LATCH_AIC32RESETN    BIT(13)
+#define Z3_APP02_LATCH_MCA1_SEL       BIT(14)
+#define Z3_APP02_LATCH_DM814X         BIT(15)
+
+
+/* Latch Y3# - A3 high Write  */
+#define Z3_APP31_Y3_SO_GRP2          BIT(15)
+#define Z3_APP31_Y3_SO_GRP1          BIT(14)
+#define Z3_APP31_Y3_SO_DETTRS        BIT(13)
+#define Z3_APP31_Y3_SO_656BYP        BIT(12)
+#define Z3_APP31_Y3_SO_ASI           BIT(11)
+#define Z3_APP31_Y3_SO_20BIT         BIT(10)
+#define Z3_APP31_Y3_SO_RATE1         BIT(9)
+#define Z3_APP31_Y3_SO_RATE0         BIT(8)
+
+#define Z3_APP31_Y3_SO_STDBY         BIT(7)
+#define Z3_APP31_Y3_SI_STDBY         BIT(6)
+#define Z3_APP31_Y3_ADC0_PDN         BIT(5)
+#define Z3_APP31_Y3_OE_SI_ASI_656BYP BIT(4)
+#define Z3_APP31_Y3_SI_SDHD          BIT(3)
+#define Z3_APP31_Y3_SI_656BYP        BIT(2)
+#define Z3_APP31_Y3_SI_ASI           BIT(1)
+#define Z3_APP31_Y3_SI_20BIT         BIT(0)
+
+
+/* Latch Y4# - A3 low read  */
+#define Z3_APP31_Y4_FPGA_DONE        BIT(7)
+#define Z3_APP31_Y4_ASI_OUT_LOCK     BIT(6)
+#define Z3_APP31_Y4_ASI_IN_LOCK      BIT(5)
+#define Z3_APP31_Y4_SO_LOCKED        BIT(4)
+#define Z3_APP31_Y4_SI_LOCKED        BIT(3)
+#define Z3_APP31_Y4_SI_656BYP        BIT(2)
+#define Z3_APP31_Y4_SI_ASI           BIT(1)
+
+
+#define Z3_APP22_LATCH_LED0_G         BIT(8)
+#define Z3_APP22_LATCH_LED0_R         BIT(9)
+#define Z3_APP22_LATCH_LED1_G         BIT(10)
+#define Z3_APP22_LATCH_LED1_R         BIT(11)
+#define Z3_APP22_LATCH_EDID_WPRT      BIT(12)
+#define Z3_APP22_LATCH_RST7002N       BIT(13)
+#define Z3_APP22_LATCH_RST7611N       BIT(14)
+
+#define Z3_APP41_LATCH_LED0_G         BIT(8)
+#define Z3_APP41_LATCH_LED0_R         BIT(9)
+#define Z3_APP41_LATCH_LED1_G         BIT(10)
+#define Z3_APP41_LATCH_LED1_R         BIT(11)
+#define Z3_APP41_LATCH_RST7611B_N     BIT(13)
+#define Z3_APP41_LATCH_RST7611A_N     BIT(14)
+
+
+
+// INT_HI0  - GP0_IO4
+// FPGA_INT - FPGA_INT
+// pin F1: CLKOUT: TVP_ECLK
+
+
+/* GP0_21: Board ID */
+
+#define Z3_BOARD_ID_NONE        0xffff
+#define Z3_BOARD_ID_MODULE_ONLY 0x0000
+#define Z3_BOARD_ID_APP_02      0x0001
+#define Z3_BOARD_ID_APP_31      0x0002
+#define Z3_BOARD_ID_APP_21      0x0008
+#define Z3_BOARD_ID_APP_41      0x000a
+
+#define Z3_APP_31_GPIO_FPGA_INITB    26
+#define Z3_APP_31_GPIO_FPGA_CSB       5
+#define Z3_APP_31_GPIO_FPGA_M0       11
+#define Z3_APP_31_GPIO_GPMC_A3       11
+#define Z3_APP_31_GPIO_FPGA_M1       12
+#define Z3_APP_31_GPIO_FPGA_CSOUT_B  13
+#define Z3_APP_31_GPIO_FPGA_RDWR     14
+
+
+
+#endif
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/devices.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/devices.c	2012-09-23 16:05:56.972322027 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/devices.c	2012-09-23 16:05:56.992322027 -0600
@@ -1312,39 +1312,33 @@
 	.resource	=	ti816x_emac1_resources,
 };
 
-static struct platform_device ti816x_emac2_device = {
-	.name	=	"davinci_emac",
-	.id	=	1,
-	.num_resources	=	ARRAY_SIZE(ti816x_emac2_resources),
-	.resource	=	ti816x_emac2_resources,
-};
-
 void ti816x_emac_mux(void)
 {
-	omap_mux_init_signal("gmii1_rxclk", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxd0", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxd1", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxd2", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxd3", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxd4", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxd5", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxd6", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxd7", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxdv", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_gtxclk", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txd0", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txd1", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txd2", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txd3", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txd4", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txd5", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txd6", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txd7", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txen", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_txclk", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_col", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_crs", OMAP_MUX_MODE1);
-	omap_mux_init_signal("gmii1_rxer", OMAP_MUX_MODE1);
+        /* Tri-state outputs for Z3 APP-22 DM814x VIP1 pins*/
+	omap_mux_init_signal("gmii1_rxclk", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxd0", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxd1", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxd2", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxd3", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxd4", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxd5", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxd6", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxd7", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxdv", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_gtxclk", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txd0", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txd1", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txd2", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txd3", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txd4", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txd5", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txd6", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txd7", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txen", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_txclk", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_col", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_crs", OMAP_MUX_MODE3);
+	omap_mux_init_signal("gmii1_rxer", OMAP_MUX_MODE3);
 }
 
 
@@ -1424,19 +1418,19 @@
 static struct ti816x_sr_sdata sr_sensor_data[] = {
 	{
 		.efuse_offs	= TI816X_SR_HVT_CNTRL_OFFSET,
-		.e2v_gain	= TI816X_SR_HVT_ERR2VOLT_GAIN,
-		.err_minlimit	= TI816X_SR_HVT_ERR_MIN_LIMIT,
-		.err_maxlimit	= 0x2,
+		.e2v_gain	= 0x3,
 		.err_weight	= 0x4,
+		.err_minlimit	= 0xD5,
+		.err_maxlimit	= 0x2,
 		.senn_mod	= 0x1,
 		.senp_mod	= 0x1,
 	},
 	{
 		.efuse_offs	= TI816X_SR_SVT_CNTRL_OFFSET,
-		.e2v_gain	= TI816X_SR_SVT_ERR2VOLT_GAIN,
-		.err_minlimit	= TI816X_SR_SVT_ERR_MIN_LIMIT,
-		.err_maxlimit	= 0x2,
+		.e2v_gain	= 0x5,
 		.err_weight	= 0x4,
+		.err_minlimit	= 0xE6,
+		.err_maxlimit	= 0x2,
 		.senn_mod	= 0x1,
 		.senp_mod	= 0x1,
 	},
@@ -1448,7 +1442,7 @@
 	.irq_delay		= 2000,
 	.no_of_vds		= 1,
 	.no_of_sens		= ARRAY_SIZE(sr_sensor_data),
-	.vstep_size_uv		= 15000,
+    .vstep_size_uv          = 49000,
 	.enable_on_init		= true,
 	.sr_sdata		= sr_sensor_data,
 };
@@ -2541,7 +2535,50 @@
 	},
 };
 
-static struct resource ti81xx_mcasp_resource[] = {
+
+static struct resource ti81xx_mcasp0_resource[] = {
+	{
+		.name = "mcasp",
+		.start = TI81XX_ASP0_BASE,
+		.end = TI81XX_ASP0_BASE + (SZ_1K * 12) - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	/* TX event */
+	{
+		.start = TI81XX_DMA_MCASP0_AXEVT,
+		.end = TI81XX_DMA_MCASP0_AXEVT,
+		.flags = IORESOURCE_DMA,
+	},
+	/* RX event */
+	{
+		.start = TI81XX_DMA_MCASP0_AREVT,
+		.end = TI81XX_DMA_MCASP0_AREVT,
+		.flags = IORESOURCE_DMA,
+	},
+};
+
+static struct resource ti81xx_mcasp1_resource[] = {
+	{
+		.name = "mcasp",
+		.start = TI81XX_ASP1_BASE,
+		.end = TI81XX_ASP1_BASE + (SZ_1K * 12) - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	/* TX event */
+	{
+		.start = TI81XX_DMA_MCASP1_AXEVT,
+		.end = TI81XX_DMA_MCASP1_AXEVT,
+		.flags = IORESOURCE_DMA,
+	},
+	/* RX event */
+	{
+		.start = TI81XX_DMA_MCASP1_AREVT,
+		.end = TI81XX_DMA_MCASP1_AREVT,
+		.flags = IORESOURCE_DMA,
+	},
+};
+
+static struct resource ti81xx_mcasp2_resource[] = {
 	{
 		.name = "mcasp",
 		.start = TI81XX_ASP2_BASE,
@@ -2562,27 +2599,49 @@
 	},
 };
 
-static struct platform_device ti81xx_mcasp_device = {
+
+
+static struct platform_device ti81xx_mcasp0_device = {
 	.name = "davinci-mcasp",
+	.id = 0,
+	.num_resources = ARRAY_SIZE(ti81xx_mcasp0_resource),
+	.resource = ti81xx_mcasp0_resource,
+};
+
+static struct platform_device ti81xx_mcasp1_device = {
+	.name = "davinci-mcasp",
+	.id = 1,
+	.num_resources = ARRAY_SIZE(ti81xx_mcasp1_resource),
+	.resource = ti81xx_mcasp1_resource,
+};
+
+static struct platform_device ti81xx_mcasp2_device = {
+	.name = "davinci-mcasp",
+	.id = 2,
+	.num_resources = ARRAY_SIZE(ti81xx_mcasp2_resource),
+	.resource = ti81xx_mcasp2_resource,
 };
 
 void __init ti81xx_register_mcasp(int id, struct snd_platform_data *pdata)
 {
-	if (machine_is_ti8168evm() || machine_is_ti8148evm()) {
-		ti81xx_mcasp_device.id = 2;
-		ti81xx_mcasp_device.resource = ti81xx_mcasp_resource;
-		ti81xx_mcasp_device.num_resources = ARRAY_SIZE(ti81xx_mcasp_resource);
-	} else if (machine_is_dm385evm()) {
-		ti81xx_mcasp_device.id = 1;
-		ti81xx_mcasp_device.resource = dm385_mcasp_resource;
-		ti81xx_mcasp_device.num_resources = ARRAY_SIZE(dm385_mcasp_resource);
-	} else {
-		pr_err("%s: platform not supported\n", __func__);
-		return;
-	}
+        switch ( id )
+        {
+        case 0:
+                ti81xx_mcasp0_device.dev.platform_data = pdata;
+                platform_device_register(&ti81xx_mcasp0_device);
+                break;
+        case 1:
+                ti81xx_mcasp1_device.dev.platform_data = pdata;
+                platform_device_register(&ti81xx_mcasp1_device);
+                break;
+        case 2:
+                ti81xx_mcasp2_device.dev.platform_data = pdata;
+                platform_device_register(&ti81xx_mcasp2_device);
+                break;
+        default:
+                break;
+        }
 
-	ti81xx_mcasp_device.dev.platform_data = pdata;
-	platform_device_register(&ti81xx_mcasp_device);
 }
 #endif
 
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pcie-ti816x.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pcie-ti816x.c	2012-09-23 16:05:56.996322027 -0600
@@ -0,0 +1,1110 @@
+/*
+ * PCIe RC (Host) Driver for TI816X PCIe Module (PCIESS) configured as Root
+ * Complex.
+ *
+ * Copyright (C) 2010 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+/*
+ * General TODO:
+ * - All of the register accesses are through raw_read/writes which eat up lines
+ *   especially when needed to mask bits before writing. Better to add
+ *   read-mask-write kind of wrappers.
+ * - Lots of private data to maintain - group together inside a structure and
+ *   provide accessor functions?
+ * - Possibility of adding hw de-initialization sequence (also, re-enumeration /
+ *   PM impact)
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/irq.h>
+#include <linux/slab.h>
+#include <linux/msi.h>
+#include <linux/pci.h>
+
+#include <asm/irq.h>
+#include <asm/signal.h>
+#include <asm/mach/pci.h>
+
+#include <plat/ti81xx.h>
+
+#include "pcie-ti816x.h"
+
+#define DRIVER_NAME		"ti816x_pcie"
+
+static struct platform_device *pcie_pdev;
+static int msi_irq_base;
+static int msi_irq_num;
+
+/* Details for inbound access to RAM, passed from platform data */
+static u32 ram_base, ram_end;
+
+/* Used for BAR0 translation */
+static u32 reg_phys;
+
+/* Used for register accesses */
+static u32 reg_virt;
+
+/* Interrupt resources */
+static int legacy_irq;
+static int msi_irq;
+
+/*
+ * Protect io accesses as it involves setting IOBASE register
+ *
+ * FIXME: We use differnet locks for IO and config accesses. This should be OK
+ * as the h/w spec doesn't mention any restriction on config and io accesses to
+ * be performed exclusively
+ */
+static DEFINE_SPINLOCK(ti816x_pci_io_lock);
+
+/*
+ *  Application Register Offsets
+ */
+#define PCISTATSET                      0x010
+#define CMD_STATUS			0x004
+#define CFG_SETUP			0x008
+#define IOBASE				0x00c
+#define OB_SIZE				0x030
+#define MSI_IRQ				0x054
+#define OB_OFFSET_INDEX(n)              (0x200 + (8 * n))     /* 32 Registers */
+#define OB_OFFSET_HI(n)			(0x204 + (8 * n))     /* 32 Registers */
+#define IB_BAR0				0x300
+#define IB_START0_LO			0x304
+#define IB_START0_HI			0x308
+#define IB_OFFSET0			0x30c
+#define ERR_IRQ_STATUS_RAW		0x1c0
+#define ERR_IRQ_STATUS			0x1c4
+#define MSI0_IRQ_STATUS			0x104
+#define MSI0_IRQ_ENABLE_SET		0x108
+#define MSI0_IRQ_ENABLE_CLR		0x10c
+#define IRQ_ENABLE_SET			0x188
+#define IRQ_ENABLE_CLR			0x18c
+
+/*
+ * PCIe Config Register Offsets (misc)
+ */
+#define DEBUG0				0x728
+#define PL_GEN2				0x80c
+
+/* Various regions in PCIESS address space */
+#define SPACE0_LOCAL_CFG_OFFSET		0x1000
+#define SPACE0_REMOTE_CFG_OFFSET	0x2000
+#define SPACE0_IO_OFFSET		0x3000
+
+/* Application command register values */
+#define DBI_CS2_EN_VAL			BIT(5)
+#define IB_XLAT_EN_VAL			BIT(2)
+#define OB_XLAT_EN_VAL			BIT(1)
+#define LTSSM_EN_VAL			BIT(0)
+
+/* Link training encodings as indicated in DEBUG0 register */
+#define LTSSM_STATE_MASK		0x1f
+#define LTSSM_STATE_L0			0x11
+
+/* Directed Speed Change */
+#define DIR_SPD				(1 << 17)
+
+/* Default value used for Command register */
+#define CFG_PCIM_CSR_VAL         (PCI_COMMAND_SERR			\
+					| PCI_COMMAND_PARITY		\
+					| PCI_COMMAND_INVALIDATE	\
+					| PCI_COMMAND_MASTER		\
+					| PCI_COMMAND_MEMORY		\
+					| PCI_COMMAND_INTX_DISABLE)
+
+/* Error mask for errors to check on CFG/IO */
+#define CFG_PCI_ERR_MASK	  ((0xf << 28) | (1 < 24))
+
+/* Outbound window size specified as power of 2 MB */
+#define CFG_PCIM_WIN_SZ_IDX	3
+#define CFG_PCIM_WIN_CNT	32
+
+/* Maximum MSIs supported by PCIESS */
+#define CFG_MAX_MSI_NUM		32
+
+static int get_and_clear_err(void)
+{
+	int status = __raw_readl(reg_virt + ERR_IRQ_STATUS_RAW);
+
+	if (status) {
+		/* The PCIESS interrupt status buts are "write 0 to clear" */
+		__raw_writel(~status, reg_virt + ERR_IRQ_STATUS);
+
+		/*
+		 * Clear all errors. We are not worried here about individual
+		 * status as no specific handling is required.
+		 */
+		__raw_writew(0xffff, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+				PCI_STATUS);
+	}
+
+	return status;
+}
+
+/**
+ * ti816x_pcie_fault() - ARM abort handler for PCIe non-posted completion aborts
+ * @addr: Address target on which the fault generated
+ * @fsr: CP15 fault status register value
+ * @regs: Pointer to register structure on abort
+ *
+ * Handles precise abort caused due to PCIe operation.
+ *
+ * Note that we are relying on virtual address filtering to determine if the
+ * target of the precise aborts was a PCIe module access (i.e., config, I/O,
+ * register) and only handle such aborts. We could check PCIe error status to
+ * confirm if the abort was caused due to non-posted completion status received
+ * by PCIESS, but this may not always be true and aborts from some downstream
+ * devices, such as PCI-PCI bridges etc may not result into error status bit
+ * getting set.
+ *
+ * Ignores and returns abort as unhandled otherwise.
+ *
+ * Also note that, using error status check (as was done in earlier
+ * implementation) would also handle failed memory accesses (non-posted), but
+ * address filerting based handling will cause aborts for memory accesses as the
+ * addresses will be outside the PCIESS module space. This seems OK, as any
+ * memory access after enumeration is sole responsibility of the driver and the
+ * system integrator (e.g., access failures due to hotplug, suspend etc). If
+ * using error check based handling, we also need to clear PCIe error status on
+ * detecting errors.
+ *
+ * Note: Due to specific h/w implementation, we can't be sure of what kind of
+ * error occurred (UR Completion, CA etc) and all we get is raw error IRQ status
+ * and probably SERR which indicate 'some kind of' error - fatal or non-fatal is
+ * received/happened.
+ */
+static int
+ti816x_pcie_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)
+{
+	unsigned long instr = *(unsigned long *)regs->ARM_pc;
+
+	pr_debug(DRIVER_NAME ": Data abort: address = 0x%08lx "
+			"fsr = 0x%03x PC = 0x%08lx LR = 0x%08lx",
+			addr, fsr, regs->ARM_pc, regs->ARM_lr);
+
+#if 0
+	if (!get_and_clear_err())
+		return -1;
+#endif
+
+	/* Note: Only handle PCIESS module space access */
+	if ((addr < reg_virt) || (addr >= (reg_virt + SZ_16K)))
+		return -1;
+
+	/*
+	 * Mimic aborted read of all 1's as required to detect device/function
+	 * absence - check if the instruction that caused abort was a LOAD,
+	 */
+	if ((instr & 0x0c100000) == 0x04100000) {
+		int reg = (instr >> 12) & 15;
+		unsigned long val;
+
+		if (instr & 0x00400000)
+			val = 255;
+		else
+			val = -1;
+
+		regs->uregs[reg] = val;
+	}
+
+	regs->ARM_pc += 4;
+
+	pr_debug(DRIVER_NAME ": Handled PCIe abort\n");
+
+	return 0;
+}
+
+/**
+ * set_outbound_trans() - Set PHYADDR <-> BUSADDR mapping for outbound
+ */
+static void set_outbound_trans(u32 start, u32 end)
+{
+	int i, tr_size;
+
+	pr_debug(DRIVER_NAME ": Setting outbound translation for %#x-%#x\n",
+			start, end);
+
+	/* Set outbound translation size per window division */
+	__raw_writel(CFG_PCIM_WIN_SZ_IDX & 0x7, reg_virt + OB_SIZE);
+
+	tr_size = (1 << (CFG_PCIM_WIN_SZ_IDX & 0x7)) * SZ_1M;
+
+	/* Using Direct 1:1 mapping of RC <-> PCI memory space */
+	for (i = 0; (i < CFG_PCIM_WIN_CNT) && (start < end); i++) {
+		__raw_writel(start | 1, reg_virt + OB_OFFSET_INDEX(i));
+		__raw_writel(0,	reg_virt + OB_OFFSET_HI(i));
+		start += tr_size;
+	}
+
+	/* TODO: ensure unused translation regions are disabled */
+
+	/* Enable OB translation */
+	 __raw_writel(OB_XLAT_EN_VAL | __raw_readl(reg_virt + CMD_STATUS),
+			 reg_virt + CMD_STATUS);
+}
+
+/**
+ * set_dbi_mode() - Set DBI mode to access overlaid BAR mask registers
+ *
+ * Since modification of dbi_cs2 involves different clock domain, read the
+ * status back to ensure the transition is complete.
+ */
+static inline void set_dbi_mode(void)
+{
+	 __raw_writel(DBI_CS2_EN_VAL | __raw_readl(reg_virt + CMD_STATUS),
+			 reg_virt + CMD_STATUS);
+
+	  /* FIXME: Need loop to check bit5 = 1? */
+	__raw_readl(reg_virt + CMD_STATUS);
+}
+
+/**
+ * clear_dbi_mode() - Disable DBI mode
+ *
+ * Since modification of dbi_cs2 involves different clock domain, read the
+ * status back to ensure the transition is complete.
+ */
+static inline void clear_dbi_mode(void)
+{
+	__raw_writel(~DBI_CS2_EN_VAL & __raw_readl(reg_virt + CMD_STATUS),
+			reg_virt + CMD_STATUS);
+
+	  /* FIXME: Need loop to check bit5 = 1? */
+	__raw_readl(reg_virt + CMD_STATUS);
+}
+
+static void disable_bars(void)
+{
+	set_dbi_mode();
+
+	__raw_writel(0, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+			PCI_BASE_ADDRESS_0);
+	__raw_writel(0, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+			PCI_BASE_ADDRESS_1);
+
+	clear_dbi_mode();
+}
+
+/**
+ * set_inbound_trans() - Setup inbound access
+ *
+ * Configure BAR0 and BAR1 for inbound access. BAR0 is set up in h/w to have
+ * access to PCIESS application register space and just needs to set up inbound
+ * address (mainly used for MSI). While BAR1 is set up to provide translation
+ * into specified (SoC/Board level) internal address space.
+ *
+ * Note: 1:1 mapping for internal addresses is used.
+ *
+ * TODO: Add 64-bit support
+ */
+static void set_inbound_trans(void)
+{
+	/* Configure and set up BAR0 */
+	set_dbi_mode();
+
+	/* Enable BAR0 */
+	__raw_writel(1, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+			PCI_BASE_ADDRESS_0);
+
+	__raw_writel(SZ_4K - 1, reg_virt +
+			SPACE0_LOCAL_CFG_OFFSET + PCI_BASE_ADDRESS_0);
+
+	clear_dbi_mode();
+
+	 /*
+	  * For BAR0, just setting bus address for inbound writes (MSI) should
+	  * be sufficient. Use physical address to avoid any conflicts.
+	  */
+	__raw_writel(reg_phys, reg_virt + SPACE0_LOCAL_CFG_OFFSET
+				+ PCI_BASE_ADDRESS_0);
+
+	/* Configure BAR1 only if inbound window is specified */
+	if (ram_base != ram_end) {
+		/*
+		 * Set Inbound translation. Skip BAR0 as it will have h/w
+		 * default set to open application register space.
+		 *
+		 * The value programmed in IB_STARTXX registers must be same as
+		 * the one set in corresponding BAR from PCI config space.
+		 *
+		 * We use translation 'offset' value to yield 1:1 mapping so as
+		 * to have physical address on RC side = Inbound PCIe link
+		 * address. This also ensures no overlapping with base/limit
+		 * regions (outbound).
+		 */
+		__raw_writel(ram_base, reg_virt + IB_START0_LO);
+		__raw_writel(0, reg_virt + IB_START0_HI);
+		__raw_writel(1, reg_virt + IB_BAR0);
+		__raw_writel(ram_base, reg_virt + IB_OFFSET0);
+
+		/*
+		 * Set BAR1 mask to accomodate inbound window
+		 */
+
+		set_dbi_mode();
+
+		__raw_writel(1, reg_virt + SPACE0_LOCAL_CFG_OFFSET +
+				PCI_BASE_ADDRESS_1);
+
+		__raw_writel(ram_end - ram_base, reg_virt +
+			SPACE0_LOCAL_CFG_OFFSET + PCI_BASE_ADDRESS_1);
+
+		clear_dbi_mode();
+
+		/* Set BAR1 attributes and value in config space */
+		__raw_writel(ram_base | PCI_BASE_ADDRESS_MEM_PREFETCH,
+				reg_virt + SPACE0_LOCAL_CFG_OFFSET
+				+ PCI_BASE_ADDRESS_1);
+
+		/*
+		 * Enable IB translation only if BAR1 is set. BAR0 doesn't
+		 * require enabling IB translation as it is set up in h/w
+		 */
+		__raw_writel(IB_XLAT_EN_VAL | __raw_readl(reg_virt +
+					CMD_STATUS), reg_virt + CMD_STATUS);
+	}
+}
+
+static DECLARE_BITMAP(msi_irq_bits, CFG_MAX_MSI_NUM);
+
+/**
+ * ti816x_msi_handler() - Handle MSI interrupt
+ * @irq: IRQ line for MSI interrupts
+ * @desc: Pointer to irq descriptor
+ *
+ * Traverse through pending MSI interrupts and invoke handler for each. Also
+ * takes care of interrupt controller level mask/ack operation.
+ */
+static void ti816x_msi_handler(unsigned int irq, struct irq_desc *desc)
+{
+	int bit = 0;
+	u32 status;
+
+	pr_debug(DRIVER_NAME ": Handling MSI irq %d\n", irq);
+
+	/*
+	 * The chained irq handler installation would have replaced normal
+	 * interrupt driver handler so we need to take care of mask/unmask and
+	 * ack operation.
+	 */
+	desc->chip->mask(irq);
+	if (desc->chip->ack)
+		desc->chip->ack(irq);
+
+	status = __raw_readl(reg_virt + MSI0_IRQ_STATUS);
+
+	/* FIXME: Use max loops count? */
+	while (status) {
+		bit = find_first_bit((unsigned long *)&status, 32);
+		generic_handle_irq(msi_irq_base + bit);
+		status = __raw_readl(reg_virt + MSI0_IRQ_STATUS);
+	}
+
+	desc->chip->unmask(irq);
+}
+
+static void ack_msi(unsigned int irq)
+{
+	unsigned int msi_num = irq - msi_irq_base;
+	__raw_writel(~(1 << (msi_num & 0x1f)), reg_virt + MSI0_IRQ_STATUS);
+}
+
+static void mask_msi(unsigned int irq)
+{
+	unsigned int msi_num = irq - msi_irq_base;
+	__raw_writel(1 << (msi_num & 0x1f), reg_virt + MSI0_IRQ_ENABLE_CLR);
+}
+
+static void unmask_msi(unsigned int irq)
+{
+	unsigned int msi_num = irq - msi_irq_base;
+	__raw_writel(1 << (msi_num & 0x1f), reg_virt + MSI0_IRQ_ENABLE_SET);
+}
+
+/*
+ * TODO: Add support for mask/unmask on remote devices (mask_msi_irq and
+ * unmask_msi_irq). Note that, this may not work always - requires endpoints to
+ * support mask bits capability.
+ */
+
+static struct irq_chip ti816x_msi_chip = {
+	.name = "PCIe-MSI",
+	.ack = ack_msi,
+	.mask = mask_msi,
+	.unmask = unmask_msi,
+};
+
+/**
+ * get_free_msi() - Get a free MSI number
+ *
+ * Checks for availability of MSI and returns the first available.
+ */
+static int get_free_msi(void)
+{
+	int bit;
+
+	do {
+		bit = find_first_zero_bit(msi_irq_bits, msi_irq_num);
+
+		if (bit >= msi_irq_num)
+			return -ENOSPC;
+
+	} while (test_and_set_bit(bit, msi_irq_bits));
+
+	pr_debug(DRIVER_NAME ": MSI %d available\n", bit);
+
+	return bit;
+}
+
+/* Stub for legacy-interrupts-only mode. */
+#ifndef CONFIG_PCI_MSI
+void write_msi_msg(unsigned int irq, struct msi_msg *msg) {}
+#endif
+
+/**
+ * arch_setup_msi_irq() - Set up an MSI for Endpoint
+ * @pdev: Pointer to PCI device structure of requesting EP
+ * @desc: Pointer to MSI descriptor data
+ *
+ * Assigns an MSI to endpoint and sets up corresponding irq. Also passes the MSI
+ * information to the endpont.
+ *
+ * TODO: Add 64-bit addressing support
+ */
+int arch_setup_msi_irq(struct pci_dev *pdev, struct msi_desc *desc)
+{
+	int ret, irq;
+	struct msi_msg msg;
+
+	if (msi_irq < 0) {
+		pr_err(DRIVER_NAME ": MSI irq pin not specified\n");
+		return msi_irq;
+	}
+
+	ret = get_free_msi();
+	if (ret < 0) {
+		pr_err(DRIVER_NAME ": Failed to get free MSI\n");
+	} else {
+		irq = msi_irq_base + ret;
+		msg.data = ret;
+
+		dynamic_irq_init(irq);
+		ret = set_irq_msi(irq, desc);
+
+		if (!ret) {
+			msg.address_hi = 0;
+			msg.address_lo = reg_phys + MSI_IRQ;
+
+			pr_debug(DRIVER_NAME ": MSI %d @%#x:%#x, irq = %d\n",
+					msg.data, msg.address_hi,
+					msg.address_lo, irq);
+
+			write_msi_msg(irq, &msg);
+
+			set_irq_chip_and_handler(irq, &ti816x_msi_chip,
+						handle_level_irq);
+			set_irq_flags(irq, IRQF_VALID);
+		}
+	}
+
+	return ret;
+}
+
+void arch_teardown_msi_irq(unsigned int irq)
+{
+	int pos = irq - msi_irq_base;
+
+	dynamic_irq_cleanup(irq);
+
+	clear_bit(pos, msi_irq_bits);
+}
+
+/**
+ * ti816x_pcie_setup() - Perform PCIe system setup.
+ * @nr: PCI controller index
+ * @sys: PCI data for the controller
+ *
+ * Initializeand configure PCIe Root Complex h/w and fill up resource data to be
+ * used by PCI core enumeration layer.
+ *
+ * H/W initializations consist mainly of:
+ * - Setting up PCIESS module clock and getting out of reset.
+ * - Establish link with downstream.
+ * - Set up outbound access.
+ * - Enable memory and IO access.
+ *
+ * Following resources are allotted for bios enumeration:
+ * - Non-Prefetch memory
+ * - 32-bit IO
+ * - Legacy interrupt
+ * - MSI (if enabled)
+ *
+ * TODO: Add
+ * - Prefetchable memory
+ * - 64-bit addressing support
+ * - Additional delay/handshaking for EPs indulging in CRRS
+ */
+static int ti816x_pcie_setup(int nr, struct pci_sys_data *sys)
+{
+	struct resource *res, *plat_res;
+	struct clk *pcie_ck;
+
+	if (nr != 0)
+		return 0;
+
+	pr_info(DRIVER_NAME ": Setting up Host Controller...\n");
+
+	plat_res = platform_get_resource_byname(pcie_pdev,
+						IORESOURCE_MEM, "pcie-regs");
+	if (!plat_res) {
+		pr_err(DRIVER_NAME ": Failed to get 'regs' memory resource\n");
+		return -1;
+	}
+
+	reg_phys = plat_res->start;
+
+	/*
+	 * Substitute the resources which were set up by default by
+	 * pcibios_init_hw
+	 */
+	res = kzalloc(sizeof(*res) * 2, GFP_KERNEL);
+	if (res == NULL) {
+		pr_err(DRIVER_NAME ": resource structure allocation failed.\n");
+		return -1;
+	}
+
+	/*
+	 * Gather resources which will be used to assign BARs to targets during
+	 * scanning.
+	 */
+
+	plat_res = platform_get_resource_byname(pcie_pdev, IORESOURCE_MEM,
+						"pcie-nonprefetch");
+	if (!plat_res) {
+		pr_err(DRIVER_NAME ": no resource for non-prefetch memory\n");
+		goto err_memres;
+	}
+
+	res[0].start = plat_res->start;
+	res[0].end = plat_res->end;
+	res[0].name = "PCI Memory";
+	res[0].flags = IORESOURCE_MEM;
+
+#if 0
+	{
+		if (insert_resource(&iomem_resource, &res[0])) {
+			pr_err(DRIVER_NAME ": Failed to reserve memory res\n");
+			goto err_memres;
+	}
+#endif
+	/* Optional: io window */
+	plat_res = platform_get_resource_byname(pcie_pdev, IORESOURCE_IO,
+						"pcie-io");
+	if (!plat_res) {
+		pr_warning(DRIVER_NAME ": no resource for PCI I/O\n");
+	} else {
+		res[1].start = plat_res->start;
+		res[1].end = plat_res->end;
+		res[1].name = "PCI I/O";
+		res[1].flags = IORESOURCE_IO;
+
+		if (insert_resource(&ioport_resource, &res[1])) {
+			pr_err(DRIVER_NAME ": Failed to reserve io resource\n");
+			goto err_iores;
+		}
+	}
+
+	/*
+	 * Note: Only one inbound window can be considered as BAR0 is set up for
+	 * application register space in h/w.
+	 */
+	plat_res = platform_get_resource_byname(pcie_pdev, IORESOURCE_MEM,
+						"pcie-inbound0");
+	if (!plat_res) {
+		pr_warning(DRIVER_NAME ": no resource for inbound PCI\n");
+	} else {
+		ram_base = plat_res->start;
+		ram_end = plat_res->end;
+	}
+
+	sys->resource[0] = &res[0];
+	sys->resource[1] = &res[1];
+	sys->resource[2] = NULL;
+
+	/* 16KB region is sufficiant for reg(4KB) + configs(8KB) + IO(4KB) */
+	reg_virt = (u32)ioremap_nocache(reg_phys, SZ_16K);
+
+	if (!reg_virt) {
+		pr_err(DRIVER_NAME ": PCIESS register memory remap failed\n");
+		goto err_ioremap;
+	}
+
+	pr_info(DRIVER_NAME ": Register base mapped @0x%08x\n", (int)reg_virt);
+
+	pcie_ck = clk_get(NULL, "pcie_ck");
+	if (IS_ERR(pcie_ck)) {
+		pr_err(DRIVER_NAME ": Failed to get PCIESS clock\n");
+		goto err_clkget;
+	}
+
+	if (clk_enable(pcie_ck))
+		goto err_clken;
+
+	/*
+	 * TI81xx devices do not support h/w autonomous link up-training to GEN2
+	 * form GEN1 in either EP/RC modes. The software needs to initiate speed
+	 * change.
+	 */
+	__raw_writel(DIR_SPD | __raw_readl(
+				reg_virt + SPACE0_LOCAL_CFG_OFFSET + PL_GEN2),
+			reg_virt + SPACE0_LOCAL_CFG_OFFSET + PL_GEN2);
+
+	/*
+	 * Initiate Link Training. We will delay for L0 as specified by
+	 * standard, but will still proceed and return success irrespective of
+	 * L0 status as this will be handled by explicit L0 state checks during
+	 * enumeration.
+	 */
+	 __raw_writel(LTSSM_EN_VAL | __raw_readl(reg_virt + CMD_STATUS),
+			 reg_virt + CMD_STATUS);
+
+	 /* 100ms */
+	 msleep(100);
+
+	/*
+	 * Identify ourselves as 'Bridge' for enumeration purpose. This also
+	 * avoids "Invalid class 0000 for header type 01" warnings from "lspci".
+	 *
+	 * If at all we want to restore the default class-subclass values, the
+	 * best place would be after returning from pci_common_init ().
+	 */
+	__raw_writew(PCI_CLASS_BRIDGE_PCI,
+			reg_virt + SPACE0_LOCAL_CFG_OFFSET + PCI_CLASS_DEVICE);
+
+	/*
+	 * Prevent the enumeration code from assigning resources to our BARs. We
+	 * will set up them after the scan is complete.
+	 */
+	disable_bars();
+
+	set_outbound_trans(res[0].start, res[0].end);
+
+	/* Enable 32-bit IO addressing support */
+	__raw_writew(PCI_IO_RANGE_TYPE_32 | (PCI_IO_RANGE_TYPE_32 << 8),
+			reg_virt + SPACE0_LOCAL_CFG_OFFSET + PCI_IO_BASE);
+
+	/*
+	 * FIXME: The IO Decode size bits in IO base and limit registers are
+	 * writable from host any time and during enumeration, the Linux PCI
+	 * core clears the lower 4-bits of these registers while writing lower
+	 * IO address. This makes IO upper address and limit registers to show
+	 * value as '0' and not the actual value as configured by the core
+	 * during enumeration. We need to re-write bits 0 of IO limit and base
+	 * registers again. Need to find if a post configuration hook is
+	 * possible. An easier and clear but possibly inefficient WA is to snoop
+	 * each config write and restore 32-bit IO decode configuration.
+	 */
+
+	/*
+	 * Setup as PCI master, also clear any pending  status bits.
+	 * FIXME: Nolonger needed as post-scan fixup handles this (see below).
+	 */
+#if 0
+	__raw_writel((__raw_readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET
+					+ PCI_COMMAND)
+			| CFG_PCIM_CSR_VAL),
+			reg_virt + SPACE0_LOCAL_CFG_OFFSET + PCI_COMMAND);
+#endif
+
+	legacy_irq = platform_get_irq_byname(pcie_pdev, "legacy_int");
+
+	if (legacy_irq >= 0) {
+		__raw_writel(0xf, reg_virt + IRQ_ENABLE_SET);
+	} else {
+		__raw_writel(0xf, reg_virt + IRQ_ENABLE_CLR);
+		pr_warning(DRIVER_NAME ": INTx disabled since no legacy IRQ\n");
+	}
+
+	msi_irq = platform_get_irq_byname(pcie_pdev, "msi_int");
+
+	if ((msi_irq >= 0) && msi_irq_num) {
+		if (msi_irq_num > CFG_MAX_MSI_NUM) {
+			msi_irq_num = max(msi_irq_num, CFG_MAX_MSI_NUM);
+			pr_warning(DRIVER_NAME
+				": Restricting MSI count to max supported (%d)",
+				msi_irq_num);
+		}
+
+		set_irq_chained_handler(msi_irq, ti816x_msi_handler);
+	} else {
+		pr_warning(DRIVER_NAME ": MSI info not available, disabled\n");
+		msi_irq_num = 0;
+	}
+
+	get_and_clear_err();
+
+	/*
+	 * PCIe access errors that result into OCP errors on TI816X are caught
+	 * by ARM as "External aborts" (Precise).
+	 */
+	hook_fault_code(8, ti816x_pcie_fault, SIGBUS, 0,
+			"Precise External Abort on non-linefetch");
+
+	 return 1;
+
+err_clken:
+	 clk_put(pcie_ck);
+err_clkget:
+	 iounmap((void __iomem *)reg_virt);
+err_ioremap:
+	 if (res[1].flags == IORESOURCE_IO)
+		 release_resource(&res[1]);
+err_iores:
+	 release_resource(&res[0]);
+err_memres:
+	 kfree(res);
+
+	 return -1;
+}
+
+/**
+ * check_device() - Checks device availability
+ * @bus: Pointer to bus to check the device availability on
+ * @dev: Device number
+ *
+ * Checks for the possibility of device being present. Relies on following
+ * logic to indicate success:
+ * - downstream link must be established to traverse PCIe fabric
+ * - treating RC as virtual PCI bridge, first (and only) device on bus 1 will be
+ *   numbered as 0
+ * - don't check device number beyond bus 1 as device on our secondary side may
+ *   as well be a PCIe-PCI bridge
+ */
+static int check_device(struct pci_bus *bus, int dev)
+{
+	if ((__raw_readl(reg_virt + SPACE0_LOCAL_CFG_OFFSET + DEBUG0) &
+				LTSSM_STATE_MASK) != LTSSM_STATE_L0)
+		return 0;
+
+	if (bus->number <= 1) {
+		if (dev == 0)
+			return 1;
+		else
+			return 0;
+	}
+
+	return 1;
+}
+
+/**
+ * setup_config_addr() - Set up configuration space address for a device
+ * @bus: Bus number the device is residing on
+ * @device: Device number
+ * @function: Function number in device
+ * @where: Offset of configuration register
+ *
+ * Forms and returns the address of configuration space mapped in PCIESS
+ * address space 0. Also configures CFG_SETUP for remote configuration space
+ * access.
+ *
+ * The address space has two regions to access configuration - local and remote.
+ * We access local region for bus 0 (as RC is attached on bus 0) and remote
+ * region for others with TYPE 1 access when bus > 1. As for device on bus = 1,
+ * we will do TYPE 0 access as it will be on our secondary bus (logical).
+ * CFG_SETUP is needed only for remote configuration access.
+ *
+ * _NOTE_: Currently only supports device 0 on bus = 0 which is OK as PCIESS has
+ * single root port.
+ */
+static inline u32 setup_config_addr(u8 bus, u8 device, u8 function)
+{
+	u32 addr;
+
+	if (bus == 0) {
+		addr = reg_virt + SPACE0_LOCAL_CFG_OFFSET;
+	} else {
+		u32 regval = (bus << 16) | (device << 8) | function;
+
+		/*
+		 * Since Bus#1 will be a virtual bus, we need to have TYPE0
+		 * access only.
+		 */
+		/* TYPE 1 */
+		if (bus != 1)
+			regval |= BIT(24);
+
+		__raw_writel(regval, reg_virt + CFG_SETUP);
+
+		addr = reg_virt + SPACE0_REMOTE_CFG_OFFSET;
+	}
+
+	return addr;
+}
+
+/**
+ * ti816x_pci_read_io() - Perform PCI IO read from a device
+ * @addr: IO address
+ * @size: Number of bytes
+ * @value: Pointer to hold the read value
+ */
+int ti816x_pci_io_read(u32 addr, int size, u32 *value)
+{
+	unsigned long flags;
+
+	if (!IS_ALIGNED(addr, size))
+		return -1;
+
+	pr_debug(DRIVER_NAME ": IO read @%#x = ", addr);
+
+	spin_lock_irqsave(&ti816x_pci_io_lock, flags);
+
+	__raw_writel(addr & 0xfffff000, reg_virt + IOBASE);
+
+	/* Get the actual address in I/O space */
+	addr = reg_virt + SPACE0_IO_OFFSET + (addr & 0xffc);
+
+	*value = __raw_readl(addr);
+	*value >>= ((addr & 3)*8);
+
+	spin_unlock_irqrestore(&ti816x_pci_io_lock, flags);
+
+	pr_debug("%#x\n", *value);
+
+	return 0;
+}
+EXPORT_SYMBOL(ti816x_pci_io_read);
+
+/**
+ * ti816x_pci_write_io() - Perform PCI IO write to a device
+ * @addr: IO address
+ * @size: Number of bytes
+ * @value: Value to write
+ */
+int ti816x_pci_io_write(u32 addr, int size, u32 value)
+{
+	unsigned long flags;
+	u32 iospace_addr;
+
+	if (!IS_ALIGNED(addr, size))
+		return -1;
+
+	pr_debug(DRIVER_NAME ": IO write @%#x = %#x\n", addr, value);
+
+	spin_lock_irqsave(&ti816x_pci_io_lock, flags);
+
+	__raw_writel(addr & 0xfffff000, reg_virt + IOBASE);
+
+	/* Get the actual address in I/O space */
+	iospace_addr = reg_virt + SPACE0_IO_OFFSET + (addr & 0xffc);
+
+	if (size != 4) {
+		u32 shift = (addr & 3) * 8;
+		u32 mask = (size == 1 ? 0xff : 0xffff) << shift;
+		u32 readval = __raw_readl(iospace_addr);
+		value = ((value << shift) & mask) | (readval & ~mask);
+	}
+
+	__raw_writel(value, iospace_addr);
+
+	spin_unlock_irqrestore(&ti816x_pci_io_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL(ti816x_pci_io_write);
+
+/**
+ * ti816x_pci_read_config() - Perform PCI configuration read from a device
+ * @bus: Pointer to bus to access device on
+ * @devfn: Device number of the bus and function number within
+ * @where: Configuration space register offset
+ * @size: Width of the register in bytes
+ * @value: Pointer to hold the read value
+ *
+ * Note: We skip alignment check and locking since it is taken care by PCI
+ * access wrappers.
+ */
+static int ti816x_pci_read_config(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 *value)
+{
+	u8 bus_num = bus->number;
+
+	pr_debug(DRIVER_NAME ": Reading config[%x] for device %04x:%02x:%02x..",
+			where, bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn));
+
+	if (!check_device(bus, PCI_SLOT(devfn))) {
+		*value = ~0;
+		pr_debug("failed. No link/device.\n");
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	*value = __raw_readl(setup_config_addr(bus_num, PCI_SLOT(devfn),
+				PCI_FUNC(devfn)) + (where & ~3));
+
+	if (size == 1)
+		*value = (*value >> (8 * (where & 3))) & 0xff;
+	else if (size == 2)
+		*value = (*value >> (8 * (where & 3))) & 0xffff;
+
+	pr_debug("done. value = %#x\n", *value);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/**
+ * ti816x_pci_write_config() - Perform PCI configuration write to a device
+ * @bus: Pointer to bus to access device on
+ * @devfn: Device number of the bus and function number within
+ * @where: Configuration space register offset
+ * @size: Width of the register in bytes
+ * @value: Value to write
+ *
+ * Note: We skip alignment check and locking since it is taken care by PCI
+ * access wrappers.
+ */
+static int ti816x_pci_write_config(struct pci_bus *bus, unsigned int devfn,
+				int where, int size, u32 value)
+{
+	u8 bus_num = bus->number;
+	u32 addr;
+
+	pr_debug(DRIVER_NAME ": Writing config[%x] = %x "
+			"for device %04x:%02x:%02x ...", where, value,
+			bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn));
+
+	if (!check_device(bus, PCI_SLOT(devfn))) {
+		pr_debug("failed. No link/device.\n");
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
+	addr = setup_config_addr(bus_num, PCI_SLOT(devfn), PCI_FUNC(devfn));
+
+	if (size == 4)
+		__raw_writel(value, addr + where);
+	else if (size == 2)
+		__raw_writew(value, addr + where);
+	else
+		__raw_writeb(value, addr + where);
+
+	/*
+	 * The h/w has a limitation where Config Writes don't signal aborts to
+	 * processor. Clear explicitly to avoid stale status.
+	 */
+	get_and_clear_err();
+
+	pr_debug("done.\n");
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops ti816x_pci_ops = {
+	.read	= ti816x_pci_read_config,
+	.write	= ti816x_pci_write_config,
+};
+
+static struct pci_bus *ti816x_pcie_scan(int nr, struct pci_sys_data *sys)
+{
+	struct pci_bus *bus = NULL;
+
+	pr_info(DRIVER_NAME ": Starting PCI scan...\n");
+	if (nr == 0) {
+		bus = pci_scan_bus(0, &ti816x_pci_ops, sys);
+
+		/* Post enumeration fixups */
+		set_inbound_trans();
+
+		/* Bridges are not getting enabled by default! */
+		pci_assign_unassigned_resources();
+	}
+
+	return bus;
+}
+
+/**
+ * ti816x_pcie_map_irq() - Map a legacy interrupt to an IRQ
+ * @dev: Device structure of End Point (EP) to assign IRQ to.
+ * @slot: Device slot
+ * @pin: Pin number for the function
+ *
+ * Note: Currently ignores all the parameters and only supports mapping to
+ * single IRQ.
+ */
+static int ti816x_pcie_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	pr_debug(DRIVER_NAME "Returning Legacy irq = %d\n", legacy_irq);
+	return (legacy_irq >= 0) ? legacy_irq : -1;
+}
+
+/* PCI controller setup and configuration data */
+static struct hw_pci ti816x_pci = {
+	.nr_controllers     = 1,
+	.setup              = ti816x_pcie_setup,
+	.scan               = ti816x_pcie_scan,
+	.preinit            = NULL,
+	.postinit           = NULL,
+	.swizzle            = pci_std_swizzle,
+	.map_irq            = ti816x_pcie_map_irq
+};
+
+/**
+ * ti816x_pcie_probe() - Invoke PCI BIOS to perrform enumeration.
+ * @pdev: Contains platform data as supplied from board level code.
+ *
+ * Also stores reference to platform device structure for use during PCIe
+ * module initialization and configuration.
+ */
+static int ti816x_pcie_probe(struct platform_device *pdev)
+{
+	struct ti816x_pcie_data *pdata;
+
+	pcie_pdev = pdev;
+
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		pr_err(DRIVER_NAME ": No platform data\n");
+		return -ENODEV;
+	}
+
+	msi_irq_base = pdata->msi_irq_base;
+	msi_irq_num = pdata->msi_irq_num;
+
+	pr_info(DRIVER_NAME ": Invoking PCI BIOS...\n");
+	pci_common_init(&ti816x_pci);
+
+	return 0;
+}
+
+static struct platform_driver ti816x_pcie_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+		.owner	= THIS_MODULE,
+	},
+	.probe = ti816x_pcie_probe,
+};
+
+/**
+ * ti816x_pcie_rc_init() - Register PCIe Root Complex node.
+ *
+ * Invoked as subsystem initialization.
+ *
+ * IMPORTANT NOTE: We are relying on SoC/Board level code to check PCIESS
+ * mode setting (RC/EP) and register the RC device only in RC mode.
+ */
+static int __init ti816x_pcie_rc_init(void)
+{
+	platform_driver_register(&ti816x_pcie_driver);
+	return 0;
+}
+subsys_initcall(ti816x_pcie_rc_init);
Index: kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pcie-ti816x.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/arch/arm/mach-omap2/pcie-ti816x.h	2012-09-23 16:05:56.996322027 -0600
@@ -0,0 +1,24 @@
+/*
+ * Platform data for ti816x PCIe Root Complex module.
+ *
+ * Copyright (C) 2010 Texas Instruments, Inc. - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ARCH_ARM_MACH_OMAP2_PCIE_TI816X_H
+#define __ARCH_ARM_MACH_OMAP2_PCIE_TI816X_H
+
+struct ti816x_pcie_data {
+	int msi_irq_base;
+	int msi_irq_num;
+};
+
+#endif
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/i2c/busses/i2c-omap.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/i2c/busses/i2c-omap.c	2012-03-22 23:12:58.000000000 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/i2c/busses/i2c-omap.c	2012-09-23 16:05:56.996322027 -0600
@@ -143,7 +143,6 @@
 #define OMAP_I2C_SCLH_HSSCLH	8
 
 /* I2C System Test Register (OMAP_I2C_SYSTEST): */
-#ifdef DEBUG
 #define OMAP_I2C_SYSTEST_ST_EN		(1 << 15)	/* System test enable */
 #define OMAP_I2C_SYSTEST_FREE		(1 << 14)	/* Free running mode */
 #define OMAP_I2C_SYSTEST_TMODE_MASK	(3 << 12)	/* Test mode select */
@@ -152,7 +151,6 @@
 #define OMAP_I2C_SYSTEST_SCL_O		(1 << 2)	/* SCL line drive out */
 #define OMAP_I2C_SYSTEST_SDA_I		(1 << 1)	/* SDA line sense in */
 #define OMAP_I2C_SYSTEST_SDA_O		(1 << 0)	/* SDA line drive out */
-#endif
 
 /* OCP_SYSSTATUS bit definitions */
 #define SYSS_RESETDONE_MASK		(1 << 0)
@@ -334,13 +332,56 @@
 	unsigned long timeout;
 	unsigned long internal_clk = 0;
 	struct clk *fclk;
+        u16 reg;
+        int cyclecnt;
 
 	if (dev->rev >= OMAP_I2C_REV_2) {
+
 		/* Disable I2C controller before soft reset */
 		omap_i2c_write_reg(dev, OMAP_I2C_CON_REG,
 			omap_i2c_read_reg(dev, OMAP_I2C_CON_REG) &
 				~(OMAP_I2C_CON_EN));
 
+                if ( 1 )
+                {
+                        dev_dbg(dev->dev,
+                                "Begin bus recovery procedure\n" );
+
+                        reg = OMAP_I2C_SYSTEST_ST_EN
+                                | OMAP_I2C_SYSTEST_FREE
+                                | ((3)<<OMAP_I2C_SYSTEST_TMODE_SHIFT)
+                                | OMAP_I2C_SYSTEST_SDA_O;
+
+                        omap_i2c_write_reg( dev,
+                                            OMAP_I2C_SYSTEST_REG,
+                                            reg );
+                        udelay(100);
+
+                        for ( cyclecnt=0; cyclecnt < 20; cyclecnt++ ) {
+                                reg &= ~OMAP_I2C_SYSTEST_SCL_O;
+                                omap_i2c_write_reg( dev,
+                                                    OMAP_I2C_SYSTEST_REG,
+                                                    reg );
+                                udelay(100);
+
+                                reg |= OMAP_I2C_SYSTEST_SCL_O;
+                                omap_i2c_write_reg( dev,
+                                                    OMAP_I2C_SYSTEST_REG,
+                                                    reg );
+                                udelay(100);
+                        }
+
+                        reg = OMAP_I2C_SYSTEST_SDA_O;
+
+                        omap_i2c_write_reg( dev,
+                                            OMAP_I2C_SYSTEST_REG,
+                                            reg );
+
+                        dev_dbg(dev->dev,
+                                "End bus recovery procedure\n" );
+                }
+
+
 		omap_i2c_write_reg(dev, OMAP_I2C_SYSC_REG, SYSC_SOFTRESET_MASK);
 		/* For some reason we need to set the EN bit before the
 		 * reset done bit gets set. */
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/adv7611.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/adv7611.c	2012-09-23 16:05:56.996322027 -0600
@@ -0,0 +1,956 @@
+//#define DEBUG
+/*
+ * Copyright (C) 2007-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+
+#include <media/v4l2-ioctl.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/davinci/videohd.h> // For HD std (V4L2_STD_1080I, etc)
+#include <asm/uaccess.h>
+
+#include "adv7611.h"
+
+/* Debug functions */
+static int debug = 0;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+
+/* Function Prototypes */
+static int adv7611_i2c_read_reg(struct i2c_client *client, u8 addr, u8 reg, u8 * val);
+static int adv7611_i2c_write_reg(struct i2c_client *client, u8 addr, u8 reg, u8 val);
+static int adv7611_querystd(struct v4l2_subdev *sd, v4l2_std_id *id);
+static int adv7611_s_std(struct v4l2_subdev *sd, v4l2_std_id std);
+
+static int adv7611_s_stream(struct v4l2_subdev *sd, int enable);
+
+static int adv7611_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+static int adv7611_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
+static int adv7611_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc);
+
+static int adv7611_initialize(struct v4l2_subdev *sd);
+static int adv7611_deinitialize(struct v4l2_subdev *sd);
+
+#if 0
+static struct v4l2_standard adv7611_standards[ADV7611_MAX_NO_STANDARDS] = {
+	{
+		.index = 0,
+		.id = V4L2_STD_720P_60,
+		.name = "720P-60",
+		.frameperiod = {1, 60},
+		.framelines = 750
+	},
+	{
+		.index = 1,
+		.id = V4L2_STD_1080I_60,
+		.name = "1080I-30",
+		.frameperiod = {1, 30},
+		.framelines = 1125
+	},
+	{
+		.index = 2,
+		.id = V4L2_STD_1080I_50,
+		.name = "1080I-25",
+		.frameperiod = {1, 25},
+		.framelines = 1125
+	},
+	{
+		.index = 3,
+		.id = V4L2_STD_720P_50,
+		.name = "720P-50",
+		.frameperiod = {1, 50},
+		.framelines = 750
+	},
+	{
+		.index = 4,
+		.id = V4L2_STD_1080P_25,
+		.name = "1080P-25",
+		.frameperiod = {1, 25},
+		.framelines = 1125
+	},
+	{
+		.index = 5,
+		.id = V4L2_STD_1080P_30,
+		.name = "1080P-30",
+		.frameperiod = {1, 30},
+		.framelines = 1125
+	},
+	{
+		.index = 6,
+		.id = V4L2_STD_1080P_24,
+		.name = "1080P-24",
+		.frameperiod = {1, 24},
+		.framelines = 1125
+	},
+	{
+		.index = 7,
+		.id = V4L2_STD_525P_60,
+		.name = "480P-60",
+		.frameperiod = {1, 60},
+		.framelines = 525
+	},
+	{
+		.index = 8,
+		.id = V4L2_STD_625P_50,
+		.name = "576P-50",
+		.frameperiod = {1, 50},
+		.framelines = 625
+	},
+	{
+		.index = 9,
+		.id = V4L2_STD_525_60,
+		.name = "NTSC",
+		.frameperiod = {1001, 30000},
+		.framelines = 525
+	},
+	{
+		.index = 10,
+		.id = V4L2_STD_625_50,
+		.name = "PAL",
+		.frameperiod = {1, 25},
+		.framelines = 625
+	},
+	{
+		.index = 11,
+		.id = V4L2_STD_1080P_50,
+		.name = "1080P-50",
+		.frameperiod = {1, 50},
+		.framelines = 1125
+	},
+	{
+		.index = 12,
+		.id = V4L2_STD_1080P_60,
+		.name = "1080P-60",
+		.frameperiod = {1, 60},
+		.framelines = 1125
+	},
+
+};
+#endif
+
+struct adv7611_channel {
+	struct v4l2_subdev    sd;
+        struct work_struct    work;
+        int                   ch_id;
+
+        int                   streaming;
+
+        s32                   output_format; // see ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_*
+
+        unsigned char IO_ADDR;
+        unsigned char DPLL_ADDR;
+        unsigned char CEC_ADDR;
+        unsigned char INFOFRAME_ADDR;
+        unsigned char KSV_ADDR;
+        unsigned char EDID_ADDR;
+        unsigned char HDMI_ADDR;
+        unsigned char CP_ADDR;
+};
+
+
+static const struct v4l2_subdev_video_ops adv7611_video_ops = {
+	.querystd = adv7611_querystd,
+	.s_stream = adv7611_s_stream,
+//	.g_input_status = adv7611_g_input_status,
+};
+
+static const struct v4l2_subdev_core_ops adv7611_core_ops = {
+        .g_chip_ident = NULL,
+	.g_ctrl = adv7611_g_ctrl,
+	.s_ctrl = adv7611_s_ctrl,
+	.queryctrl = adv7611_queryctrl,
+	.s_std = adv7611_s_std,
+};
+
+static const struct v4l2_subdev_ops adv7611_ops = {
+	.core = &adv7611_core_ops,
+	.video = &adv7611_video_ops,
+};
+
+
+static inline struct adv7611_channel *to_adv7611(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct adv7611_channel, sd);
+}
+
+
+
+/* adv7611_initialize :
+ * This function will set the video format standard
+ */
+static int adv7611_initialize(struct v4l2_subdev *sd)
+{
+	int err = 0;
+	struct i2c_client *ch_client = NULL;
+        struct adv7611_channel *channel = (to_adv7611(sd));
+
+        struct {
+                adv7611_i2caddr_t i2caddr;
+                u8                reg;
+                u8                val;
+        } *init_cur, init_sequence[] = {
+                { ADV7611_I2CADDR_IO,   0x01, 0x06 },
+                { ADV7611_I2CADDR_IO,   0x02, 0xf5 }, // YUV out
+                { ADV7611_I2CADDR_IO,   0x03, 0x80 },
+                { ADV7611_I2CADDR_IO,   0x05, 0x2c },
+//                { ADV7611_I2CADDR_IO,   0x02, 0xf5 }, // RGB discrete
+//                { ADV7611_I2CADDR_IO,   0x03, 0x80 },
+//                { ADV7611_I2CADDR_IO,   0x05, 0x2c },
+                { ADV7611_I2CADDR_IO,   0x06, 0xa6 }, // Invert HS, VS pins
+
+                /* Bring chip out of powerdown and disable tristate */
+                { ADV7611_I2CADDR_IO,   0x0b, 0x44 },
+                { ADV7611_I2CADDR_IO,   0x0c, 0x42 },
+                { ADV7611_I2CADDR_IO,   0x14, 0x3f },
+                { ADV7611_I2CADDR_IO,   0x15, 0xBE },
+
+                /* LLC DLL enable */
+//                { ADV7611_I2CADDR_IO,   0x19, 0x83 },
+                { ADV7611_I2CADDR_IO,   0x19, 0x94 },
+                { ADV7611_I2CADDR_IO,   0x33, 0x40 },
+
+                /* Force HDMI free run */
+                { ADV7611_I2CADDR_CP,   0xba, 0x01 },
+
+                /* Disable HDCP 1.1*/
+                { ADV7611_I2CADDR_KSV,  0x40, 0x81 },
+
+                /* ADI recommended writes */
+                { ADV7611_I2CADDR_HDMI, 0x9B, 0x03 },
+                { ADV7611_I2CADDR_HDMI, 0xC1, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xC2, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xC3, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xC4, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xC5, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xC6, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xC7, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xC8, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xC9, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xCA, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xCB, 0x01 },
+                { ADV7611_I2CADDR_HDMI, 0xCC, 0x01 },
+
+                { ADV7611_I2CADDR_HDMI, 0x00, 0x00 }, // Set HDMI port A
+                { ADV7611_I2CADDR_HDMI, 0x83, 0xFE }, // Enable clock terminator for port A
+                { ADV7611_I2CADDR_HDMI, 0x6F, 0x08 }, // ADI recommended setting
+                { ADV7611_I2CADDR_HDMI, 0x85, 0x1F }, // ADI recommended setting
+                { ADV7611_I2CADDR_HDMI, 0x87, 0x70 }, // ADI recommended setting
+                { ADV7611_I2CADDR_HDMI, 0x8D, 0x04 }, // LFG
+                { ADV7611_I2CADDR_HDMI, 0x8E, 0x1E }, // HFG
+                { ADV7611_I2CADDR_HDMI, 0x1A, 0x8A }, // unmute audio
+                { ADV7611_I2CADDR_HDMI, 0x57, 0xDA }, // ADI recommended setting
+                { ADV7611_I2CADDR_HDMI, 0x58, 0x01 }, // ADI recommended setting
+                { ADV7611_I2CADDR_HDMI, 0x75, 0x10 }, // DDC drive strength
+
+                { ADV7611_I2CADDR_NONE, 0, 0 },
+        };
+
+        u8 i2caddr;
+
+	ch_client = v4l2_get_subdevdata(sd);
+
+	v4l2_dbg(1, debug, sd, "Adv7611 driver registered\n");
+
+	/*Configure the ADV7611 in default 720p 60 Hz standard for normal
+	   power up mode */
+
+        for ( init_cur=&init_sequence[0];
+              err >=0 && init_cur->i2caddr != ADV7611_I2CADDR_NONE;
+              init_cur++ ) {
+
+                switch ( init_cur->i2caddr ) {
+                case ADV7611_I2CADDR_IO:
+                        i2caddr = channel->IO_ADDR;
+                        break;
+                case ADV7611_I2CADDR_DPLL:
+                        i2caddr = channel->DPLL_ADDR;
+                        break;
+                case ADV7611_I2CADDR_CEC:
+                        i2caddr = channel->CEC_ADDR;
+                        break;
+                case ADV7611_I2CADDR_INFOFRAME:
+                        i2caddr = channel->INFOFRAME_ADDR;
+                        break;
+                case ADV7611_I2CADDR_KSV:
+                        i2caddr = channel->KSV_ADDR;
+                        break;
+                case ADV7611_I2CADDR_EDID:
+                        i2caddr = channel->EDID_ADDR;
+                        break;
+                case ADV7611_I2CADDR_HDMI:
+                        i2caddr = channel->HDMI_ADDR;
+                        break;
+                case ADV7611_I2CADDR_CP:
+                        i2caddr = channel->CP_ADDR;
+                        break;
+                default:
+                        err = -EINVAL;
+                        adv7611_deinitialize(sd);
+                        return err;
+                        break;
+                }
+                err = adv7611_i2c_write_reg(ch_client,
+                                             i2caddr,
+                                             init_cur->reg,
+                                             init_cur->val);
+        }
+
+
+	if (err < 0) {
+		err = -EINVAL;
+		adv7611_deinitialize(sd);
+		return err;
+	}
+
+	v4l2_dbg(1, debug, sd, "End of adv7611_init.\n");
+	return err;
+}
+
+static int adv7611_deinitialize(struct v4l2_subdev *sd)
+{
+        struct adv7611_channel *channel = (to_adv7611(sd));
+	struct i2c_client      *ch_client = NULL;
+        int                     err;
+
+	ch_client = v4l2_get_subdevdata(sd);
+
+	v4l2_dbg(1, debug, sd, "adv7611_deinitialize.\n");
+
+        err = adv7611_i2c_write_reg(ch_client,
+                                    channel->IO_ADDR,
+                                    0x15,
+                                    0xBE);
+
+        return err;
+}
+
+static int adv7611_queryctrl(struct v4l2_subdev *sd, struct v4l2_queryctrl *qc)
+{
+	switch (qc->id) {
+	case ADV7611_V4L2_CONTROL_OUTPUT_FORMAT:
+		return v4l2_ctrl_query_fill(qc,
+                                            0,
+                                            ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_MAX,
+                                            1,
+                                            ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_YUV422 );
+	default:
+                return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int adv7611_g_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	int ret = 0;
+	struct i2c_client      *ch_client = NULL;
+        struct adv7611_channel *ch;
+
+
+        ch = to_adv7611(sd);
+
+	ch_client = v4l2_get_subdevdata(sd);
+
+
+	switch (ctrl->id) {
+	case ADV7611_V4L2_CONTROL_OUTPUT_FORMAT:
+                ctrl->value = ch->output_format;
+                break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static int adv7611_s_ctrl(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
+{
+	u8 reg_io_02;
+	u8 reg_io_03;
+	u8 reg_io_05;
+	int ret = 0;
+
+	struct i2c_client      *ch_client = NULL;
+        struct adv7611_channel *ch;
+
+
+        ch = to_adv7611(sd);
+
+	ch_client = v4l2_get_subdevdata(sd);
+
+
+	switch (ctrl->id) {
+	case ADV7611_V4L2_CONTROL_OUTPUT_FORMAT:
+                switch ( ctrl->value ) {
+                case ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_YUV422:
+                        reg_io_02 = 0xf5; // YUV colorspace
+                        reg_io_03 = 0x80; // 16-bit SDR
+                        reg_io_05 = 0x2c; // embedded syncs
+                        break;
+                case ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_RGB24:
+                        reg_io_02 = 0xf7; // RGB colorspace
+                        reg_io_03 = 0x40; // 24-bit SDR embedded syncs
+                        reg_io_05 = 0x2c; // embedded syncs
+                        break;
+
+                case ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_RGB24_DISCRETE:
+                        reg_io_02 = 0xf7; // RGB colorspace
+                        reg_io_03 = 0x40; // 24-bit SDR embedded syncs
+                        reg_io_05 = 0x28; // embedded syncs
+                        break;
+
+                case ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_YUV444:
+                        reg_io_02 = 0xf5; // YUV colorspace
+                        reg_io_03 = 0x40; // 24-bit SDR embedded syncs
+                        reg_io_05 = 0x2c; // embedded syncs
+                        break;
+
+                default:
+                        ret = -ERANGE;
+                        break;
+                }
+
+                if ( 0 == ret ) {
+                        ret = adv7611_i2c_write_reg(ch_client,
+                                                    ch->IO_ADDR,
+                                                    0x02,
+                                                    reg_io_02);
+                        ret |= adv7611_i2c_write_reg(ch_client,
+                                                     ch->IO_ADDR,
+                                                     0x03,
+                                                     reg_io_03);
+                        ret |= adv7611_i2c_write_reg(ch_client,
+                                                     ch->IO_ADDR,
+                                                     0x05,
+                                                     reg_io_05);
+                }
+
+                ch->output_format = ctrl->value;
+
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+
+
+/* adv7611_setstd :
+ * Function to set the video standard
+ */
+static int adv7611_s_std(struct v4l2_subdev *sd, v4l2_std_id std)
+{
+	int err = 0;
+        struct adv7611_channel *channel = to_adv7611(sd);
+        struct i2c_client *ch_client = v4l2_get_subdevdata(sd);
+
+        /* No support for forcing standard */
+
+        (void) channel;
+        (void) ch_client;
+
+	v4l2_dbg(1, debug, sd, "Start of adv7611_setstd..\n");
+
+	v4l2_dbg(1, debug, sd, "End of adv7611 set standard...\n");
+	return err;
+}
+
+
+/* adv7611_querystd :
+ * Function to return standard detected by decoder
+ */
+static int adv7611_querystd(struct v4l2_subdev *sd, v4l2_std_id *id)
+{
+	int err = 0;
+	unsigned char val;
+	unsigned short stdi_cp8l       = 0;      /* Block length - clocks per 8 lines */
+        unsigned char  stdi_lcvs       = 0;      /* Line count in vertical sync */
+        unsigned short stdi_lpf        = 0;       /* Lines per field */
+        unsigned short stdi_cpfdiv256  = 0; /* Clocks per field div 256 */
+        unsigned char  stdi_interlaced = 0;
+
+        int detected      = 0;
+        int gotformat     = 0;
+        int formatretries = 4;
+        struct i2c_client *ch_client    = v4l2_get_subdevdata(sd);
+        struct adv7611_channel *channel = to_adv7611(sd);
+        unsigned int fps_1000 = 0;
+
+        struct {
+                v4l2_std_id id;
+                unsigned short       lpf_low;
+                unsigned short       lpf_high;
+                unsigned int         fps1000_low;
+                unsigned int         fps1000_high;
+
+        } *queryStdEntry, queryStdTable[ ] = {
+                {V4L2_STD_1080P_25, 0x462, 0x465, 24800, 25200},
+                {V4L2_STD_1080P_30, 0x462, 0x465, 29700, 30300},
+                {V4L2_STD_1080P_50, 0x462, 0x465, 49500, 50500},
+                {V4L2_STD_1080P_60|V4L2_STD_HD_DIV_1001, 0x462, 0x465, 59900, 59979},
+                {V4L2_STD_1080P_60, 0x462, 0x465, 59400, 60600},
+                {V4L2_STD_1080P_24, 0x462, 0x465, 23700, 24300},
+
+                {V4L2_STD_1080I_60|V4L2_STD_HD_DIV_1001, 0x230, 0x233, 59900, 59979},
+                {V4L2_STD_1080I_60, 0x230, 0x233, 59400, 60600},
+                {V4L2_STD_1080I_50, 0x230, 0x233, 49500, 50500},
+
+                {V4L2_STD_720P_60|V4L2_STD_HD_DIV_1001,  0x2ea, 0x2ee, 59900, 59979},
+                {V4L2_STD_720P_60,  0x2ea, 0x2ee, 59400, 60600},
+                {V4L2_STD_720P_50,  0x2ea, 0x2ee, 49500, 50500},
+
+
+                {V4L2_STD_800x600_60,  627,   629, 59000, 61000 },
+                {V4L2_STD_800x600_72,  665,   667, 71000, 73000 },
+                {V4L2_STD_800x600_75,  624,   626, 74000, 76000 },
+                {V4L2_STD_800x600_85,  630,   632, 84000, 86000 },
+
+                {V4L2_STD_525P_60,     523,   525, 59000,  61000 },
+                {V4L2_STD_625P_50,     623,   625, 49000,  51000 },
+                {V4L2_STD_525_60,      260,   263, 59000,  61000 },
+                {V4L2_STD_625_50,      310,   313, 49000,  51000 },
+
+                {V4L2_STD_1024x768_60, 805,   807, 59000, 61000 },
+                {V4L2_STD_1024x768_70, 805,   807, 69000, 71000 },
+                {V4L2_STD_1024x768_75, 799,   801, 74000, 76000 },
+                {V4L2_STD_1024x768_85, 807,   809, 84000, 86000 },
+
+                {V4L2_STD_1280x600_60, 621,   623, 59000, 61000 },
+
+                {V4L2_STD_1280x720_60, 745,   747, 59000, 61000 },
+                {V4L2_STD_1280x720_75, 751,   753, 74000, 76000 },
+                {V4L2_STD_1280x720_85, 755,   757, 84000, 86000 },
+
+                {V4L2_STD_1280x768_60, 794,   796, 59000, 61000 },
+                {V4L2_STD_1280x768_75, 801,   803, 74000, 76000 },
+                {V4L2_STD_1280x768_85, 806,   808, 84000, 86000 },
+
+                {V4L2_STD_1280x800_60, 822,   824, 59000, 61000 },
+
+                {V4L2_STD_1280x1024_60, 1065, 1067, 59000, 61000 },
+                {V4L2_STD_1280x1024_75, 1065, 1067, 74000, 76000 },
+                {V4L2_STD_1280x1024_85, 1071, 1073, 84000, 86000 },
+
+                {               0,      0,     0,     0,     0},
+        };
+
+	v4l2_dbg(1, debug, sd, "Starting querystd function...\n");
+	if (id == NULL) {
+		dev_err(&ch_client->dev, "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+
+        err = adv7611_i2c_read_reg(ch_client,
+                                   channel->CP_ADDR,
+                                   0xb1,
+                                   &val);
+
+        if (err < 0) {
+                dev_err(&ch_client->dev,
+                        "I2C read fails...sync detect\n");
+                return err;
+        }
+
+        detected = (val & 0x80);
+        stdi_interlaced = (val & 0x40) ? 1 : 0;
+        stdi_cp8l = (val&0x3f);
+        stdi_cp8l <<= 8;
+
+        if ( !detected ) {
+                v4l2_dbg( 1, debug, sd, "No sync detected\n");
+                return -EIO;
+        }
+
+
+        do {
+                /* Query clock cycles per 8 lines */
+                err = adv7611_i2c_read_reg(ch_client,
+                                           channel->CP_ADDR,
+                                           0xb2, &val);
+                if (err < 0) {
+                        dev_err(&ch_client->dev,
+                                "I2C read fails...Lines per frame high\n");
+                        return err;
+                }
+
+                stdi_cp8l |= (val&0xff);
+
+
+                /* Query line count in vertical sync */
+                err = adv7611_i2c_read_reg(ch_client,
+                                           channel->CP_ADDR,
+                                           0xb3, &stdi_lcvs);
+                if (err < 0) {
+                        dev_err(&ch_client->dev,
+                                "I2C read fails...Lines per frame low\n");
+                        return err;
+                }
+                stdi_lcvs >>= 3;
+                stdi_lcvs &= 0x1f;
+
+
+                /* Query lines per field */
+                err = adv7611_i2c_read_reg(ch_client,
+                                           channel->CP_ADDR,
+                                           0xa3, &val);
+                stdi_lpf = (val& 0xf);
+                stdi_lpf <<= 8;
+
+                err |= adv7611_i2c_read_reg(ch_client,
+                                           channel->CP_ADDR,
+                                           0xa4, &val);
+                stdi_lpf |= val;
+
+                if (err < 0) {
+                        dev_err(&ch_client->dev,
+                                "I2C read fails...Lines per field\n");
+                        return err;
+                }
+
+                /* Query clocks per field div 256 */
+                err = adv7611_i2c_read_reg(ch_client,
+                                           channel->CP_ADDR,
+                                           0xb8, &val);
+                stdi_cpfdiv256 = (val& 0x1f);
+                stdi_cpfdiv256 <<= 8;
+
+                err |= adv7611_i2c_read_reg(ch_client,
+                                           channel->CP_ADDR,
+                                           0xb9, &val);
+                stdi_cpfdiv256 |= val;
+
+                if (err < 0) {
+                        dev_err(&ch_client->dev,
+                                "I2C read fails...CPF div 256\n");
+                        return err;
+                }
+
+
+                fps_1000 = (28636360/256)*1000;
+                if ( stdi_cpfdiv256 != 0 ) {
+                        fps_1000 /= stdi_cpfdiv256;
+                }
+
+                for ( queryStdEntry = &queryStdTable[0];
+                      queryStdEntry->id != 0 ;
+                      queryStdEntry++ ) {
+
+                        dev_dbg(&ch_client->dev,
+                                "entry %d %u-%u %u-%u\n",
+                                queryStdEntry - &queryStdTable[0],
+                                queryStdEntry->lpf_low,
+                                queryStdEntry->lpf_high,
+                                queryStdEntry->fps1000_low,
+                                queryStdEntry->fps1000_high );
+
+                        if ( (queryStdEntry->lpf_low <= stdi_lpf)
+                             && (queryStdEntry->lpf_high >= stdi_lpf )
+                             && (queryStdEntry->fps1000_low <= fps_1000)
+                             && (queryStdEntry->fps1000_high >= fps_1000) ) {
+
+                                *id = queryStdEntry->id;
+                                gotformat = 1;
+                                break;
+                        }
+                }
+
+
+                if ( !gotformat ) {
+                        /* VSYNC ctr may take some time to converge */
+                        msleep(50);
+                }
+
+        } while ( gotformat == 0 && --formatretries > 0 ) ;
+
+	dev_notice(&ch_client->dev,
+		   "ADV7611 - interlaced=%d lines per field=%d clocks per 8 lines=%d fps=%u.%03u\n",
+                   (int)stdi_interlaced,
+                   (int)stdi_lpf, (int)stdi_cp8l, fps_1000/1000, fps_1000%1000);
+
+        if ( !gotformat ) {
+		dev_notice(&ch_client->dev, "querystd: No std detected\n" );
+                return -EINVAL;
+	}
+
+        err = 0;
+
+	v4l2_dbg(1, debug, sd, "End of querystd function.\n");
+	return err;
+}
+
+
+/* adv7611_s_stream:
+ *
+ *     Enable streaming.
+ *
+ *     For video decoder, this means driving the output bus,
+ *     which may be shared with other video decoders.
+ */
+static int adv7611_s_stream(struct v4l2_subdev *sd, int enable)
+{
+        struct i2c_client *ch_client = v4l2_get_subdevdata(sd);
+        struct adv7611_channel *channel = to_adv7611(sd);
+        int err = 0;
+
+        v4l2_dbg(1, debug, sd, "s_stream %d\n", enable);
+
+//        if (channel->streaming == enable)
+//                return 0;
+
+        if ( enable ) {
+                err = adv7611_i2c_write_reg(ch_client,
+                                            channel->IO_ADDR,
+                                            0x15,
+                                            0xA0);
+        } else {
+                err = adv7611_i2c_write_reg(ch_client,
+                                            channel->IO_ADDR,
+                                            0x15,
+                                            0xBE);
+        }
+
+        if (err) {
+                v4l2_err(sd, "s_stream: err %d\n", err);
+        } else {
+                channel->streaming = enable;
+        }
+
+        return err;
+}
+
+
+/* adv7611_i2c_read_reg :This function is used to read value from register
+ * for i2c client.
+ */
+static int adv7611_i2c_read_reg(struct i2c_client *client, u8 addr, u8 reg, u8 * val)
+{
+	int err = 0;
+        int retries = 5;
+
+	struct i2c_msg msg[2];
+	unsigned char writedata[1];
+	unsigned char readdata[1];
+
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+
+             do {
+		msg[0].addr = addr;
+		msg[0].flags = 0;
+		msg[0].len = 1;
+		msg[0].buf = writedata;
+		writedata[0] = reg;
+
+		msg[1].addr = addr;
+		msg[1].flags = I2C_M_RD;
+		msg[1].len = 1;
+		msg[1].buf = readdata;
+
+		err = i2c_transfer(client->adapter, msg, 2);
+                if (err >= 2) {
+                        *val = readdata[0];
+		} else {
+                        msleep(10);
+                        v4l2_warn(client, "Read: retry ... %d\n", retries);
+                }
+             } while ( err < 2 && --retries > 0);
+	}
+        if ( err < 0 ) {
+                dev_err( &client->adapter->dev, "ADV7611: read addr %02x reg x%02x failed\n", (int) addr, (int) reg );
+        } else {
+                v4l_dbg( 2, debug, client, "ADV7611: read addr %02x reg x%02x val %02x\n", (int) addr, (int)reg, (int)(*val) );
+        }
+
+	return ((err < 0) ? err : 0);
+}
+
+/* adv7611_i2c_write_reg :This function is used to write value into register
+ * for i2c client.
+ */
+static int adv7611_i2c_write_reg(struct i2c_client *client, u8 addr, u8 reg, u8 val)
+{
+	int err = 0;
+
+        int retries = 3;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+             do {
+		msg->addr = addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+                if ( err < 0 ) {
+                     msleep(10);
+                     v4l_warn(client, "Write: retry ... %d\n", retries);
+                }
+             } while ( err < 0 && --retries > 0);
+	}
+
+        if ( err < 0
+             && client->adapter != NULL ) {
+             dev_err( &client->adapter->dev,
+                      "adv7611 i2c write failed: addr %02x reg x%02x value x%02x\n",
+                      (unsigned int)addr,
+                      (unsigned int)reg,
+                      (unsigned int)val
+                  );
+        }
+
+        v4l_dbg( 2, debug, client, "ADV7611: write addr %02x reg x%02x val %02x\n", (int) addr, (int)reg, (int)val );
+
+	return ((err < 0) ? err : 0);
+}
+
+
+/****************************************************************************
+			I2C Client & Driver
+ ****************************************************************************/
+
+static int adv7611_probe(struct i2c_client *c,
+			 const struct i2c_device_id *id)
+{
+	struct adv7611_channel *core;
+	struct v4l2_subdev *sd;
+        int ret;
+
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(c->adapter,
+	     I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+		return -EIO;
+
+	core = kzalloc(sizeof(struct adv7611_channel), GFP_KERNEL);
+	if (!core) {
+		return -ENOMEM;
+	}
+
+
+	sd = &core->sd;
+	v4l2_i2c_subdev_init(sd, c, &adv7611_ops);
+	v4l_info(c, "chip found @ 0x%02x (%s)\n",
+		 c->addr << 1, c->adapter->name);
+
+        core->IO_ADDR = c->addr;
+        if ( core->IO_ADDR == 0x4c ) {
+                core->DPLL_ADDR = 0x3F;
+		core->CEC_ADDR  = 0x40;
+		core->INFOFRAME_ADDR = 0x3E;
+		core->KSV_ADDR  = 0x32;
+		core->EDID_ADDR = 0x36;
+		core->HDMI_ADDR = 0x34;
+		core->CP_ADDR   = 0x22;
+        }
+        else if ( core->IO_ADDR == 0x4d ) {
+                core->DPLL_ADDR = 0x45;
+		core->CEC_ADDR  = 0x46;
+		core->INFOFRAME_ADDR = 0x47;
+		core->KSV_ADDR  = 0x48;
+		core->EDID_ADDR = 0x49;
+		core->HDMI_ADDR = 0x4a;
+		core->CP_ADDR   = 0x4b;
+        }
+        else {
+                ret = -EINVAL;
+                v4l_err(c, "adv7611 invalid I2C address %02x\n", c->addr );
+                kfree(core);
+                return ret;
+        }
+
+
+        ret = adv7611_initialize(sd);
+        if ( ret != 0 ) {
+             v4l_err(c, "adv7611 init failed, code %d\n", ret );
+             kfree(core);
+             return ret;
+        }
+
+	return ret;
+}
+
+static int adv7611_remove(struct i2c_client *c)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(c);
+
+#ifdef DEBUG
+ 	v4l_info(c,
+		"adv7611.c: removing adv7611 adapter on address 0x%x\n",
+		c->addr << 1);
+#endif
+
+	v4l2_device_unregister_subdev(sd);
+//	kfree(to_adv7611(sd));
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static const struct i2c_device_id adv7611_id[] = {
+	{ "adv7611", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, adv7611_id);
+
+static struct i2c_driver adv7611_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "adv7611",
+	},
+	.probe		= adv7611_probe,
+	.remove		= adv7611_remove,
+	.id_table	= adv7611_id,
+};
+
+static __init int init_adv7611(void)
+{
+	return i2c_add_driver(&adv7611_driver);
+}
+
+static __exit void exit_adv7611(void)
+{
+	i2c_del_driver(&adv7611_driver);
+}
+
+module_init(init_adv7611);
+module_exit(exit_adv7611);
+
+MODULE_DESCRIPTION("Analog Devices AD9880 video decoder driver");
+MODULE_AUTHOR("John Whittington");
+MODULE_LICENSE("GPL");
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/adv7611.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/adv7611.h	2012-09-23 16:05:56.996322027 -0600
@@ -0,0 +1,76 @@
+#ifndef _VIDEO_ADV7611_H
+#define _VIDEO_ADV7611_H
+
+#ifdef __KERNEL__
+
+typedef enum {
+        ADV7611_I2CADDR_NONE,
+        ADV7611_I2CADDR_IO,
+        ADV7611_I2CADDR_DPLL,
+        ADV7611_I2CADDR_CEC,
+        ADV7611_I2CADDR_INFOFRAME,
+        ADV7611_I2CADDR_KSV,
+        ADV7611_I2CADDR_EDID,
+        ADV7611_I2CADDR_HDMI,
+        ADV7611_I2CADDR_CP,
+} adv7611_i2caddr_t;
+
+
+#define ADV7611_MAX_NO_INPUTS			1
+#define ADV7611_MAX_NO_STANDARDS		13
+#define ADV7611_MAX_NO_CONTROLS			0
+
+
+#define ADV7611_LINES_720_LOWER       0x2Ea
+#define ADV7611_LINES_720_UPPER       0x2EE
+
+#define ADV7611_LINES_1080P_LOWER   0x462
+#define ADV7611_LINES_1080P_UPPER   0x465
+
+#define ADV7611_LINES_1080I_60_LOWER   0x230
+#define ADV7611_LINES_1080I_60_UPPER   0x233
+
+
+
+/* ADV7611 registers */
+
+#define ADV7611_REG_HDMI_AUDIO_DPLL_COAST  0x13
+
+
+#define ADV7611_REG_HDMI_I2S_SELECT    0x6D
+#define ADV7611_SHIFT_HDMI_I2S_SELECT     4
+#define ADV7611_MASK_HDMI_I2S_SELECT   0x30
+
+#define ADV7611_REG_HDMI_I2S_TDM_MODE  0x6D
+#define ADV7611_SHIFT_HDMI_TDM_MODE       7
+#define ADV7611_MASK_HDMI_TDM_MODE     0x80
+
+/* I2S bus mux */
+#define ADV7611_VALUE_HDMI_I2S_SELECT_I2S0  0x00
+#define ADV7611_VALUE_HDMI_I2S_SELECT_I2S3  0x10
+#define ADV7611_VALUE_HDMI_I2S_SELECT_I2S2  0x20
+#define ADV7611_VALUE_HDMI_I2S_SELECT_I2S1  0x30
+
+/* Bit width for right-justified mode */
+#define ADV7611_REG_HDMI_I2S_WIDTH    0x03
+#define ADV7611_SHIFT_HDMI_I2S_WIDTH     0
+#define ADV7611_MASK_HDMI_I2S_WIDTH   0x1f
+
+#define ADV7611_REG_IO_TRISTATE_AUDIO      0x15
+#define ADV7611_SHIFT_IO_TRISTATE_AUDIO       4
+#define ADV7611_MASK_IO_TRISTATE_AUDIO     0x10
+#endif
+
+#define ADV7611_V4L2_CONTROL_OUTPUT_FORMAT  (V4L2_CID_PRIVATE_BASE + 0)
+
+enum {
+        ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_YUV422 = 0 ,
+        ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_RGB24  = 1 ,
+        ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_YUV444 = 2 ,
+        ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_RGB24_DISCRETE = 3,
+        ADV7611_V4L2_CONTROL_OUTPUT_FORMAT_MAX
+};
+
+
+
+#endif
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/adv9880.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/adv9880.c	2012-09-23 16:05:56.996322027 -0600
@@ -0,0 +1,1808 @@
+#define DEBUG
+/*
+ * Copyright (C) 2007-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/ctype.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/i2c-id.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+
+#include <media/v4l2-ioctl.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/davinci/videohd.h> // For HD std (V4L2_STD_1080I, etc)
+#include <asm/uaccess.h>
+#if defined(CONFIG_DAVINCI_DM368_FPGA)
+#include <asm/arch/dm368_fpga.h>
+#endif
+
+#include "adv9880.h"
+
+/* Function Prototypes */
+static int adv9880_set_hdmi_colorspace(struct i2c_client *ch_client);
+static int adv9880_set_format_params(struct v4l2_subdev *sd,
+                                     struct adv9880_format_params *tvpformats);
+static int adv9880_i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val);
+static int adv9880_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val);
+static int adv9880_querystd(struct v4l2_subdev *sd, v4l2_std_id *id);
+static int adv9880_s_std(struct v4l2_subdev *sd, v4l2_std_id std);
+static int adv9880_s_routing(struct v4l2_subdev *sd,
+                             u32 input, u32 output, u32 config);
+
+static int adv9880_initialize(struct v4l2_subdev *sd);
+static int adv9880_deinitialize(struct v4l2_subdev *sd);
+
+static 	v4l2_std_id cea861_stds[256] = {
+     [2]  = V4L2_STD_525P_60,
+     [3]  = V4L2_STD_525P_60,
+
+     [4]  = V4L2_STD_720P_60,
+     [5]  = V4L2_STD_1080I_60,
+
+     [16] = V4L2_STD_1080P_60,
+
+     [19] = V4L2_STD_720P_50,
+     [20] = V4L2_STD_1080I_50,
+
+     [31] = V4L2_STD_1080P_50,
+     [32] = V4L2_STD_1080P_24,
+     [33] = V4L2_STD_1080P_25,
+     [34] = V4L2_STD_1080P_30,
+
+     [39] = V4L2_STD_1080I_50, // 1080I, 1250 total, 50fps
+
+//     [60] = V4L2_STD_720P_24,
+     [61] = V4L2_STD_720P_25,
+     [62] = V4L2_STD_720P_30,
+};
+
+unsigned int cea861_fps_1000[256] = {
+     [2]  = 60000,
+     [3]  = 60000,
+
+     [4]  = 60000,
+     [5]  = 60000,
+
+     [16] = 60000,
+
+     [19] = 50000,
+     [20] = 50000,
+
+     [31] = 50000,
+     [32] = 24000,
+     [33] = 25000,
+     [34] = 30000,
+
+     [39] = 50000, // 1080I, 1250 total, 50fps
+
+     [60] = 24000,
+     [61] = 25000,
+     [62] = 30000,
+};
+
+static struct v4l2_standard adv9880_standards[ADV9880_MAX_NO_STANDARDS] = {
+	{
+		.index = 0,
+		.id = V4L2_STD_720P_60,
+		.name = "720P-60",
+		.frameperiod = {1, 60},
+		.framelines = 750
+	},
+	{
+		.index = 1,
+		.id = V4L2_STD_1080I_60,
+		.name = "1080I-30",
+		.frameperiod = {1, 30},
+		.framelines = 1125
+	},
+	{
+		.index = 2,
+		.id = V4L2_STD_1080I_50,
+		.name = "1080I-25",
+		.frameperiod = {1, 25},
+		.framelines = 1125
+	},
+	{
+		.index = 3,
+		.id = V4L2_STD_720P_50,
+		.name = "720P-50",
+		.frameperiod = {1, 50},
+		.framelines = 750
+	},
+	{
+		.index = 4,
+		.id = V4L2_STD_1080P_25,
+		.name = "1080P-25",
+		.frameperiod = {1, 25},
+		.framelines = 1125
+	},
+	{
+		.index = 5,
+		.id = V4L2_STD_1080P_30,
+		.name = "1080P-30",
+		.frameperiod = {1, 30},
+		.framelines = 1125
+	},
+	{
+		.index = 6,
+		.id = V4L2_STD_1080P_24,
+		.name = "1080P-24",
+		.frameperiod = {1, 24},
+		.framelines = 1125
+	},
+	{
+		.index = 7,
+		.id = V4L2_STD_525P_60,
+		.name = "480P-60",
+		.frameperiod = {1, 60},
+		.framelines = 525
+	},
+	{
+		.index = 8,
+		.id = V4L2_STD_625P_50,
+		.name = "576P-50",
+		.frameperiod = {1, 50},
+		.framelines = 625
+	},
+	{
+		.index = 9,
+		.id = V4L2_STD_525_60,
+		.name = "NTSC",
+		.frameperiod = {1001, 30000},
+		.framelines = 525
+	},
+	{
+		.index = 10,
+		.id = V4L2_STD_625_50,
+		.name = "PAL",
+		.frameperiod = {1, 25},
+		.framelines = 625
+	},
+	{
+		.index = 11,
+		.id = V4L2_STD_1080P_50,
+		.name = "1080P-50",
+		.frameperiod = {1, 50},
+		.framelines = 1125
+	},
+	{
+		.index = 12,
+		.id = V4L2_STD_1080P_60,
+		.name = "1080P-60",
+		.frameperiod = {1, 60},
+		.framelines = 1125
+	},
+
+};
+
+static struct adv9880_format_params
+	adv9880_formats[ADV9880_MAX_NO_STANDARDS] = {
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_720p,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_720p,
+		.hpll_vco_control = VCO_CONTROL_720p,
+		.hpll_cp_current = CP_CURRENT_720p,
+		.hpll_phase_select = PHASE_SELECT_720p,
+		.hpll_control = HPLL_CONTROL_720p,
+		.avid_start_msb = AVID_START_PIXEL_MSB_720p,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_720p,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_720p,
+		.vblk_start_f0_line_offset = 30, // VBLK_F0_START_LINE_OFFSET_720p,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_720p,
+		.vblk_f0_duration = 0, // VBLK_F0_DURATION_720p,
+		.vblk_f1_duration = 0, // VBLK_F1_DURATION_720p,
+		.clamp_start = ADV9880_HD_CLAMP_START,
+		.clamp_width = ADV9880_HD_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_HD_PRE_COAST,
+		.hpll_post_coast = ADV9880_HD_POST_COAST,
+		.reserved = RESERVED_720p,
+                .screen_height_msb = 0x02,
+                .screen_height_lsb = 0xed,
+                .sync_filter_control = 0xdc,
+				.vsync_duration = 26,
+
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080i,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080i,
+		.hpll_vco_control = VCO_CONTROL_1080i,
+		.hpll_cp_current = CP_CURRENT_1080i,
+		.hpll_phase_select = PHASE_SELECT_1080i,
+		.hpll_control = HPLL_CONTROL_1080i,
+		.avid_start_msb = AVID_START_PIXEL_MSB_1080i,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_1080i,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080i,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080i,
+		.vblk_start_f0_line_offset = 1,//VBLK_F0_START_LINE_OFFSET_1080i,
+		.vblk_start_f1_line_offset = 0,//VBLK_F1_START_LINE_OFFSET_1080i,
+		.vblk_f0_duration = 0,//VBLK_F0_DURATION_1080i,
+		.vblk_f1_duration = 1,//VBLK_F1_DURATION_1080i,
+		.clamp_start = ADV9880_HD_CLAMP_START,
+		.clamp_width = ADV9880_HD_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_HD_PRE_COAST,
+		.hpll_post_coast = ADV9880_HD_POST_COAST,
+		.reserved = RESERVED_1080i,
+                .screen_height_msb = 0x04,
+                .screen_height_lsb = 0x64,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+//		.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+		.vsync_duration = 2,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080i_50,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080i_50,
+		.hpll_vco_control = VCO_CONTROL_1080i_50,
+		.hpll_cp_current = CP_CURRENT_1080i_50,
+		.hpll_phase_select = PHASE_SELECT_1080i_50,
+		.hpll_control = HPLL_CONTROL_1080i_50,
+		.avid_start_msb = AVID_START_PIXEL_MSB_1080i_50,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_1080i_50,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080i_50,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080i_50,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080i_50,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080i_50,
+		.vblk_f0_duration = VBLK_F0_DURATION_1080i_50,
+		.vblk_f1_duration = VBLK_F1_DURATION_1080i_50,
+		.clamp_start = ADV9880_HD_CLAMP_START,
+		.clamp_width = ADV9880_HD_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_HD_PRE_COAST,
+		.hpll_post_coast = ADV9880_HD_POST_COAST,
+		.reserved = RESERVED_1080i_50,
+                .screen_height_msb = 0x04,
+                .screen_height_lsb = 0x38,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_720p_50,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_720p_50,
+		.hpll_vco_control = VCO_CONTROL_720p_50,
+		.hpll_cp_current = CP_CURRENT_720p_50,
+		.hpll_phase_select = PHASE_SELECT_720p_50,
+		.hpll_control = HPLL_CONTROL_720p_50,
+		.avid_start_msb = AVID_START_PIXEL_MSB_720p_50,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_720p_50,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p_50,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_720p_50,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_720p_50,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_720p_50,
+		.vblk_f0_duration = VBLK_F0_DURATION_720p_50,
+		.vblk_f1_duration = 0,
+		.clamp_start = ADV9880_HD_CLAMP_START,
+		.clamp_width = ADV9880_HD_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_HD_PRE_COAST,
+		.hpll_post_coast = ADV9880_HD_POST_COAST,
+		.reserved = RESERVED_720p,
+                .screen_height_msb = 0x02,
+                .screen_height_lsb = 0xd0,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080P_25,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080P_25,
+		.hpll_vco_control = VCO_CONTROL_1080P_25,
+		.hpll_cp_current = CP_CURRENT_1080P_25,
+		.hpll_phase_select = PHASE_SELECT_1080P_25,
+		.hpll_control = HPLL_CONTROL_1080P_25,
+		.avid_start_msb = AVID_START_PIXEL_MSB_1080P_25,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_1080P_25,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080P_25,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080P_25,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080P_25,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080P_25,
+		.vblk_f0_duration = VBLK_F0_DURATION_1080P_25,
+		.vblk_f1_duration = 0,
+		.clamp_start = ADV9880_HD_CLAMP_START,
+		.clamp_width = ADV9880_HD_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_HD_PRE_COAST,
+		.hpll_post_coast = ADV9880_HD_POST_COAST,
+		.reserved = RESERVED_1080P_30,
+                .screen_height_msb = 0x04,
+                .screen_height_lsb = 0x38,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080P_30,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080P_30,
+		.hpll_vco_control = VCO_CONTROL_1080P_30,
+		.hpll_cp_current = CP_CURRENT_1080P_30,
+		.hpll_phase_select = PHASE_SELECT_1080P_30,
+		.hpll_control = HPLL_CONTROL_1080P_30,
+		.avid_start_msb = AVID_START_PIXEL_MSB_1080P_30,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_1080P_30,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080P_30,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080P_30,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080P_30,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080P_30,
+		.vblk_f0_duration = VBLK_F0_DURATION_1080P_30,
+		.vblk_f1_duration = 0,
+		.clamp_start = ADV9880_HD_CLAMP_START,
+		.clamp_width = ADV9880_HD_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_HD_PRE_COAST,
+		.hpll_post_coast = ADV9880_HD_POST_COAST,
+		.reserved = RESERVED_1080P,
+                .screen_height_msb = 0x04,
+                .screen_height_lsb = 0x38,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080P_24,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080P_24,
+		.hpll_vco_control = VCO_CONTROL_1080P_24,
+		.hpll_cp_current = CP_CURRENT_1080P_24,
+		.hpll_phase_select = PHASE_SELECT_1080P_24,
+		.hpll_control = HPLL_CONTROL_1080P_24,
+		.avid_start_msb = AVID_START_PIXEL_MSB_1080P_24,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_1080P_24,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080P_24,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080P_24,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080P_24,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080P_24,
+		.vblk_f0_duration = VBLK_F0_DURATION_1080P_24,
+		.vblk_f1_duration = 0,
+		.clamp_start = ADV9880_HD_CLAMP_START,
+		.clamp_width = ADV9880_HD_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_HD_PRE_COAST,
+		.hpll_post_coast = ADV9880_HD_POST_COAST,
+		.reserved = RESERVED_1080P,
+                .screen_height_msb = 0x04,
+                .screen_height_lsb = 0x38,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_480P,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_480P,
+		.hpll_vco_control = VCO_CONTROL_480P,
+		.hpll_cp_current = CP_CURRENT_480P,
+		.hpll_phase_select = PHASE_SELECT_480P,
+		.hpll_control = HPLL_CONTROL_480P,
+		.avid_start_msb = AVID_START_PIXEL_MSB_480P,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_480P,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_480P,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_480P,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_480P,
+		.vblk_start_f1_line_offset = 0,//VBLK_F1_START_LINE_OFFSET_480P,
+		.vblk_f0_duration = VBLK_F0_DURATION_480P,
+		.vblk_f1_duration = 0,//VBLK_F1_DURATION_480P,
+		.clamp_start = ADV9880_ED_CLAMP_START,
+		.clamp_width = ADV9880_ED_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_ED_PRE_COAST,
+		.hpll_post_coast = ADV9880_ED_POST_COAST,
+		.reserved = RESERVED_720p,
+                .screen_height_msb = 0x02,
+                .screen_height_lsb = 0x0c,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_576P,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_576P,
+		.hpll_vco_control = VCO_CONTROL_576P,
+		.hpll_cp_current = CP_CURRENT_576P,
+		.hpll_phase_select = PHASE_SELECT_576P,
+		.hpll_control = HPLL_CONTROL_576P,
+		.avid_start_msb = AVID_START_PIXEL_MSB_576P,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_576P,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_576P,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_576P,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_576P,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_576P,
+		.vblk_f0_duration = VBLK_F0_DURATION_576P,
+		.vblk_f1_duration = 0,//VBLK_F1_DURATION_576P,
+		.clamp_start = ADV9880_ED_CLAMP_START,
+		.clamp_width = ADV9880_ED_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_ED_PRE_COAST,
+		.hpll_post_coast = ADV9880_ED_POST_COAST,
+		.reserved = RESERVED_720p,
+                .screen_height_msb = 0x02,
+                .screen_height_lsb = 0x70,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_NTSC,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_NTSC,
+		.hpll_vco_control = VCO_CONTROL_NTSC,
+		.hpll_cp_current = CP_CURRENT_NTSC,
+		.hpll_phase_select = PHASE_SELECT_NTSC,
+		.hpll_control = HPLL_CONTROL_NTSC,
+		.avid_start_msb = AVID_START_PIXEL_MSB_NTSC,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_NTSC,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_NTSC,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_NTSC,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_NTSC,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_NTSC,
+		.vblk_f0_duration = VBLK_F0_DURATION_NTSC,
+		.vblk_f1_duration = VBLK_F1_DURATION_NTSC,
+		.clamp_start = ADV9880_ED_CLAMP_START,
+		.clamp_width = ADV9880_ED_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_ED_PRE_COAST,
+		.hpll_post_coast = ADV9880_ED_POST_COAST,
+		.reserved = RESERVED_720p,
+                .screen_height_msb = 0x02,
+                .screen_height_lsb = 0x0c,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_PAL,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_PAL,
+		.hpll_vco_control = VCO_CONTROL_PAL,
+		.hpll_cp_current = CP_CURRENT_PAL,
+		.hpll_phase_select = PHASE_SELECT_PAL,
+		.hpll_control = HPLL_CONTROL_PAL,
+		.avid_start_msb = AVID_START_PIXEL_MSB_PAL,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_PAL,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_PAL,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_PAL,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_PAL,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_PAL,
+		.vblk_f0_duration = VBLK_F0_DURATION_PAL,
+		.vblk_f1_duration = VBLK_F1_DURATION_PAL,
+		.clamp_start = ADV9880_ED_CLAMP_START,
+		.clamp_width = ADV9880_ED_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_ED_PRE_COAST,
+		.hpll_post_coast = ADV9880_ED_POST_COAST,
+		.reserved = RESERVED_720p,
+                .screen_height_msb = 0x02,
+                .screen_height_lsb = 0x70,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080P_50,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080P_50,
+		.hpll_vco_control = VCO_CONTROL_1080P_50,
+		.hpll_cp_current = CP_CURRENT_1080P_50,
+		.hpll_phase_select = PHASE_SELECT_1080P_50,
+		.hpll_control = HPLL_CONTROL_1080P_50,
+		.avid_start_msb = AVID_START_PIXEL_MSB_1080P_50,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_1080P_50,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080P_50,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080P_50,
+		.vblk_start_f0_line_offset = VBLK_F0_START_LINE_OFFSET_1080P_50,
+		.vblk_start_f1_line_offset = VBLK_F1_START_LINE_OFFSET_1080P_50,
+		.vblk_f0_duration = VBLK_F0_DURATION_1080P_50,
+		.vblk_f1_duration = 0,//VBLK_F1_DURATION_1080P_50,
+		.clamp_start = ADV9880_HD_CLAMP_START,
+		.clamp_width = ADV9880_HD_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_HD_PRE_COAST,
+		.hpll_post_coast = ADV9880_HD_POST_COAST,
+		.reserved = RESERVED_1080P,
+                .screen_height_msb = 0x04,
+                .screen_height_lsb = 0x38,
+                .sync_filter_control = ADV9880_SYNC_FILTER_CONTROL_DEFAULT,
+				.vsync_duration = ADV9880_VSYNC_DURATION_DEFAULT,
+	},
+	{
+		.hpll_divider_msb = FEEDBACK_DIVIDER_MSB_1080P_60,
+		.hpll_divider_lsb = FEEDBACK_DIVIDER_LSB_1080P_60,
+		.hpll_vco_control = VCO_CONTROL_1080P_60,
+		.hpll_cp_current = CP_CURRENT_1080P_60,
+		.hpll_phase_select = PHASE_SELECT_1080P_60,
+		.hpll_control = HPLL_CONTROL_1080P_60,
+		.avid_start_msb = AVID_START_PIXEL_MSB_1080P_60,
+		.avid_start_lsb = AVID_START_PIXEL_LSB_1080P_60,
+		.avid_stop_lsb = AVID_STOP_PIXEL_LSB_1080P_60,
+		.avid_stop_msb = AVID_STOP_PIXEL_MSB_1080P_60,
+		.vblk_start_f0_line_offset = 45,//VBLK_F0_START_LINE_OFFSET_1080P_60,
+		.vblk_start_f1_line_offset = 0,//VBLK_F1_START_LINE_OFFSET_1080P_60,
+		.vblk_f0_duration = VBLK_F0_DURATION_1080P_60,
+		.vblk_f1_duration = 0,//VBLK_F1_DURATION_1080P_60,
+		.clamp_start = ADV9880_HD_CLAMP_START,
+		.clamp_width = ADV9880_HD_CLAMP_WIDTH,
+		.hpll_pre_coast = ADV9880_HD_PRE_COAST,
+		.hpll_post_coast = ADV9880_HD_POST_COAST,
+		.reserved = RESERVED_1080P,
+                .screen_height_msb = 0x04,
+                .screen_height_lsb = 0x64,
+                .sync_filter_control = 0xdc,	/* Enable VSYNC duration, disable filter */
+				.vsync_duration = 41,
+	},
+};
+
+static struct adv9880_config adv9880_configuration[ADV9880_NUM_CHANNELS] = {
+	{
+		.no_of_inputs = ADV9880_MAX_NO_INPUTS,
+		.input[0] = {
+			.input_type = ADV9880_ANALOG_INPUT,
+			.input_info = {
+				.index = 0,
+				.name = "COMPONENT",
+				.type = V4L2_INPUT_TYPE_CAMERA,
+				.std = V4L2_STD_ADV9880_ALL
+			},
+			.no_of_standard = ADV9880_MAX_NO_STANDARDS,
+			.standard = (struct v4l2_standard *)&adv9880_standards,
+			.def_std = V4L2_STD_720P_60,
+			.format =
+			   (struct adv9880_format_params *)&adv9880_formats,
+			.no_of_controls = ADV9880_MAX_NO_CONTROLS,
+			.controls = NULL
+		},
+		.input[1] = {
+			.input_type = ADV9880_DIGITAL_INPUT,
+			.input_info = {
+				.index = 1,
+				.name = "HDMI",
+				.type = V4L2_INPUT_TYPE_CAMERA,
+				.std = V4L2_STD_ADV9880_ALL
+			},
+			.no_of_standard = ADV9880_MAX_NO_STANDARDS,
+			.standard = (struct v4l2_standard *)&adv9880_standards,
+			.def_std = V4L2_STD_720P_60,
+			.format =
+			   (struct adv9880_format_params *)&adv9880_formats,
+			.no_of_controls = ADV9880_MAX_NO_CONTROLS,
+			.controls = NULL
+		},
+		.def_params = {V4L2_STD_1080P_60, 1,
+				{1, 0xa, 0x6}, {0, 0, 0, 7, 7, 7},
+				{0x80, 0x80, 0x80, 0, 0, 0, 0x10, 0x10, 0x10} }
+	 }
+};
+
+struct adv9880_channel {
+	struct v4l2_subdev    sd;
+        struct work_struct    work;
+        int                   ch_id;
+	struct adv9880_params params;
+};
+
+
+static const struct v4l2_subdev_video_ops adv9880_video_ops = {
+	.querystd = adv9880_querystd,
+	.s_routing = adv9880_s_routing,
+//	.g_input_status = adv9880_g_input_status,
+};
+
+static const struct v4l2_subdev_core_ops adv9880_core_ops = {
+        .g_chip_ident = NULL,
+	.s_std = adv9880_s_std,
+};
+
+static const struct v4l2_subdev_ops adv9880_ops = {
+	.core = &adv9880_core_ops,
+	.video = &adv9880_video_ops,
+};
+
+
+static struct timer_list adv9880_timer;
+static unsigned int adv9880_timeout_ms = 1000;
+
+
+static inline struct adv9880_channel *to_adv9880(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct adv9880_channel, sd);
+}
+
+
+static void adv9880_timer_function(unsigned long data)
+{
+     struct adv9880_channel *channel = (struct adv9880_channel *) data;
+
+     schedule_work(&channel->work);
+     mod_timer( &adv9880_timer, jiffies + msecs_to_jiffies( adv9880_timeout_ms ) );
+}
+
+
+static void adv9880_work(struct work_struct *work)
+{
+     struct adv9880_channel *channel = container_of(work, struct adv9880_channel, work);
+     struct i2c_client *ch_client = v4l2_get_subdevdata(&channel->sd);
+     int ch_id = channel->ch_id;
+     int err;
+     int inputidx;
+     int input_type;
+
+     if (ch_client != NULL ) {
+
+          inputidx = channel->params.inputidx;
+          input_type = adv9880_configuration[ch_id].input[inputidx].input_type;
+
+          if ( input_type == ADV9880_DIGITAL_INPUT ) {
+#if 0
+               unsigned char val;
+
+               err = adv9880_i2c_read_reg(ch_client,
+                                          0x87,
+                                          &val);
+
+               if ( err == 0 && val != 0 ) {
+                    err = adv9880_i2c_write_reg(ch_client,
+                                                0x7f,
+                                                0x00);
+               }
+#else
+               err = adv9880_i2c_write_reg(ch_client,
+                                           0x7f,
+                                           0x00);
+#endif
+          }
+     }
+}
+
+static int adv9880_set_input_mux(unsigned char channel)
+{
+     (void) channel;
+
+     return 0;
+}
+
+/* adv9880_initialize :
+ * This function will set the video format standard
+ */
+static int adv9880_initialize(struct v4l2_subdev *sd)
+{
+	int err = 0;
+	int ch_id;
+	v4l2_std_id std;
+	struct i2c_client *ch_client = NULL;
+	int index;
+        struct adv9880_channel *channel = (to_adv9880(sd));
+
+        ch_id = (to_adv9880(sd))->ch_id;
+	ch_client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&ch_client->dev, "Adv9880 driver registered\n");
+	/*Configure the ADV9880 in default 720p 60 Hz standard for normal
+	   power up mode */
+
+#if defined(CONFIG_DAVINCI_DM368_FPGA)
+        dm368_fpga_vinsel_hdmi();
+#endif
+
+	/* Reset the chip */
+	err |= adv9880_i2c_write_reg(ch_client, ADV9880_POWER_CONTROL,
+				     0xff);
+        if ( 0 == err ) {
+             msleep(10);
+
+             err |= adv9880_i2c_write_reg(ch_client, ADV9880_POWER_CONTROL,
+                                          0x0e);
+
+             msleep(10);
+        }
+
+
+        if ( 0 == err ) {
+             err |= adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_DIVIDER_MSB,
+                                          ADV9880_HPLL_MSB_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |= adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_DIVIDER_LSB,
+                                          ADV9880_HPLL_LSB_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |= adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_CONTROL,
+                                          ADV9880_HPLL_CONTROL_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |= adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_PHASE_SELECT,
+				     ADV9880_HPLL_PHASE_SEL_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |= adv9880_i2c_write_reg(ch_client, ADV9880_CLAMP_START,
+                                          ADV9880_CLAMP_START_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |= adv9880_i2c_write_reg(ch_client, ADV9880_CLAMP_WIDTH,
+                                          ADV9880_CLAMP_WIDTH_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_SYNC_SEPARATER_THLD,
+                                        ADV9880_SYNC_SEP_THLD_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_PRE_COAST,
+                                        ADV9880_HPLL_PRE_COAST_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_POST_COAST,
+                                        ADV9880_HPLL_POST_COAST_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_OUTPUT_MODE_CONTROL,
+                                        ADV9880_OUTPUT_MODE_CONTROL_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_SYNC_FILTER_CONTROL,
+                                        ADV9880_SYNC_FILTER_CONTROL_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_CLAMP_CONTROL,
+                                        ADV9880_CLAMP_CONTROL_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_AUTO_OFFSET_CONTROL,
+                                        ADV9880_AUTO_OFFSET_CONTROL_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_GREEN_OFFSET,
+                                        ADV9880_GREEN_OFFSET_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_MISC_CONTROL_1,
+                                        ADV9880_MISC_CONTROL_1_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_OUTPUT_SYNC_CONTROL,
+                                        ADV9880_OUTPUT_SYNC_CONTROL_DEFAULT);
+        }
+
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_I2S_CONTROL,
+                                        ADV9880_I2S_CONTROL_DEFAULT);
+        }
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_HSYNC_DURATION,
+                                        ADV9880_HSYNC_DURATION_DEFAULT);
+        }
+
+        if ( 0 == err ) {
+             err |=
+                  adv9880_i2c_write_reg(ch_client, ADV9880_INPUT_SELECT,
+                                        ADV9880_INPUT_SELECT_DEFAULT );
+        }
+
+	if (err < 0) {
+		err = -EINVAL;
+		adv9880_deinitialize(sd);
+		return err;
+	} else {
+
+		memcpy(&channel->params,
+		       &adv9880_configuration[ch_id].def_params,
+		       sizeof(struct adv9880_params));
+		/* Configure for default video standard */
+		/* call set standard */
+		index = channel->params.inputidx;
+		std = adv9880_configuration[ch_id].input[index].def_std;
+		err |= adv9880_s_std(sd, std);
+
+		if (err < 0) {
+			err = -EINVAL;
+			adv9880_deinitialize(sd);
+			return err;
+		}
+	}
+
+	dev_dbg(&ch_client->dev, "End of adv9880_init.\n");
+	return err;
+}
+
+static int adv9880_deinitialize(struct v4l2_subdev *sd)
+{
+
+     (void) sd;
+
+     return 0;
+}
+
+
+
+/* adv9880_setstd :
+ * Function to set the video standard
+ */
+static int adv9880_s_std(struct v4l2_subdev *sd, v4l2_std_id std)
+{
+	int err = 0;
+	struct adv9880_format_params *adv9880formats;
+	int ch_id;
+	int i = 0;
+	struct v4l2_standard *standard;
+	int input_idx;
+        int input_type;
+        struct adv9880_channel *channel = to_adv9880(sd);
+        struct i2c_client *ch_client = v4l2_get_subdevdata(sd);
+
+        ch_id = (channel)->ch_id;
+
+	dev_dbg(&ch_client->dev, "Start of adv9880_setstd..\n");
+	input_idx = channel->params.inputidx;
+        input_type = adv9880_configuration[ch_id].input[input_idx].input_type;
+
+	for (i = 0; i < adv9880_configuration[ch_id].input[input_idx].
+	     no_of_standard; i++) {
+		standard = &adv9880_configuration[ch_id].input[input_idx].
+		    standard[i];
+		if (standard->id & std) {
+			break;
+		}
+	}
+	if (i == adv9880_configuration[ch_id].input[input_idx].no_of_standard) {
+		dev_err(&ch_client->dev, "Invalid id...\n");
+		return -EINVAL;
+	}
+
+
+        /* Horizontal alignment of video */
+        switch ( input_type )  {
+        case ADV9880_ANALOG_INPUT:
+#if defined(CONFIG_DAVINCI_DM368_FPGA)
+             /* Set audio path */
+             dm368_fpga_audio_select( DM368_FPGA_AUDIO_TRISTATE );
+#endif
+             /* Disable CSC (assume YPbPr) */
+             dev_dbg(&ch_client->dev, "Disable CSC analog input\n" );
+             err |= adv9880_i2c_write_reg(ch_client,  ADV9880_COLOR_CONVERT_CONTROL, 0x80 );
+
+#if 0
+             /* Flip HSYNC polarity to account for internal video data delay vs. HSYNC */
+
+             switch ( std ) {
+#if 1
+             case V4L2_STD_720P_60:
+             case V4L2_STD_720P_50:
+                  dev_dbg( &ch_client->dev,
+                       "720p adjust analog\n");
+                  adv9880_i2c_write_reg(ch_client,
+                                        ADV9880_OUTPUT_SYNC_CONTROL,
+                                        ADV9880_OUTPUT_SYNC_CONTROL_DEFAULT^ADV9880_OUTPUT_SYNC_CONTROL_HSYNC_POL_MASK);
+
+                  adv9880_i2c_write_reg(ch_client,
+                                        ADV9880_HSYNC_DURATION,
+                                        0x26);
+                  break;
+
+             case V4L2_STD_1080I_60:
+             case V4L2_STD_1080I_50:
+                  dev_dbg( &ch_client->dev,
+                       "1080i adjust analog\n");
+                  adv9880_i2c_write_reg(ch_client,
+                                        ADV9880_OUTPUT_SYNC_CONTROL,
+                                        ADV9880_OUTPUT_SYNC_CONTROL_DEFAULT^ADV9880_OUTPUT_SYNC_CONTROL_HSYNC_POL_MASK);
+
+                  adv9880_i2c_write_reg(ch_client,
+                                        ADV9880_HSYNC_DURATION,
+                                        0x2c);
+                  break;
+#endif
+             default:
+                  adv9880_i2c_write_reg(ch_client,
+                                        ADV9880_OUTPUT_SYNC_CONTROL,
+                                        ADV9880_OUTPUT_SYNC_CONTROL_DEFAULT);
+
+                  adv9880_i2c_write_reg(ch_client,
+                                        ADV9880_HSYNC_DURATION,
+                                        ADV9880_HSYNC_DURATION_DEFAULT);
+                  break;
+             }
+#else
+                  adv9880_i2c_write_reg(ch_client,
+                                        ADV9880_OUTPUT_SYNC_CONTROL,
+                                        ADV9880_OUTPUT_SYNC_CONTROL_DEFAULT);
+
+                  adv9880_i2c_write_reg(ch_client,
+                                        ADV9880_HSYNC_DURATION,
+                                        ADV9880_HSYNC_DURATION_DEFAULT);
+#endif
+             break;
+
+        case ADV9880_DIGITAL_INPUT:
+
+#if defined(CONFIG_DAVINCI_DM368_FPGA)
+             dm368_fpga_audio_select( DM368_FPGA_AUDIO_HDMI );
+#endif
+             err = adv9880_set_hdmi_colorspace(ch_client);
+
+             adv9880_i2c_write_reg(ch_client,
+                                   ADV9880_OUTPUT_SYNC_CONTROL,
+                                   ADV9880_OUTPUT_SYNC_CONTROL_DEFAULT);
+             adv9880_i2c_write_reg(ch_client,
+                                   ADV9880_HSYNC_DURATION,
+                                   ADV9880_HSYNC_DURATION_DEFAULT);
+             break;
+
+        }
+
+	adv9880formats =
+	    &adv9880_configuration[ch_id].input[input_idx].format[i];
+
+	err = adv9880_set_format_params(sd, adv9880formats);
+	if (err < 0) {
+		dev_err(&ch_client->dev, "Set standard failed\n");
+		return err;
+	}
+
+	/* Lock the structure variable and assign std to the member
+	   variable */
+	channel->params.std = std;
+
+	dev_dbg(&ch_client->dev, "End of adv9880 set standard...\n");
+	return err;
+}
+
+#ifdef DEBUG
+static void adv9880_dump_register(struct v4l2_subdev *sd)
+{
+	int i = 0, err;
+	u8 val;
+        struct i2c_client *ch_client = v4l2_get_subdevdata(sd);
+
+	for (i = 0; i <= ADV9880_SCREEN_HEIGHT_LSB; i++) {
+		err = adv9880_i2c_read_reg(ch_client,
+				   i, &val);
+		printk(KERN_NOTICE "reg %x, val = %x, err = %x\n", i, val, err);
+	}
+}
+#endif
+
+int
+adv9880_set_hdmi_colorspace(struct i2c_client *ch_client)
+{
+     int err = 0;
+     unsigned char avinfo1_val=ADV9880_AVI_INFOFRAME_1_CSIN_YCBCR422;
+     unsigned char dvi_hdmi_val=0;
+
+     err = adv9880_i2c_read_reg(ch_client, ADV9880_AVI_INFOFRAME_1, &avinfo1_val );
+
+     if ( err != 0 ) {
+          dev_dbg(&ch_client->dev, "set_hdmi_colorspace: Error reading AVI_INFOFRAME_1\n" );
+
+          return err;
+     }
+
+     err = adv9880_i2c_read_reg(ch_client, ADV9880_HDMI_MODE, &dvi_hdmi_val);
+     if ( err != 0 ) {
+          dev_dbg(&ch_client->dev, "set_hdmi_colorspace: Error reading HDMI_MODE\n" );
+
+          return err;
+     }
+
+     if ( ((avinfo1_val&ADV9880_AVI_INFOFRAME_1_CSIN_MASK) == ADV9880_AVI_INFOFRAME_1_CSIN_RGB)
+          || ((dvi_hdmi_val&ADV9880_HDMI_MODE_DVI_HDMI_MASK) == ADV9880_HDMI_MODE_DVI) ) {
+
+          dev_dbg(&ch_client->dev, "set_hdmi_colorspace: RGB\n" );
+
+          err = adv9880_i2c_write_reg(ch_client,  0x35, 0x07 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x36, 0x06 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x37, 0x19 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x38, 0xa0 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x39, 0x1f );
+          err |= adv9880_i2c_write_reg(ch_client,  0x3a, 0x5b );
+
+          err |= adv9880_i2c_write_reg(ch_client,  0x3b, 0x08 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x3c, 0x00 );
+
+          err |= adv9880_i2c_write_reg(ch_client,  0x3d, 0x02 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x3e, 0xed );
+          err |= adv9880_i2c_write_reg(ch_client,  0x3f, 0x09 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x40, 0xd3 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x41, 0x00 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x42, 0xfd );
+
+          err |= adv9880_i2c_write_reg(ch_client,  0x43, 0x01 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x44, 0x00 );
+
+          err |= adv9880_i2c_write_reg(ch_client,  0x45, 0x1e );
+          err |= adv9880_i2c_write_reg(ch_client,  0x46, 0x64 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x47, 0x1a );
+          err |= adv9880_i2c_write_reg(ch_client,  0x48, 0x96 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x49, 0x07 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x4a, 0x06 );
+
+          err |= adv9880_i2c_write_reg(ch_client,  0x4b, 0x08 );
+          err |= adv9880_i2c_write_reg(ch_client,  0x4c, 0x00 );
+
+          err |= adv9880_i2c_write_reg(ch_client,  ADV9880_COLOR_CONVERT_CONTROL, 0x82 );
+     } else {
+          dev_dbg(&ch_client->dev,
+                  "set_hdmi_colorspace: YPbPr: avinfo_val 0x%x\n",
+                  (unsigned int)avinfo1_val );
+
+          err |= adv9880_i2c_write_reg(ch_client,  ADV9880_COLOR_CONVERT_CONTROL, 0x80 );
+     }
+
+     return err;
+}
+
+/* adv9880_querystd :
+ * Function to return standard detected by decoder
+ */
+static int adv9880_querystd(struct v4l2_subdev *sd, v4l2_std_id *id)
+{
+	int err = 0;
+	unsigned char val;
+	unsigned short val1;
+        unsigned short val2;
+        unsigned char  cea861VidId = 0;
+	int ch_id;
+        int detected = 0;
+        int gotformat = 0;
+        unsigned char sync_status=0;
+        unsigned char hdmi_status=0;
+        int input_type;
+        int inputidx;
+        int formatretries = 4;
+        struct i2c_client *ch_client = v4l2_get_subdevdata(sd);
+        struct adv9880_channel *channel = to_adv9880(sd);
+        unsigned int fps_1000 = 0;
+
+        v4l2_std_id cea861Std = 0;
+
+	dev_dbg(&ch_client->dev, "Starting querystd function...\n");
+	if (id == NULL) {
+		dev_err(&ch_client->dev, "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	msleep(100);
+
+#ifdef DEBUG
+//	adv9880_dump_register(sd);
+#endif
+
+        ch_id = channel->ch_id;
+
+        inputidx = channel->params.inputidx;
+        input_type = adv9880_configuration[ch_id].input[inputidx].input_type;
+        switch (input_type) {
+        case ADV9880_ANALOG_INPUT:
+             /* Query the sync status */
+             err = adv9880_i2c_read_reg(ch_client,
+                                        ADV9880_SYNC_DETECT_2, &sync_status);
+             if (err < 0) {
+                  dev_err(&ch_client->dev,
+                          "I2C read fails...sync detect\n");
+                  return err;
+             }
+
+
+             if ( (sync_status & ADV9880_SYNC_DETECT_2_SYNC_LOCK_MASK) == ADV9880_SYNC_DETECT_2_SYNC_LOCK_MASK ) {
+                  detected = 1;
+             }
+             break;
+
+        case ADV9880_DIGITAL_INPUT:
+        default:
+             /* Query the sync status */
+             err = adv9880_i2c_read_reg(ch_client,
+                                        ADV9880_HDMI_STATUS_1, &hdmi_status);
+             if (err < 0) {
+                  dev_err(&ch_client->dev,
+                          "I2C read fails...hdmi status\n");
+                  return err;
+             }
+
+             if ( (hdmi_status & ADV9880_HDMI_STATUS_1_DE_MASK ) == ADV9880_HDMI_STATUS_1_DE_MASK ) {
+                  detected = 1;
+             }
+             break;
+        }
+
+
+        if ( !detected ) {
+             dev_dbg( &ch_client->dev, "No sync detected\n");
+             return -EIO;
+        }
+
+
+        do {
+             val1 = 0;
+             /* Query the standards */
+             err = adv9880_i2c_read_reg(ch_client,
+                                        ADV9880_LINES_PER_VSYNC_STATUS_HIGH, &val);
+             if (err < 0) {
+                  dev_err(&ch_client->dev,
+                          "I2C read fails...Lines per frame high\n");
+                  return err;
+             }
+
+             val1 |= (val << LINES_PER_VSYNC_MSB_SHIFT) & LINES_PER_VSYNC_MSB_MASK;
+
+             err = adv9880_i2c_read_reg(ch_client,
+                                        ADV9880_LINES_PER_VSYNC_STATUS_LOW, &val);
+             if (err < 0) {
+                  dev_err(&ch_client->dev,
+                          "I2C read fails...Lines per frame low\n");
+                  return err;
+             }
+             val1 |= (val&0xff);
+
+
+             fps_1000 = 0;
+             val2     = 0;
+#if defined(CONFIG_DAVINCI_DM368_FPGA)
+             val2 = dm368_fpga_hdmi_hsync_counter();
+
+             if ( val1 != 0 && val2 != 0 ) {
+                  fps_1000 = 27000000 / val1;
+                  fps_1000 *= 1000;
+                  fps_1000 /= val2;
+             }
+#else
+             if ( input_type == ADV9880_DIGITAL_INPUT ) {
+                  err = adv9880_i2c_read_reg(ch_client,
+                                             ADV9880_AVI_INFOFRAME_VIDEO_ID, &cea861VidId);
+                  if ( err < 0) {
+                       dev_err( &ch_client->dev,
+                                "I2C read fails...AVI Infoframe video ID\n" );
+                       return err;
+                  }
+
+                  cea861VidId &= 0x7F; // only bits 6:0 are valid
+
+                  cea861Std = cea861_stds[cea861VidId];
+                  fps_1000  = cea861_fps_1000[cea861VidId];
+
+                  if ( fps_1000 == 0 ) {
+                       fps_1000 = 60000;
+                  }
+
+                  if (fps_1000 != 0 && val1 != 0 )
+                       val2 = ((27000000/val1)*1000)/fps_1000;
+             }
+
+
+#endif
+
+             if ( ADV9880_LINES_1080P_LOWER <= val1
+                  && val1 <= ADV9880_LINES_1080P_UPPER  ) {
+
+                  if ( fps_1000 >= 24800 && fps_1000 <= 25200 ) {
+                       *id = V4L2_STD_1080P_25;
+                       gotformat = 1;
+                  }
+                  else if ( (fps_1000 >= 29700 && fps_1000 <= 30300) ) {
+                       *id = V4L2_STD_1080P_30;
+                       gotformat = 1;
+                  }
+                  else if ( fps_1000 >= 49500 && fps_1000 <= 50500 ) {
+                       *id = V4L2_STD_1080P_50;
+                       gotformat = 1;
+                  }
+                  else if ( fps_1000 >= 59400 && fps_1000 <= 60600 ) {
+                       *id = V4L2_STD_1080P_60;
+                       gotformat = 1;
+                  }
+                  else if ( fps_1000 >= 23700 && fps_1000 <= 24300 ) {
+                       *id = V4L2_STD_1080P_24;
+                       gotformat = 1;
+                  }
+             }
+             if ( ADV9880_LINES_1080I_60_LOWER <= val1
+                  && val1 <= ADV9880_LINES_1080I_60_UPPER
+                  ) {
+
+                  if ( 0 == val2 || (0x310 <= val2 && val2 <= 0x330) ) {
+                       *id = V4L2_STD_1080I_60;
+                       gotformat = 1;
+                  } else if ( 0x3b0 <= val2 && val2 <= 0x3d0 )  {
+                       *id = V4L2_STD_1080I_50;
+                       gotformat = 1;
+                  }
+             }
+             else if (ADV9880_LINES_720_LOWER <= val1 &&
+                      val1 <= ADV9880_LINES_720_UPPER) {
+
+                  if ( 0 == val2 || (0x248 <= val2 && val2 <= 0x268) ) {
+                       *id = V4L2_STD_720P_60;
+                       gotformat = 1;
+                  }
+                  else if ( (0x2c0 <= val2) && (val2 <= 0x2e0) ) {
+                       *id = V4L2_STD_720P_50;
+                       gotformat = 1;
+                  }
+             }
+             else if ((524 == val1) || (525 == val1)) { // VESA mode has one less line
+                  *id = V4L2_STD_525P_60;
+                  gotformat = 1;
+             }
+             else if ((624==val1)||(625 == val1)) {
+                  *id = V4L2_STD_625P_50;
+                  gotformat = 1;
+             }
+             else if ((262==val1) || (263==val1)) {
+                  *id = V4L2_STD_525_60;
+                  gotformat = 1;
+             }
+             else if ((312==val1) || (313==val1)) {
+                  *id = V4L2_STD_625_50;
+                  gotformat = 1;
+             }
+
+
+             if ( !gotformat ) {
+                  /* VSYNC ctr may take some time to converge */
+                  msleep(50);
+             }
+
+        } while ( gotformat == 0 && --formatretries > 0 ) ;
+
+	dev_notice(&ch_client->dev,
+		   "ADV9880 - lines per frame detected = %d 27mhz clocks per line = %d fps=%u.%03u\n", (int)val1, (int)val2, fps_1000/1000, fps_1000%1000);
+
+        if ( !gotformat ) {
+		dev_notice(&ch_client->dev,
+			"querystd, error, val = %x, lpf = %x, clkperline = %x\n", val, (int)val1, val2);
+                return -EINVAL;
+	}
+
+	if ( V4L2_STD_720P_60 == *id )
+	  {
+	    if ( val1  == ADV9880_LINES_720_UPPER)
+	      {
+		//printk ( KERN_ERR "STANDARD 720P\n" );
+		adv9880_formats[0].avid_start_lsb = AVID_START_PIXEL_LSB_720p;
+		adv9880_formats[0].avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p;
+
+		adv9880_formats[0].clamp_start = ADV9880_HD_CLAMP_START;
+		adv9880_formats[0].clamp_width = ADV9880_HD_CLAMP_WIDTH;
+		adv9880_formats[0].hpll_pre_coast = ADV9880_HD_PRE_COAST;
+		adv9880_formats[0].hpll_post_coast = ADV9880_HD_POST_COAST;
+	      }
+	    else
+	      {
+		//printk ( KERN_ERR "VESA 720P\n" );
+
+		/* VESA uses bi-level sync, so low pulse is twice as long */
+		adv9880_formats[0].avid_start_lsb = AVID_START_PIXEL_LSB_720p - 44;
+		adv9880_formats[0].avid_stop_lsb = AVID_STOP_PIXEL_LSB_720p - 44;
+
+		/* VESA uses bi-level sync, so set up as for ED (bi-level) syncs */
+		adv9880_formats[0].clamp_start = ADV9880_ED_CLAMP_START;
+		adv9880_formats[0].clamp_width = ADV9880_ED_CLAMP_WIDTH;
+		adv9880_formats[0].hpll_pre_coast = ADV9880_ED_PRE_COAST;
+		adv9880_formats[0].hpll_post_coast = ADV9880_ED_POST_COAST;
+	      }
+	  }
+
+	channel->params.std = *id;
+//	err = adv9880_setstd(id, dec);
+	dev_dbg(&ch_client->dev, "End of querystd function.\n");
+	return err;
+}
+
+
+/**
+ * adv9880_s_routing() - V4L2 decoder interface handler for s_routing
+ * @sd: pointer to standard V4L2 sub-device structure
+ * @input: input selector for routing the signal
+ * @output: output selector for routing the signal
+ * @config: config value. Not used
+ *
+ * If index is valid, selects the requested input. Otherwise, returns -EINVAL if
+ * the input is not supported
+ */
+static int adv9880_s_routing(struct v4l2_subdev *sd,
+                             u32 input, u32 output, u32 config)
+{
+     struct i2c_client *ch_client = v4l2_get_subdevdata(sd);
+     struct adv9880_channel *channel = to_adv9880(sd);
+     int err = 0;
+     int ch_id = channel->ch_id;
+     u8 input_sel;
+     u8 input_sel_current;
+     u8 input_sel_new;
+
+     dev_dbg(&ch_client->dev, "Start of s_routing function.\n");
+
+     input_sel = adv9880_configuration[ch_id].input[input].input_type;
+
+
+     err = adv9880_i2c_read_reg(ch_client,
+                                ADV9880_INPUT_SELECT,
+                                &input_sel_current);
+     if ( 0 != ((input_sel ^ input_sel_current) & ADV9880_INPUT_SELECT_INTERFACE_MASK) ) {
+
+          input_sel_new = input_sel_current & ~ADV9880_INPUT_SELECT_INTERFACE_MASK;
+          input_sel_new |= (input_sel & ADV9880_INPUT_SELECT_INTERFACE_MASK);
+          input_sel_new |= ADV9880_INPUT_SELECT_MANUAL_MASK;
+          adv9880_i2c_write_reg(ch_client,
+                                ADV9880_INPUT_SELECT,
+                                input_sel_new );
+
+          /* Wait for sync */
+          msleep( 50 );
+     }
+
+     channel->params.inputidx = input;
+
+out:
+
+     dev_dbg(&ch_client->dev, "End of set input function.\n");
+     return err;
+
+}
+
+
+
+/* adv9880_enumstd : Function to enumerate standards supported
+ */
+/* static int adv9880_enumstd(struct v4l2_standard *std, void *dec) */
+/* { */
+/* 	int index, index1; */
+/* 	int err = 0; */
+/* 	int ch_id; */
+/* 	int input_idx, sumstd = 0; */
+/* 	if (NULL == dec) { */
+/* 		printk(KERN_ERR "NULL Pointer\n"); */
+/* 		return -EINVAL; */
+/* 	} */
+/* 	ch_id = ((struct decoder_device *)dec)->channel_id; */
+/* 	if (std == NULL) { */
+/* 		dev_err(&ch_client->dev, "NULL Pointer.\n"); */
+/* 		return -EINVAL; */
+/* 	} */
+/* 	index = std->index; */
+/* 	index1 = index; */
+/* 	/\* Check for valid value of index *\/ */
+/* 	for (input_idx = 0; */
+/* 	     input_idx < adv9880_configuration[ch_id].no_of_inputs; */
+/* 	     input_idx++) { */
+/* 		sumstd += adv9880_configuration[ch_id].input[input_idx] */
+/* 		    .no_of_standard; */
+/* 		if (index < sumstd) { */
+/* 			sumstd -= adv9880_configuration[ch_id] */
+/* 			    .input[input_idx].no_of_standard; */
+/* 			break; */
+/* 		} */
+/* 	} */
+/* 	if (input_idx == adv9880_configuration[ch_id].no_of_inputs) */
+/* 		return -EINVAL; */
+/* 	index -= sumstd; */
+
+/* 	memset(std, 0, sizeof(*std)); */
+
+/* 	memcpy(std, &adv9880_configuration[ch_id].input[input_idx]. */
+/* 	       standard[index], sizeof(struct v4l2_standard)); */
+/* 	std->index = index1; */
+/* 	return err; */
+/* } */
+
+/* adv9880_setinput :
+ * Function to set the input
+ */
+/* static int adv9880_setinput(int *index, void *dec) */
+/* { */
+/* 	int err = 0; */
+/* 	int ch_id; */
+/*         u8 input_sel; */
+/*         u8 input_sel_current; */
+/*         u8 input_sel_new; */
+
+/* 	if (NULL == dec) { */
+/* 		printk(KERN_ERR "NULL Pointer\n"); */
+/* 		return -EINVAL; */
+/* 	} */
+/* 	ch_id = ((struct decoder_device *)dec)->channel_id; */
+/* 	dev_dbg(&ch_client->dev, "Start of set input function.\n"); */
+
+/* 	/\* check for null pointer *\/ */
+/* 	if (index == NULL) { */
+/* 		dev_err(&ch_client->dev, "NULL Pointer.\n"); */
+/* 		return -EINVAL; */
+/* 	} */
+/* 	if ((*index >= adv9880_configuration[ch_id].no_of_inputs) */
+/* 	    || (*index < 0)) { */
+/* 		return -EINVAL; */
+/* 	} */
+
+
+/*         input_sel = adv9880_configuration[ch_id].input[*index].input_type; */
+
+
+/*         err = adv9880_i2c_read_reg(ch_client, */
+/*                                    ADV9880_INPUT_SELECT, */
+/*                                    &input_sel_current); */
+/*         if ( 0 != ((input_sel ^ input_sel_current) & ADV9880_INPUT_SELECT_INTERFACE_MASK) ) { */
+
+/*              input_sel_new = input_sel_current & ~ADV9880_INPUT_SELECT_INTERFACE_MASK; */
+/*              input_sel_new |= (input_sel & ADV9880_INPUT_SELECT_INTERFACE_MASK); */
+/*              input_sel_new |= ADV9880_INPUT_SELECT_MANUAL_MASK; */
+/*              adv9880_i2c_write_reg(ch_client, */
+/*                                    ADV9880_INPUT_SELECT, */
+/*                                    input_sel_new ); */
+
+/*              /\* Wait for sync *\/ */
+/*              msleep( 50 ); */
+/*         } */
+
+/*         channel->params.inputidx = *index; */
+
+/* 	dev_dbg(&ch_client->dev, "End of set input function.\n"); */
+/* 	return err; */
+/* } */
+
+/* adv9880_getinput : Function to get the input
+ */
+/* static int adv9880_getinput(int *index, void *dec) */
+/* { */
+/* 	int err = 0; */
+/* 	int ch_id; */
+/* 	v4l2_std_id id; */
+/* 	if (NULL == dec) { */
+/* 		printk(KERN_ERR "NULL Pointer\n"); */
+/* 		return -EINVAL; */
+/* 	} */
+/* 	ch_id = ((struct decoder_device *)dec)->channel_id; */
+/* 	dev_dbg(&ch_client->dev, "Start of get input function.\n"); */
+
+/* 	/\* check for null pointer *\/ */
+/* 	if (index == NULL) { */
+/* 		dev_err(&ch_client->dev, "NULL Pointer.\n"); */
+/* 		return -EINVAL; */
+/* 	} */
+/* 	err |= adv9880_querystd(&id, dec); */
+/* 	if (err < 0) { */
+/* 		return err; */
+/* 	} */
+/* 	*index = 0; */
+/* 	*index = channel->params.inputidx; */
+/* 	dev_dbg(&ch_client->dev, "End of get input function.\n"); */
+/* 	return err; */
+/* } */
+
+/* adv9880_enuminput :
+ * Function to enumerate the input
+ */
+/* static int adv9880_enuminput(struct v4l2_input *input, void *dec) */
+/* { */
+/* 	int err = 0; */
+/* 	int index = 0; */
+/* 	int ch_id; */
+/* 	if (NULL == dec) { */
+/* 		printk(KERN_ERR "NULL Pointer.\n"); */
+/* 		return -EINVAL; */
+/* 	} */
+/* 	ch_id = ((struct decoder_device *)dec)->channel_id; */
+
+/* 	/\* check for null pointer *\/ */
+/* 	if (input == NULL) { */
+/* 		dev_err(&ch_client->dev, "NULL Pointer.\n"); */
+/* 		return -EINVAL; */
+/* 	} */
+
+/* 	/\* Only one input is available *\/ */
+/* 	if (input->index >= adv9880_configuration[ch_id].no_of_inputs) { */
+/* 		return -EINVAL; */
+/* 	} */
+/* 	index = input->index; */
+/* 	memset(input, 0, sizeof(*input)); */
+/* 	input->index = index; */
+/* 	memcpy(input, */
+/* 	       &adv9880_configuration[ch_id].input[index].input_info, */
+/* 	       sizeof(struct v4l2_input)); */
+/* 	return err; */
+/* } */
+
+/* adv9880_set_format_params :
+ * Function to set the format parameters
+ */
+static int adv9880_set_format_params(struct v4l2_subdev *sd, struct adv9880_format_params *tvpformats)
+{
+	int err = 0;
+	unsigned char val;
+	int ch_id;
+        u8 vs_delay_reg;
+        u16 line_start, line_end, line_width;
+	struct i2c_client *ch_client = NULL;
+        struct adv9880_channel *channel = (to_adv9880(sd));
+        unsigned char vs_start;
+
+	ch_client = v4l2_get_subdevdata(sd);
+
+	ch_id = channel->ch_id;
+
+	dev_dbg(&ch_client->dev,
+		"Adv9880 set format params started...\n");
+	if (tvpformats == NULL) {
+		dev_err(&ch_client->dev, "NULL Pointer.\n");
+		return -EINVAL;
+	}
+
+	/* Write the HPLL related registers */
+	err = adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_DIVIDER_MSB,
+				    tvpformats->hpll_divider_msb);
+	if (err < 0) {
+		dev_err(&ch_client->dev,
+			"I2C write fails...Divider MSB\n");
+		return err;
+	}
+
+	val = ((tvpformats->
+		hpll_divider_lsb & HPLL_DIVIDER_LSB_MASK) <<
+	       HPLL_DIVIDER_LSB_SHIFT);
+	err =
+	    adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_DIVIDER_LSB, val);
+	if (err < 0) {
+		dev_err(&ch_client->dev,
+			"I2C write fails...Divider LSB.\n");
+		return err;
+	}
+
+	err = adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_CONTROL,
+				    tvpformats->hpll_control);
+	err = adv9880_i2c_write_reg(ch_client, ADV9880_CLAMP_START,
+				    tvpformats->clamp_start);
+	err = adv9880_i2c_write_reg(ch_client, ADV9880_CLAMP_WIDTH,
+				    tvpformats->clamp_width);
+	err = adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_PRE_COAST,
+				    tvpformats->hpll_pre_coast);
+	err = adv9880_i2c_write_reg(ch_client, ADV9880_HPLL_POST_COAST,
+				    tvpformats->hpll_post_coast);
+
+        /* Set BT.656 size parameters */
+        vs_start = tvpformats->vblk_start_f0_line_offset + tvpformats->vblk_f0_duration;
+
+        vs_delay_reg = ((vs_start)&0x3f)<<2;
+        vs_delay_reg |= (tvpformats->avid_start_msb & 0x3);
+
+	err = adv9880_i2c_write_reg(ch_client, ADV9880_VS_DELAY,
+				    vs_delay_reg);
+
+        err = adv9880_i2c_write_reg(ch_client, ADV9880_HS_DELAY,
+				    (tvpformats->avid_start_lsb & 0xfe));
+
+        line_start = tvpformats->avid_start_msb;
+        line_start <<= 8;
+        line_start |= tvpformats->avid_start_lsb;
+
+        line_end = tvpformats->avid_stop_msb;
+        line_end <<= 8;
+        line_end |= tvpformats->avid_stop_lsb;
+
+        line_width = (line_end-line_start)-4;
+
+        if ( tvpformats->vblk_f1_duration != 0 ) {
+             err = adv9880_i2c_write_reg(ch_client, ADV9880_MISC_CONTROL_1,
+                                         ADV9880_MISC_CONTROL_1_DEFAULT | 0x00 /* Netra ACTVID does not like =1 ??*/ );
+        } else {
+             err = adv9880_i2c_write_reg(ch_client, ADV9880_MISC_CONTROL_1,
+                                         ADV9880_MISC_CONTROL_1_DEFAULT | 0x00  );
+        }
+
+        err = adv9880_i2c_write_reg(ch_client, ADV9880_LINE_WIDTH_MSB,
+				    (line_width>>8)&0xf );
+
+        err = adv9880_i2c_write_reg(ch_client, ADV9880_LINE_WIDTH_LSB,
+				    (line_width)&0xff );
+
+        err = adv9880_i2c_write_reg(ch_client, ADV9880_SCREEN_HEIGHT_MSB,
+				    tvpformats->screen_height_msb );
+
+        err = adv9880_i2c_write_reg(ch_client, ADV9880_SCREEN_HEIGHT_LSB,
+				    tvpformats->screen_height_lsb );
+
+        err = adv9880_i2c_write_reg(ch_client, ADV9880_SYNC_FILTER_CONTROL,
+				    tvpformats->sync_filter_control );
+
+        err = adv9880_i2c_write_reg(ch_client, ADV9880_VSYNC_DURATION,
+				    tvpformats->vsync_duration );
+
+
+	channel->params.format = *tvpformats;
+
+	dev_dbg(&ch_client->dev,
+		"End of adv9880 set format params...\n");
+	return err;
+}
+
+
+/* adv9880_i2c_read_reg :This function is used to read value from register
+ * for i2c client.
+ */
+static int adv9880_i2c_read_reg(struct i2c_client *client, u8 reg, u8 * val)
+{
+	int err = 0;
+        int retries = 5;
+
+	struct i2c_msg msg[2];
+	unsigned char writedata[1];
+	unsigned char readdata[1];
+
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+
+             do {
+		msg[0].addr = client->addr;
+		msg[0].flags = 0;
+		msg[0].len = 1;
+		msg[0].buf = writedata;
+		writedata[0] = reg;
+
+		msg[1].addr = client->addr;
+		msg[1].flags = I2C_M_RD;
+		msg[1].len = 1;
+		msg[1].buf = readdata;
+
+		err = i2c_transfer(client->adapter, msg, 2);
+                if (err >= 2) {
+                     *val = readdata[0];
+		}
+             } while ( err < 2 && --retries > 0);
+	}
+        if ( err < 0 ) {
+             dev_err( &client->adapter->dev, "ADV9880: read x%02x failed\n", reg );
+        } else {
+             dev_dbg( &client->adapter->dev, "ADV9880: read x%02x val %02x\n", (int)reg, (int)(*val) );
+        }
+
+	return ((err < 0) ? err : 0);
+}
+
+/* adv9880_i2c_write_reg :This function is used to write value into register
+ * for i2c client.
+ */
+static int adv9880_i2c_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err = 0;
+
+        int retries = 3;
+
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+	if (!client->adapter) {
+		err = -ENODEV;
+	} else {
+
+
+             do {
+		msg->addr = client->addr;
+		msg->flags = 0;
+		msg->len = 2;
+		msg->buf = data;
+		data[0] = reg;
+		data[1] = val;
+		err = i2c_transfer(client->adapter, msg, 1);
+                if ( err < 0 ) {
+                     msleep(10);
+                }
+             } while ( err < 0 && --retries > 0);
+	}
+
+        if ( err < 0
+             && client->adapter != NULL ) {
+             dev_err( &client->adapter->dev,
+                      "adv9880 i2c write failed: reg x%02x value x%02x\n",
+                      (unsigned int)reg,
+                      (unsigned int)val
+                  );
+        }
+        dev_dbg( &client->adapter->dev,"ADV9880: write x%02x val %02x\n", (int)reg, (int)val );
+
+	return ((err < 0) ? err : 0);
+}
+
+
+/****************************************************************************
+			I2C Client & Driver
+ ****************************************************************************/
+
+static int adv9880_probe(struct i2c_client *c,
+			 const struct i2c_device_id *id)
+{
+	struct adv9880_channel *core;
+	struct v4l2_subdev *sd;
+        int ret;
+
+	/* Check if the adapter supports the needed features */
+	if (!i2c_check_functionality(c->adapter,
+	     I2C_FUNC_SMBUS_READ_BYTE | I2C_FUNC_SMBUS_WRITE_BYTE_DATA))
+		return -EIO;
+
+	core = kzalloc(sizeof(struct adv9880_channel), GFP_KERNEL);
+	if (!core) {
+		return -ENOMEM;
+	}
+
+        core->params.inputidx = 1; //digital
+        core->params.std = adv9880_configuration[0].input[core->params.inputidx].def_std;
+
+	sd = &core->sd;
+	v4l2_i2c_subdev_init(sd, c, &adv9880_ops);
+	v4l_info(c, "chip found @ 0x%02x (%s)\n",
+		 c->addr << 1, c->adapter->name);
+
+	INIT_WORK(&core->work, adv9880_work);
+
+        ret = adv9880_initialize(sd);
+        if ( ret != 0 ) {
+             v4l_err(c, "adv9880 init failed, code %d\n", ret );
+             return ret;
+        }
+
+#if 0
+        if ( adv9880_timer.function == NULL ) {
+             init_timer(&adv9880_timer);
+             adv9880_timer.function = adv9880_timer_function;
+             adv9880_timer.data     = core;
+        }
+        mod_timer( &adv9880_timer, jiffies + msecs_to_jiffies( adv9880_timeout_ms ) );
+#endif
+
+	return ret;
+}
+
+static int adv9880_remove(struct i2c_client *c)
+{
+	struct v4l2_subdev *sd = i2c_get_clientdata(c);
+
+#ifdef DEBUG
+ 	v4l_info(c,
+		"adv9880.c: removing adv9880 adapter on address 0x%x\n",
+		c->addr << 1);
+#endif
+        del_timer_sync( &adv9880_timer );
+
+	v4l2_device_unregister_subdev(sd);
+//	kfree(to_adv9880(sd));
+	return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+
+static const struct i2c_device_id adv9880_id[] = {
+	{ "adv9880", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, adv9880_id);
+
+static struct i2c_driver adv9880_driver = {
+	.driver = {
+		.owner	= THIS_MODULE,
+		.name	= "adv9880",
+	},
+	.probe		= adv9880_probe,
+	.remove		= adv9880_remove,
+	.id_table	= adv9880_id,
+};
+
+static __init int init_adv9880(void)
+{
+	return i2c_add_driver(&adv9880_driver);
+}
+
+static __exit void exit_adv9880(void)
+{
+	i2c_del_driver(&adv9880_driver);
+}
+
+module_init(init_adv9880);
+module_exit(exit_adv9880);
+
+MODULE_DESCRIPTION("Analog Devices AD9880 video decoder driver");
+MODULE_AUTHOR("John Whittington");
+MODULE_LICENSE("GPL");
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/adv9880.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/adv9880.h	2012-09-23 16:05:57.000322027 -0600
@@ -0,0 +1,594 @@
+/*
+ * Copyright (C) 2007-2009 Texas Instruments Inc
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#ifndef _ADV9880_H_
+#define _ADV9880_H_
+
+#ifdef __KERNEL__
+#include <linux/i2c.h>
+#include <linux/device.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#endif				/* __KERNEL__ */
+
+#include <media/davinci/videohd.h> // For HD std (V4L2_STD_1080I, etc)
+
+#define V4L2_STD_ADV9880_ALL        (V4L2_STD_720P_60 | \
+					V4L2_STD_720P_50 | \
+					V4L2_STD_1080I_60 | \
+					V4L2_STD_1080I_50 | \
+					V4L2_STD_1080P_24 | \
+					V4L2_STD_1080P_25 | \
+					V4L2_STD_1080P_30 | \
+					V4L2_STD_1080P_50 | \
+					V4L2_STD_1080P_60 | \
+					V4L2_STD_525P_60 | \
+					V4L2_STD_625P_50 | \
+                                        V4L2_STD_525_60 | \
+                                        V4L2_STD_625_50 \
+				    )
+
+/* enum */
+enum adv9880_mode {
+	ADV9880_MODE_480i_30FPS = 0,
+	ADV9880_MODE_576i_25FPS,
+	ADV9880_MODE_480p_30FPS,
+	ADV9880_MODE_576p_25FPS,
+	ADV9880_MODE_720p_30FPS,
+	ADV9880_MODE_1080i_30FPS,
+	ADV9880_MODE_1080p_30FPS,
+	ADV9880_MODE_1080i_25FPS
+};
+
+enum adv9880_vco_gain {
+	VCO_GAIN_ULTRA_LOW = 0,
+	VCO_GAIN_LOW,
+	VCO_GAIN_MEDIUM,
+	VCO_GAIN_HIGH
+};
+
+enum adv9880_cp_current {
+	CP_CURRENT_SMALL,
+	CP_CURRENT_DEFAULT,
+	CP_CURRENT_LARGE
+};
+
+/*structures*/
+
+struct adv9880_format_params {
+	unsigned char hpll_divider_msb;
+	unsigned char hpll_divider_lsb;
+	enum adv9880_vco_gain hpll_vco_control;
+	enum adv9880_cp_current hpll_cp_current;
+	unsigned char hpll_phase_select;
+//	enum adv9880_post_divider hpll_post_divider;
+	unsigned char hpll_control;
+
+	unsigned char avid_start_msb;
+	unsigned char avid_start_lsb;
+	unsigned char avid_stop_msb;
+	unsigned char avid_stop_lsb;
+	unsigned char vblk_start_f0_line_offset;
+	unsigned char vblk_start_f1_line_offset;
+	unsigned char vblk_f0_duration;
+	unsigned char vblk_f1_duration;
+
+	unsigned char clamp_start, clamp_width;
+	unsigned char hpll_pre_coast;
+	unsigned char hpll_post_coast;
+	unsigned char reserved;
+
+        unsigned char screen_height_msb;
+        unsigned char screen_height_lsb;
+        unsigned char sync_filter_control;
+        unsigned char vsync_duration;
+};
+
+struct adv9880_offset {
+	unsigned char blue_fine_offset;
+	unsigned char green_fine_offset;
+	unsigned char red_fine_offset;
+	unsigned char blue_fine_offset_lsb;
+	unsigned char green_fine_offset_lsb;
+	unsigned char red_fine_offset_lsb;
+	unsigned char blue_coarse_offset;
+	unsigned char green_coarse_offset;
+	unsigned char red_coarse_offset;
+};
+
+struct adv9880_gain {
+	unsigned char blue_fine_gain;
+	unsigned char green_fine_gain;
+	unsigned char red_fine_gain;
+	unsigned char blue_coarse_gain;
+	unsigned char green_coarse_gain;
+	unsigned char red_coarse_gain;
+};
+
+struct adv9880_params {
+	v4l2_std_id std;
+	int inputidx;
+	struct adv9880_gain gain;
+	struct adv9880_offset offset;
+	struct adv9880_format_params format;
+};
+
+#ifdef __KERNEL__
+
+#define ADV9880_NUM_CHANNELS                    1
+
+/* Macros */
+#define ADV9880_LINES_720_LOWER       0x2Ea
+#define ADV9880_LINES_720_UPPER       0x2EE
+
+#define ADV9880_LINES_1080P_LOWER   0x462
+#define ADV9880_LINES_1080P_UPPER   0x465
+
+#define ADV9880_LINES_1080I_60_LOWER   0x232
+#define ADV9880_LINES_1080I_60_UPPER   0x233
+
+#define GENERATE_MASK(bits, pos) ((((0xFFFFFFFF) << (32-bits)) >> \
+		(32-bits)) << pos)
+
+/* Defines for input supported */
+#define ADV9880_ANALOG_INPUT			ADV9880_INPUT_SELECT_ANALOG
+#define ADV9880_DIGITAL_INPUT			ADV9880_INPUT_SELECT_DIGITAL
+
+/* Macros for default register values */
+
+#define ADV9880_HPLL_MSB_DEFAULT                0x89
+#define ADV9880_HPLL_LSB_DEFAULT                0x80
+#define ADV9880_HPLL_CONTROL_DEFAULT            0xA0
+#define ADV9880_HPLL_PHASE_SEL_DEFAULT          0x80
+#define ADV9880_CLAMP_START_DEFAULT             0x32
+#define ADV9880_CLAMP_WIDTH_DEFAULT             0x20
+#define ADV9880_SYNC_SEP_THLD_DEFAULT           0x20
+#define ADV9880_HPLL_PRE_COAST_DEFAULT          0x01
+#define ADV9880_HPLL_POST_COAST_DEFAULT         0x00
+
+
+#define ADV9880_OUTPUT_MODE_CONTROL_DEFAULT     0x76 /* 4:2:2, primary output enabled, secondary output disabled,
+                                                        high drive strength, 1x CLK */
+
+#define ADV9880_SYNC_FILTER_CONTROL_DEFAULT     0xec /* Enable HSYNC filter and VSYNC filter */
+#define ADV9880_SYNC_FILTER_CONTROL_VSYNC_DURATION	0x10;
+
+
+#define	ADV9880_VSYNC_DURATION_DEFAULT			0x4	/* Default VSYNC duration */
+
+#define ADV9880_CLAMP_CONTROL_DEFAULT           0xa2 /* Pr and Pb mid-level clamp */
+
+#define ADV9880_AUTO_OFFSET_CONTROL_DEFAULT     0xCE /* Enable auto-offset control */
+
+#define ADV9880_GREEN_OFFSET_DEFAULT            0x04 /* Auto-offset target for luminance */
+
+#define ADV9880_MISC_CONTROL_1_DEFAULT          0x88 /* BT.656 disabled */
+//#define ADV9880_MISC_CONTROL_1_DEFAULT          0x98 /* BT.656 enabled */
+
+//#define ADV9880_I2S_CONTROL_DEFAULT             0x10 /* I2S mode */
+#define ADV9880_I2S_CONTROL_DEFAULT             0x30 /* right-justified mode */
+//#define ADV9880_I2S_CONTROL_DEFAULT             0x50 /* left-justified mode */
+
+//#define ADV9880_OUTPUT_SYNC_CONTROL_DEFAULT     0xee /* Hsync active high, Vsync active high, field ID active*/
+//#define ADV9880_OUTPUT_SYNC_CONTROL_DEFAULT     0x3e /* Hsync active low, Vsync active low, field ID active high, DE active high, clock not inverted */
+#define ADV9880_OUTPUT_SYNC_CONTROL_DEFAULT     0x3f /* Hsync active low, Vsync active low, field ID active high, DE active high, clock inverted */
+
+#define ADV9880_INPUT_SELECT_DEFAULT            0x03 /* Manual select, HDMI */
+
+#define ADV9880_HSYNC_DURATION_DEFAULT          0x30 /* Allow polarity switch to account for component input delay */
+
+/* Macros for horizontal PLL */
+#define FEEDBACK_DIVIDER_MSB_720p               0x67
+#define FEEDBACK_DIVIDER_LSB_720p               0x02
+#define VCO_CONTROL_720p                        0x02
+#define CP_CURRENT_720p                         0x04
+#define PHASE_SELECT_720p                       0x16
+#define HPLL_CONTROL_720p			0xA0
+#define AVID_START_PIXEL_LSB_720p		0x04
+#define AVID_START_PIXEL_MSB_720p		0x01
+#define AVID_STOP_PIXEL_LSB_720p		0x08
+#define AVID_STOP_PIXEL_MSB_720p		0x06
+#define VBLK_F0_START_LINE_OFFSET_720p		0x05
+#define VBLK_F1_START_LINE_OFFSET_720p		0x00
+#define VBLK_F0_DURATION_720p			0x2D
+#define VBLK_F1_DURATION_720p			0x00
+#define RESERVED_720p				0x03
+
+#define FEEDBACK_DIVIDER_MSB_720p_50            0x7B
+#define FEEDBACK_DIVIDER_LSB_720p_50            0x0C
+#define VCO_CONTROL_720p_50                     0x02
+#define CP_CURRENT_720p_50                      0x03
+#define PHASE_SELECT_720p_50                    0x16
+#define HPLL_CONTROL_720p_50			0xa0
+#define AVID_START_PIXEL_LSB_720p_50		0x04
+#define AVID_START_PIXEL_MSB_720p_50		0x01
+#define AVID_STOP_PIXEL_LSB_720p_50		0x08
+#define AVID_STOP_PIXEL_MSB_720p_50		0x06
+#define VBLK_F0_START_LINE_OFFSET_720p_50	0x05
+#define VBLK_F1_START_LINE_OFFSET_720p_50	0x00
+#define VBLK_F0_DURATION_720p_50		0x2D
+#define VBLK_F1_DURATION_720p_50		0x00
+#define RESERVED_720p				0x03
+
+#define FEEDBACK_DIVIDER_MSB_1080i              0x89
+#define FEEDBACK_DIVIDER_LSB_1080i              0x08
+#define VCO_CONTROL_1080i                       0x02
+#define CP_CURRENT_1080i                        0x03
+#define PHASE_SELECT_1080i                      0x14
+#define HPLL_CONTROL_1080i			0xa0
+//#define AVID_START_PIXEL_LSB_1080i		0x06
+//#define AVID_START_PIXEL_MSB_1080i		0x01
+#define AVID_START_PIXEL_LSB_1080i		0xc6
+#define AVID_START_PIXEL_MSB_1080i		0x00
+//#define AVID_STOP_PIXEL_LSB_1080i		0x8A
+//#define AVID_STOP_PIXEL_MSB_1080i		0x08
+#define AVID_STOP_PIXEL_LSB_1080i		0x4A
+#define AVID_STOP_PIXEL_MSB_1080i		0x08
+#define VBLK_F0_START_LINE_OFFSET_1080i		0x02
+#define VBLK_F1_START_LINE_OFFSET_1080i		0x02
+#define VBLK_F0_DURATION_1080i			0x16
+#define VBLK_F1_DURATION_1080i			0x17
+#define RESERVED_1080i				0x02
+
+#define FEEDBACK_DIVIDER_MSB_1080i_50           0xA5
+#define FEEDBACK_DIVIDER_LSB_1080i_50           0x00
+#define VCO_CONTROL_1080i_50                    0x02
+#define CP_CURRENT_1080i_50                     0x02
+#define PHASE_SELECT_1080i_50                   0x14
+#define HPLL_CONTROL_1080i_50			0xa0
+#define AVID_START_PIXEL_LSB_1080i_50		0x06
+#define AVID_START_PIXEL_MSB_1080i_50		0x01
+#define AVID_STOP_PIXEL_LSB_1080i_50		0x8A
+#define AVID_STOP_PIXEL_MSB_1080i_50		0x08
+#define VBLK_F0_START_LINE_OFFSET_1080i_50	0x02
+#define VBLK_F1_START_LINE_OFFSET_1080i_50	0x02
+#define VBLK_F0_DURATION_1080i_50		0x16
+#define VBLK_F1_DURATION_1080i_50		0x17
+#define RESERVED_1080i_50			0x02
+
+
+#define FEEDBACK_DIVIDER_MSB_1080P_30           0x89
+#define FEEDBACK_DIVIDER_LSB_1080P_30           0x08
+#define VCO_CONTROL_1080P_30                    0x02
+#define CP_CURRENT_1080P_30                     0x03
+#define PHASE_SELECT_1080P_30                   0x14
+#define HPLL_CONTROL_1080P_30			0xa0
+//#define AVID_START_PIXEL_LSB_1080P_30		0x06
+//#define AVID_START_PIXEL_MSB_1080P_30		0x01
+#define AVID_START_PIXEL_LSB_1080P_30		0xfe
+#define AVID_START_PIXEL_MSB_1080P_30		0x00
+//#define AVID_STOP_PIXEL_LSB_1080P_30		0x8A
+//#define AVID_STOP_PIXEL_MSB_1080P_30		0x08
+#define AVID_STOP_PIXEL_LSB_1080P_30		0x82
+#define AVID_STOP_PIXEL_MSB_1080P_30		0x08
+#define VBLK_F0_START_LINE_OFFSET_1080P_30	0x27
+#define VBLK_F1_START_LINE_OFFSET_1080P_30	0x27
+#define VBLK_F0_DURATION_1080P_30		0x16
+#define VBLK_F1_DURATION_1080P_30		0x00
+#define RESERVED_1080P_30			0x02
+
+#define FEEDBACK_DIVIDER_MSB_1080P_25           0xA5
+#define FEEDBACK_DIVIDER_LSB_1080P_25           0x00
+#define VCO_CONTROL_1080P_25                    0x02
+#define CP_CURRENT_1080P_25                     0x02
+#define PHASE_SELECT_1080P_25                   0x14
+#define HPLL_CONTROL_1080P_25			0xa0
+#define AVID_START_PIXEL_LSB_1080P_25		0x06
+#define AVID_START_PIXEL_MSB_1080P_25		0x01
+#define AVID_STOP_PIXEL_LSB_1080P_25		0x8A
+#define AVID_STOP_PIXEL_MSB_1080P_25		0x08
+#define VBLK_F0_START_LINE_OFFSET_1080P_25	0x27
+#define VBLK_F1_START_LINE_OFFSET_1080P_25	0x27
+#define VBLK_F0_DURATION_1080P_25		0x16
+#define VBLK_F1_DURATION_1080P_25		0x00
+#define RESERVED_1080P   			0x02
+
+#define FEEDBACK_DIVIDER_MSB_1080P_24           0xAB
+#define FEEDBACK_DIVIDER_LSB_1080P_24           0x0E
+#define VCO_CONTROL_1080P_24                    0x02
+#define CP_CURRENT_1080P_24                     0x02
+#define PHASE_SELECT_1080P_24                   0x14
+#define HPLL_CONTROL_1080P_24			0xa0
+#define AVID_START_PIXEL_LSB_1080P_24		0x06
+#define AVID_START_PIXEL_MSB_1080P_24		0x01
+#define AVID_STOP_PIXEL_LSB_1080P_24		0x8A
+#define AVID_STOP_PIXEL_MSB_1080P_24		0x08
+#define VBLK_F0_START_LINE_OFFSET_1080P_24	0x27
+#define VBLK_F1_START_LINE_OFFSET_1080P_24	0x27
+#define VBLK_F0_DURATION_1080P_24		0x16
+#define VBLK_F1_DURATION_1080P_24		0x00
+#define RESERVED_1080P_24 			0x02
+
+#define FEEDBACK_DIVIDER_MSB_1080P_60           0x89
+#define FEEDBACK_DIVIDER_LSB_1080P_60           0x08
+#define VCO_CONTROL_1080P_60                    0x03
+#define CP_CURRENT_1080P_60                     0x06
+#define PHASE_SELECT_1080P_60                   0x80
+#define HPLL_CONTROL_1080P_60			0xf0
+//#define AVID_START_PIXEL_LSB_1080P_60		0x06
+//#define AVID_START_PIXEL_MSB_1080P_60		0x01
+#define AVID_START_PIXEL_LSB_1080P_60		0xfe
+#define AVID_START_PIXEL_MSB_1080P_60		0x00
+//#define AVID_STOP_PIXEL_LSB_1080P_60		0x8A
+//#define AVID_STOP_PIXEL_MSB_1080P_60		0x08
+#define AVID_STOP_PIXEL_LSB_1080P_60		0x82
+#define AVID_STOP_PIXEL_MSB_1080P_60		0x08
+#define VBLK_F0_START_LINE_OFFSET_1080P_60	0x27
+#define VBLK_F1_START_LINE_OFFSET_1080P_60	0x27
+#define VBLK_F0_DURATION_1080P_60		0x16
+#define VBLK_F1_DURATION_1080P_60		0x00
+#define RESERVED_1080P_60			0x02
+
+#define FEEDBACK_DIVIDER_MSB_1080P_50           0xA5
+#define FEEDBACK_DIVIDER_LSB_1080P_50           0x08
+#define VCO_CONTROL_1080P_50                    0x03
+#define CP_CURRENT_1080P_50                     0x06
+#define PHASE_SELECT_1080P_50                   0x80
+#define HPLL_CONTROL_1080P_50			0xf0
+//#define AVID_START_PIXEL_LSB_1080P_50		0x06
+//#define AVID_START_PIXEL_MSB_1080P_50		0x01
+#define AVID_START_PIXEL_LSB_1080P_50		0xfe
+#define AVID_START_PIXEL_MSB_1080P_50		0x00
+//#define AVID_STOP_PIXEL_LSB_1080P_50		0x8A
+//#define AVID_STOP_PIXEL_MSB_1080P_50		0x08
+#define AVID_STOP_PIXEL_LSB_1080P_50		0x82
+#define AVID_STOP_PIXEL_MSB_1080P_50		0x08
+#define VBLK_F0_START_LINE_OFFSET_1080P_50	0x27
+#define VBLK_F1_START_LINE_OFFSET_1080P_50	0x27
+#define VBLK_F0_DURATION_1080P_50		0x16
+#define VBLK_F1_DURATION_1080P_50		0x00
+#define RESERVED_1080P_50			0x02
+
+#define FEEDBACK_DIVIDER_MSB_480P		0x35
+#define FEEDBACK_DIVIDER_LSB_480P		0x0A
+#define VCO_CONTROL_480P			0x00
+#define CP_CURRENT_480P				0x05
+#define PHASE_SELECT_480P			0x14
+#define HPLL_CONTROL_480P			0x28
+#define AVID_START_PIXEL_LSB_480P		0x7a
+#define AVID_START_PIXEL_MSB_480P		0x00
+#define AVID_STOP_PIXEL_LSB_480P		0x4e
+#define AVID_STOP_PIXEL_MSB_480P		0x03
+#define VBLK_F0_START_LINE_OFFSET_480P		0x00
+#define VBLK_F1_START_LINE_OFFSET_480P		0x00
+#define VBLK_F0_DURATION_480P			0x2d
+#define VBLK_F1_DURATION_480P			0x00
+#define RESERVED_1080i_50                       0x02
+
+#define FEEDBACK_DIVIDER_MSB_576P               0x36
+#define FEEDBACK_DIVIDER_LSB_576P               0x00
+#define VCO_CONTROL_576P                        0x00
+#define CP_CURRENT_576P                         0x05
+#define PHASE_SELECT_576P                       0x14
+#define HPLL_CONTROL_576P                       0x28
+#define AVID_START_PIXEL_LSB_576P               0x84
+#define AVID_START_PIXEL_MSB_576P               0x00
+#define AVID_STOP_PIXEL_LSB_576P                0x58
+#define AVID_STOP_PIXEL_MSB_576P                0x03
+#define VBLK_F0_START_LINE_OFFSET_576P          0x00
+#define VBLK_F1_START_LINE_OFFSET_576P          0x00
+#define VBLK_F0_DURATION_576P                   0x2C
+#define VBLK_F1_DURATION_576P                   0x00
+#define RESERVED_1080i_50                       0x02
+
+#define FEEDBACK_DIVIDER_MSB_NTSC		0x35
+#define FEEDBACK_DIVIDER_LSB_NTSC		0x0A
+#define VCO_CONTROL_NTSC			0x00
+#define CP_CURRENT_NTSC				0x02
+#define PHASE_SELECT_NTSC			0x14
+#define HPLL_CONTROL_NTSC			0x10
+#define AVID_START_PIXEL_LSB_NTSC		0x7a
+#define AVID_START_PIXEL_MSB_NTSC		0x00
+#define AVID_STOP_PIXEL_LSB_NTSC		0x4E
+#define AVID_STOP_PIXEL_MSB_NTSC		0x03
+#define VBLK_F0_START_LINE_OFFSET_NTSC		0x03
+#define VBLK_F1_START_LINE_OFFSET_NTSC		0x03
+#define VBLK_F0_DURATION_NTSC			0x13
+#define VBLK_F1_DURATION_NTSC			0x14
+
+#define FEEDBACK_DIVIDER_MSB_PAL                0x36
+#define FEEDBACK_DIVIDER_LSB_PAL                0x00
+#define VCO_CONTROL_PAL                         0x00
+#define CP_CURRENT_PAL                          0x02
+#define PHASE_SELECT_PAL                        0x14
+#define HPLL_CONTROL_PAL                        0x10
+#define AVID_START_PIXEL_LSB_PAL                0x84
+#define AVID_START_PIXEL_MSB_PAL                0x00
+#define AVID_STOP_PIXEL_LSB_PAL                 0x58
+#define AVID_STOP_PIXEL_MSB_PAL                 0x03
+#define VBLK_F0_START_LINE_OFFSET_PAL           0x00
+#define VBLK_F1_START_LINE_OFFSET_PAL           0x17
+#define VBLK_F0_DURATION_PAL                    0x16
+#define VBLK_F1_DURATION_PAL                    0x17
+
+
+
+#define ADV9880_HD_ALC_PLACEMENT		0x5A
+#define ADV9880_ED_ALC_PLACEMENT		0x18
+
+#define ADV9880_HD_CLAMP_START			0x32
+#define ADV9880_ED_CLAMP_START			0x06
+
+#define ADV9880_HD_CLAMP_WIDTH			0x20
+#define ADV9880_ED_CLAMP_WIDTH			0x10
+
+#define ADV9880_HD_PRE_COAST			0x1
+#define ADV9880_ED_PRE_COAST			0x03
+
+#define ADV9880_HD_POST_COAST			0x0
+#define ADV9880_ED_POST_COAST			0x0C
+
+/* HPLL masks and shifts */
+#define HPLL_DIVIDER_LSB_MASK                   GENERATE_MASK(4, 0)
+#define HPLL_DIVIDER_LSB_SHIFT                  4
+#define VCO_CONTROL_MASK                        GENERATE_MASK(2, 0)
+#define CP_CURRENT_MASK                         GENERATE_MASK(3, 0)
+#define VCO_CONTROL_SHIFT                       6
+#define CP_CURRENT_SHIFT                        3
+#define PHASE_SELECT_MASK                       GENERATE_MASK(5, 0)
+#define PHASE_SELECT_SHIFT                      3
+
+
+#define LINES_PER_VSYNC_MSB_MASK                GENERATE_MASK(4, 8)
+#define LINES_PER_VSYNC_MSB_SHIFT               8
+
+
+/* Gain and offset masks */
+
+/* Defines for ADV9880 register address */
+#define ADV9880_REVISION                        0x00
+#define ADV9880_HPLL_DIVIDER_MSB                0x01
+#define ADV9880_HPLL_DIVIDER_LSB                0x02
+#define ADV9880_HPLL_CONTROL                    0x03
+#define ADV9880_HPLL_PHASE_SELECT               0x04
+
+#define ADV9880_RED_GAIN                        0x05
+#define ADV9880_GREEN_GAIN                      0x06
+#define ADV9880_BLUE_GAIN                       0x07
+
+#define ADV9880_RED_AUTO_OFFSET_ADJUST          0x08
+#define ADV9880_RED_OFFSET                      0x09
+#define ADV9880_GREEN_AUTO_OFFSET_ADJUST        0x0a
+#define ADV9880_GREEN_OFFSET                    0x0b
+#define ADV9880_BLUE_AUTO_OFFSET_ADJUST         0x0c
+#define ADV9880_BLUE_OFFSET                     0x0d
+
+#define ADV9880_SYNC_SEPARATER_THLD             0x0e
+#define ADV9880_SOG_THRESHOLD_ENTER             0x0f
+#define ADV9880_SOG_THRESHOLD_EXIT              0x10
+
+#define ADV9880_INPUT_SELECT                    0x11
+#define ADV9880_INPUT_SELECT_INTERFACE_MASK     0x02
+#define ADV9880_INPUT_SELECT_DIGITAL            0x02
+#define ADV9880_INPUT_SELECT_ANALOG             0x00
+#define ADV9880_INPUT_SELECT_MANUAL_MASK        0x01
+
+#define ADV9880_COAST_CONTROL                   0x12
+#define ADV9880_HPLL_PRE_COAST                  0x13
+#define ADV9880_HPLL_POST_COAST                 0x14
+#define ADV9880_SYNC_DETECT_1                   0x15
+#define ADV9880_SYNC_DETECT_2                   0x16
+#define ADV9880_LINES_PER_VSYNC_STATUS_HIGH     0x17
+#define ADV9880_LINES_PER_VSYNC_STATUS_LOW      0x18
+#define ADV9880_CLAMP_START                     0x19
+#define ADV9880_CLAMP_WIDTH                     0x1a
+
+#define ADV9880_CLAMP_CONTROL                   0x1b
+#define ADV9880_AUTO_OFFSET_CONTROL             0x1c
+#define ADV9880_AUTO_OFFSET_SLEW_LIMIT          0x1d
+#define ADV9880_SYNC_FILTER_LOCK_THRESHOLD      0x1e
+#define ADV9880_SYNC_FILTER_UNLOCK_THRESHOLD    0x1f
+#define ADV9880_SYNC_FILTER_WINDOW_WIDTH        0x20
+#define ADV9880_SYNC_FILTER_CONTROL             0x21
+#define ADV9880_VSYNC_DURATION                  0x22
+#define ADV9880_HSYNC_DURATION                  0x23
+#define ADV9880_OUTPUT_SYNC_CONTROL             0x24
+#define ADV9880_OUTPUT_MODE_CONTROL             0x25
+#define ADV9880_POWER_CONTROL                   0x26
+#define ADV9880_MISC_CONTROL_1                  0x27
+#define ADV9880_VS_DELAY                        0x28
+#define ADV9880_HS_DELAY                        0x29
+#define ADV9880_LINE_WIDTH_MSB                  0x2A
+#define ADV9880_LINE_WIDTH_LSB                  0x2B
+#define ADV9880_SCREEN_HEIGHT_MSB               0x2C
+#define ADV9880_SCREEN_HEIGHT_LSB               0x2D
+
+/* HDMI registers */
+#define ADV9880_I2S_CONTROL                     0x2E
+#define ADV9880_HDMI_STATUS_1                   0x2F
+#define ADV9880_HDMI_STATUS_2                   0x30
+#define ADV9880_MACROVISION_CONTROL_1           0x31
+#define ADV9880_MACROVISION_CONTROL_2           0x32
+#define ADV9880_MACROVISION_CONTROL_3           0x33
+#define ADV9880_COLOR_CONVERT_CONTROL           0x34
+
+#define ADV9880_HDMI_STATUS_1_DE_MASK           0x40
+
+/* Color conversion: 0x35 - 0x4C */
+#define ADV9880_COLOR_CONVERT_COEF_BASE         0x35
+
+#define ADV9880_AV_MUTE_CONTROL                 0x57
+#define ADV9880_MCLK_CONTROL                    0x58
+#define ADV9880_HDMI_CONTROL_1                  0x59
+#define ADV9880_PACKET_DETECT_STATUS            0x5A
+#define ADV9880_HDMI_MODE                       0x5B
+
+#define ADV9880_HDMI_MODE_DVI_HDMI_MASK         0x08
+#define ADV9880_HDMI_MODE_HDMI                  0x08
+#define ADV9880_HDMI_MODE_DVI                   0x00
+
+
+#define ADV9880_CHANNEL_STATUS                  0x5E
+
+#define ADV9880_AUDIO_SAMPLE_RATE               0x61
+#define ADV9880_AUDIO_SAMPLE_SIZE               0x62
+#define ADV9880_AUDIO_CTS_BASE                  0x7B
+#define ADV9880_AUDIO_N_BASE                    0x7D
+
+#define ADV9880_AVI_INFOFRAME_1                 0x81
+
+#define ADV9880_AVI_INFOFRAME_1_CSIN_MASK       0x60
+#define ADV9880_AVI_INFOFRAME_1_CSIN_RGB        0x00
+#define ADV9880_AVI_INFOFRAME_1_CSIN_YCBCR422   0x20
+#define ADV9880_AVI_INFOFRAME_1_CSIN_YCBCR444   0x40
+
+#define ADV9880_AVI_INFOFRAME_VIDEO_ID          0x84
+
+
+
+#define ADV9880_MISC_CONTROL_1_BT656_EN_MASK    0x10
+#define ADV9880_SYNC_DETECT_2_SYNC_LOCK_MASK    0x02
+
+
+#define ADV9880_OUTPUT_SYNC_CONTROL_HSYNC_POL_MASK 0x80
+#define ADV9880_OUTPUT_SYNC_CONTROL_VSYNC_POL_MASK 0x40
+#define ADV9880_OUTPUT_SYNC_CONTROL_DE_POL_MASK    0x20
+#define ADV9880_OUTPUT_SYNC_CONTROL_FIELD_POL_MASK 0x10
+
+
+
+/* decoder standard related strctures */
+#define ADV9880_MAX_NO_INPUTS			2
+#define ADV9880_MAX_NO_STANDARDS		13
+#define ADV9880_MAX_NO_CONTROLS			0
+
+#define ADV9880_ALC_VCOEFF_SHIFT		4
+
+#define ADV9880_STANDARD_INFO_SIZE      (ADV9880_MAX_NO_STANDARDS)
+
+struct adv9880_control_info {
+	int register_address;
+	struct v4l2_queryctrl query_control;
+};
+
+struct adv9880_config {
+	int no_of_inputs;
+	struct {
+		int input_type;
+		struct v4l2_input input_info;
+		int no_of_standard;
+		struct v4l2_standard *standard;
+		v4l2_std_id def_std;
+		struct adv9880_format_params *format;
+		int no_of_controls;
+		struct adv9880_control_info *controls;
+	} input[ADV9880_MAX_NO_INPUTS];
+	struct adv9880_params def_params;
+};
+
+#endif				/* __KERNEL__ */
+#endif
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/gv7601.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/gv7601.c	2012-09-23 16:05:57.000322027 -0600
@@ -0,0 +1,1144 @@
+//#define DEBUG
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+
+#include <linux/spi/spi.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+
+//#include <asm/arch/video_evm.h>
+#include <asm/uaccess.h>
+#include <mach/z3_fpga.h>
+
+#include <media/v4l2-ioctl.h>
+#include <linux/videodev2.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-chip-ident.h>
+#include <asm/uaccess.h>
+
+#include "gv7601.h"
+
+#define GV7601_SPI_TRANSFER_MAX 1024
+
+//#define GV7601_ENABLE_ANCILLARY_DATA
+
+#define DRIVER_NAME     "anc_data"
+
+/* Debug functions */
+static int debug = 0;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "Debug level (0-2)");
+
+/* Function Prototypes */
+static int gv7601_initialize(struct v4l2_subdev *sd);
+static int gv7601_deinitialize(struct v4l2_subdev *sd);
+static int gv7601_s_std(struct v4l2_subdev *sd, v4l2_std_id std);
+static int gv7601_querystd(struct v4l2_subdev *sd, v4l2_std_id *id);
+static int gv7601_s_stream(struct v4l2_subdev *sd, int enable);
+
+
+struct gv7601_spidata {
+	struct spi_device	*spi;
+
+	struct mutex		buf_lock;
+	unsigned		users;
+	u8			*buffer;
+};
+
+struct gv7601_params {
+	v4l2_std_id std;
+	int         inputidx;
+	struct v4l2_format fmt;
+};
+
+struct gv7601_channel {
+     struct v4l2_subdev    sd;
+     struct gv7601_spidata *spidata;
+     struct gv7601_params   params;
+     u16    anc_buf[GV7601_ANC_BANK_SIZE];
+};
+
+
+static struct gv7601_channel gv7601_channel_info[GV7601_NUM_CHANNELS] = {
+     [0] = {
+          .spidata = NULL,
+     },
+};
+
+
+static atomic_t reference_count = ATOMIC_INIT(0);
+
+/* For registeration of	charatcer device*/
+static struct cdev c_dev;
+/* device structure	to make	entry in device*/
+static dev_t dev_entry;
+
+static struct class *gv7601_class;
+
+static const struct v4l2_subdev_video_ops gv7601_video_ops = {
+	.querystd = gv7601_querystd,
+	.s_stream = gv7601_s_stream,
+//	.g_input_status = gv7601_g_input_status,
+};
+
+static const struct v4l2_subdev_core_ops gv7601_core_ops = {
+        .g_chip_ident = NULL,
+	.s_std = gv7601_s_std,
+};
+
+static const struct v4l2_subdev_ops gv7601_ops = {
+	.core = &gv7601_core_ops,
+	.video = &gv7601_video_ops,
+};
+
+
+
+#define V4L2_STD_GV7601_ALL        (V4L2_STD_720P_60 | \
+					V4L2_STD_720P_50 | \
+					V4L2_STD_1080I_60 | \
+					V4L2_STD_1080I_50 | \
+					V4L2_STD_1080P_24 | \
+					V4L2_STD_1080P_25 | \
+					V4L2_STD_1080P_30 | \
+					V4L2_STD_525P_60 | \
+					V4L2_STD_625P_50 | \
+                                        V4L2_STD_525_60 | \
+                                        V4L2_STD_625_50 \
+                                   )
+#if 0
+static struct v4l2_standard gv7601_standards[GV7601_MAX_NO_STANDARDS] = {
+	{
+		.index = 0,
+		.id = V4L2_STD_720P_60,
+		.name = "720P-60",
+		.frameperiod = {1, 60},
+		.framelines = 720
+	},
+	{
+		.index = 1,
+		.id = V4L2_STD_1080I_60,
+		.name = "1080I-30",
+		.frameperiod = {1, 30},
+		.framelines = 1080
+	},
+	{
+		.index = 2,
+		.id = V4L2_STD_1080I_50,
+		.name = "1080I-25",
+		.frameperiod = {1, 25},
+		.framelines = 1080
+	},
+	{
+		.index = 3,
+		.id = V4L2_STD_720P_50,
+		.name = "720P-50",
+		.frameperiod = {1, 50},
+		.framelines = 720
+	},
+	{
+		.index = 4,
+		.id = V4L2_STD_1080P_25,
+		.name = "1080P-25",
+		.frameperiod = {1, 25},
+		.framelines = 1080
+	},
+	{
+		.index = 5,
+		.id = V4L2_STD_1080P_30,
+		.name = "1080P-30",
+		.frameperiod = {1, 30},
+		.framelines = 1080
+	},
+	{
+		.index = 6,
+		.id = V4L2_STD_1080P_24,
+		.name = "1080P-24",
+		.frameperiod = {1, 24},
+		.framelines = 1080
+	},
+	{
+		.index = 7,
+		.id = V4L2_STD_525P_60,
+		.name = "480P-60",
+		.frameperiod = {1, 60},
+		.framelines = 525
+	},
+	{
+		.index = 8,
+		.id = V4L2_STD_625P_50,
+		.name = "576P-50",
+		.frameperiod = {1, 50},
+		.framelines = 625
+	},
+	{
+		.index = 9,
+		.id = V4L2_STD_525_60,
+		.name = "NTSC",
+		.frameperiod = {1001, 30000},
+		.framelines = 525
+	},
+	{
+		.index = 10,
+		.id = V4L2_STD_625_50,
+		.name = "PAL",
+		.frameperiod = {1, 25},
+		.framelines = 625
+	},
+};
+#endif
+
+struct v4l2_input gv7601_inputs[GV7601_MAX_NO_INPUTS] = {
+     [0] = {
+          .index = 0,
+          .name  = "HD-SDI",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std  = V4L2_STD_GV7601_ALL,
+     },
+};
+
+
+static inline struct gv7601_channel *to_gv7601(struct v4l2_subdev *sd)
+{
+	return container_of(sd, struct gv7601_channel, sd);
+}
+
+
+static struct spi_device *gv7601_get_spi( struct gv7601_channel *ch )
+{
+     if ( ch == NULL
+          || ch->spidata == NULL )
+          return NULL;
+
+     return ch->spidata->spi;
+
+}
+
+static struct device *gv7601_get_dev( struct gv7601_channel *ch )
+{
+     if ( ch == NULL
+          || ch->spidata == NULL
+          || ch->spidata->spi == NULL )
+          return NULL;
+
+     return &ch->spidata->spi->dev;
+}
+
+int gv7601_read_buffer(struct spi_device *spi, u16 offset, u16 *values, int length )
+{
+     struct spi_message msg;
+     struct spi_transfer spi_xfer;
+     int status;
+     u16 txbuf[GV7601_SPI_TRANSFER_MAX+1] = {
+          0x9000,  // read, auto-increment
+     };
+     u16 rxbuf[GV7601_SPI_TRANSFER_MAX+1];
+
+     if ( NULL == spi ) {
+          return -ENODEV;
+     }
+
+     if ( length > GV7601_SPI_TRANSFER_MAX ) {
+          return -EINVAL;
+     }
+
+     txbuf[0] = txbuf[0] | (offset & 0xfff);
+
+     memset( &spi_xfer, '\0', sizeof(spi_xfer) );
+     spi_xfer.tx_buf = txbuf;
+     spi_xfer.rx_buf = rxbuf;
+     spi_xfer.cs_change = 1;
+     spi_xfer.bits_per_word = 16;
+     spi_xfer.delay_usecs = 0;
+     spi_xfer.speed_hz = 1000000;
+     spi_xfer.len = sizeof(*values)*(length+1); // length in bytes
+
+     spi_message_init( &msg );
+     spi_message_add_tail( &spi_xfer, &msg );
+
+     status = spi_sync(spi, &msg);
+
+     memcpy( values, &rxbuf[1], sizeof(*values)*length );
+
+     return status;
+}
+
+int gv7601_read_register(struct spi_device *spi, u16 offset, u16 *value)
+{
+     struct spi_message msg;
+     struct spi_transfer spi_xfer;
+     int status;
+     u32 txbuf[1] = {
+          0x90000000,  // read, auto-increment
+     };
+     u32 rxbuf[1];
+
+     if ( NULL == spi ) {
+          return -ENODEV;
+     }
+
+
+     txbuf[0] = txbuf[0] | ((offset & 0xfff)<<16);
+
+     memset( &spi_xfer, '\0', sizeof(spi_xfer) );
+     spi_xfer.tx_buf = txbuf;
+     spi_xfer.rx_buf = rxbuf;
+     spi_xfer.cs_change = 0; // ??
+     spi_xfer.bits_per_word = 32;
+     spi_xfer.delay_usecs = 0;
+     spi_xfer.speed_hz = 1000000;
+     spi_xfer.len = 4; // length in bytes
+
+     spi_message_init( &msg );
+     spi_message_add_tail( &spi_xfer, &msg );
+
+     status = spi_sync(spi, &msg);
+
+     if ( 0 != status ) {
+             dev_dbg( &spi->dev, "read_reg failed\n" );
+             *value = 0xffff;
+     } else {
+             *value = (u16)(rxbuf[0] & 0xffff);
+     }
+
+     return status;
+}
+
+int gv7601_write_buffer(struct spi_device *spi, u16 offset, u16 *values, int length)
+{
+     struct spi_message msg;
+     struct spi_transfer spi_xfer;
+     int status;
+     u16 txbuf[GV7601_SPI_TRANSFER_MAX] = {
+          0x1000,  // write, auto-increment
+     };
+     u16 rxbuf[GV7601_SPI_TRANSFER_MAX] = {
+     };
+
+     if ( NULL == spi ) {
+          return -ENODEV;
+     }
+
+     if ( length > GV7601_SPI_TRANSFER_MAX-1 ) {
+          return -EINVAL;
+     }
+
+     txbuf[0] = txbuf[0] | (offset & 0xfff);
+     memcpy( &txbuf[1], values, sizeof(*values)*length );
+
+     memset( &spi_xfer, '\0', sizeof(spi_xfer) );
+     spi_xfer.tx_buf = txbuf;
+     spi_xfer.rx_buf = rxbuf;
+     spi_xfer.cs_change = 0; // ??
+     spi_xfer.bits_per_word = 16;
+     spi_xfer.delay_usecs = 0;
+     spi_xfer.speed_hz = 1000000;
+     spi_xfer.len = sizeof(*values)*(length+1); // length in bytes
+
+     spi_message_init( &msg );
+     spi_message_add_tail( &spi_xfer, &msg );
+
+     status = spi_sync(spi, &msg);
+     return status;
+}
+
+
+int gv7601_write_register(struct spi_device *spi, u16 offset, u16 value)
+{
+     return gv7601_write_buffer(spi, offset, &value, 1);
+}
+
+
+static struct timer_list gv7601_timer;
+static unsigned int gv7601_timeout_ms = 50;
+
+static void gv7601_workqueue_handler(struct work_struct * data);
+
+DECLARE_WORK(gv7601_worker, gv7601_workqueue_handler);
+
+static void gv7601_timer_function(unsigned long data)
+{
+     (void) data;
+     schedule_work(&gv7601_worker);
+     mod_timer( &gv7601_timer, jiffies + msecs_to_jiffies( gv7601_timeout_ms ) );
+}
+
+
+static void gv7601_workqueue_handler(struct work_struct *ignored)
+{
+     struct gv7601_channel *ch;
+     struct spi_device *spi;
+     u16    bank_reg_base, anc_reg;
+     static u16    anc_buf[257];
+     int    anc_length;
+     int    adf_found = 1;
+     int    ch_id;
+     int    status;
+     u16    did,sdid;
+
+     for ( ch_id = 0; ch_id < GV7601_NUM_CHANNELS; ch_id++ ) {
+          ch = &gv7601_channel_info[ch_id];
+
+          spi = gv7601_get_spi( ch );
+          if ( NULL == spi ) {
+               continue;
+          }
+
+          /* Step 2: start writing to other bank */
+          gv7601_write_register( spi,
+                                 GV7601_REG_ANC_CONFIG,
+                                 GV7601_ANC_CONFIG_ANC_DATA_SWITCH
+          );
+
+
+#if 1
+          /* Step 1: read ancillary data */
+          bank_reg_base = GV7601_ANC_BANK_REG;
+          status = 0;
+          for ( anc_reg = bank_reg_base, adf_found = 1;
+                (0 == status) && ((anc_reg+6) < bank_reg_base + GV7601_ANC_BANK_SIZE);
+                ) {
+
+               status = gv7601_read_buffer(spi, anc_reg, anc_buf, 6);
+               anc_reg += 6;
+
+               if (anc_reg >= bank_reg_base + GV7601_ANC_BANK_SIZE)
+                    break;
+
+               if ( 0 == status ) {
+                    if ( anc_buf[0] == 0
+                         || anc_buf[1] == 0xff
+                         || anc_buf[2] == 0xff ) {
+
+                         did = anc_buf[3];
+                         sdid = anc_buf[4];
+                         anc_length = (anc_buf[5] & 0xff)+1;
+                         anc_reg += anc_length;
+
+                         if ( !( did ==0 && sdid == 0)
+                              && ( did < 0xf8 ) ) {
+                              dev_dbg( &spi->dev, "anc[%x] %02x %02x %02x\n",
+                                       anc_reg,
+                                       did,
+                                       sdid,
+                                       anc_length );
+                         }
+                    } else {
+                         break;
+                    }
+               }
+          }
+          dev_dbg( &spi->dev, "anc_end[%x] %02x %02x %02x\n",
+                   anc_reg,
+                   anc_buf[0],
+                   anc_buf[1],
+                   anc_buf[2] );
+#endif
+
+          /* Step 3: switch reads to other bank */
+          gv7601_write_register( spi,
+                                 GV7601_REG_ANC_CONFIG,
+                                 0 );
+
+     }
+}
+
+
+static int gv7601_dump_regs(struct spi_device *spi)
+{
+        u16 value;
+        int offset;
+
+        u16 stdlock_value = 0;
+
+        for ( offset=0; offset < 0x80; offset++ ) {
+
+                /* Skip reserved registers */
+                if ( offset == 1
+                     || offset == 3
+                     || offset == 7
+                     || offset == 0x0d
+                     || offset == 0x0e
+                     || ( 0x14 <= offset  && offset <= 0x1e )
+                     || ( 0x27 <= offset  && offset <= 0x36 )
+                     || offset == 0x38
+                     || ( 0x3a <= offset  && offset <= 0x6b )
+                     || ( 0x6e <= offset  && offset <= 0x72 )
+                     || ( 0x74 <= offset  && offset <= 0x85 ) )
+                        continue;
+
+                if ( 0 == gv7601_read_register( spi, offset, &value ) ) {
+                        if ( value != 0 ) {
+                                dev_dbg( &spi->dev, "vid_core offset %u value x%04x\n",
+                                         (unsigned int)offset, (unsigned int)value );
+                        }
+                        if ( offset == GV7601_REG_STD_LOCK ) {
+                                stdlock_value = value;
+                        }
+                }
+
+        }
+
+        /* Audio registers only valid when standard is locked */
+        switch (stdlock_value & 0xd000) {
+        case 0x1000:
+        case 0x9000:
+
+                for ( offset=0x200; offset < 0x210; offset++ ) {
+                        if ( 0 == gv7601_read_register( spi, offset, &value ) ) {
+                                if ( value != 0 ) {
+                                        dev_dbg( &spi->dev, "hd_audio offset %u value x%04x\n",
+                                                 (unsigned int)offset, (unsigned int)value );
+                                }
+                        }
+                }
+                break;
+
+        case 0x5000:
+        case 0xd000:
+
+                for ( offset=0x400; offset < 0x410; offset++ ) {
+                        if ( 0 == gv7601_read_register( spi, offset, &value ) ) {
+                                if ( value != 0 ) {
+                                        dev_dbg( &spi->dev, "sd_audio offset %u value x%04x\n",
+                                                 (unsigned int)offset, (unsigned int)value );
+                                }
+                        }
+                }
+
+                break;
+        default:
+                break;
+        }
+
+        return 0;
+}
+
+#if defined(GV7601_ENABLE_ANCILLARY_DATA)
+static int gv7601_init_ancillary(struct spi_device *spi)
+{
+        u16 value;
+        int offset;
+
+        int status = 0;
+
+        /* Set up ancillary data filtering */
+        if ( 0 == status )
+                status = gv7601_write_register( spi,
+                                       GV7601_REG_ANC_TYPE1,
+                                       0x4100 ); // SMPTE-352M Payload ID (0x4101)
+        if ( 0 == status )
+                status = gv7601_write_register( spi,
+                                       GV7601_REG_ANC_TYPE2,
+                                       0x5f00 ); // Placeholder
+
+        if ( 0 == status )
+                status = gv7601_write_register( spi,
+                                       GV7601_REG_ANC_TYPE3,
+                                       0x6000 ); // Placeholder
+
+        if ( 0 == status )
+                status = gv7601_write_register( spi,
+                                       GV7601_REG_ANC_TYPE4,
+                               0x6100 ); // SMPTE 334 - SDID 01=EIA-708, 02=EIA-608
+        if ( 0 == status )
+                status = gv7601_write_register( spi,
+                               GV7601_REG_ANC_TYPE5,
+                               0x6200 ); // SMPTE 334 - SDID 01=Program description, 02=Data broadcast, 03=VBI data
+
+        if ( 0 == gv7601_read_register( spi, GV7601_REG_ANC_TYPE1, &value ) ) {
+                dev_dbg( &spi->dev, "REG_ANC_TYPE1 value x%04x\n",
+                                 (unsigned int)value );
+        }
+        if ( 0 == gv7601_read_register( spi, GV7601_REG_ANC_TYPE2, &value ) ) {
+                dev_dbg( &spi->dev, "REG_ANC_TYPE2 value x%04x\n",
+                                 (unsigned int)value );
+        }
+
+
+        /* Clear old ancillary data */
+        if ( 0 == status )
+                status = gv7601_write_register( spi,
+                                                GV7601_REG_ANC_CONFIG,
+                                                GV7601_ANC_CONFIG_ANC_DATA_SWITCH
+                );
+
+        /* Step 2: start writing to other bank */
+        if ( 0 == status )
+                status = gv7601_write_register( spi,
+                                                GV7601_REG_ANC_CONFIG,
+                                                0
+                        );
+
+        return status;
+}
+#endif
+
+/* gv7601_initialize :
+ * This function will set the video format standard
+ */
+static int gv7601_initialize(struct v4l2_subdev *sd)
+{
+        struct gv7601_channel *ch;
+        struct spi_device *spi;
+        int status = 0;
+
+        ch = to_gv7601(sd);
+
+        try_module_get(THIS_MODULE);
+
+        spi = gv7601_get_spi( ch );
+
+#if 0
+        gv7601_write_register( spi,
+                               GV7601_REG_VIDEO_CONFIG,
+                               (GV7601_REG_VIDEO_CONFIG_861_PIN_DISABLE_MASK|
+                                GV7601_REG_VIDEO_CONFIG_TIMING_861_MASK)
+                );
+#endif
+
+#if defined(GV7601_ENABLE_ANCILLARY_DATA)
+        gv7601_init_ancillary(spi);
+#endif
+
+
+#if 0
+        if ( gv7601_timer.function == NULL ) {
+                init_timer(&gv7601_timer);
+                gv7601_timer.function = gv7601_timer_function;
+        }
+        mod_timer( &gv7601_timer, jiffies + msecs_to_jiffies( gv7601_timeout_ms ) );
+#endif
+
+        return status;
+}
+
+static int gv7601_deinitialize(struct v4l2_subdev *sd)
+{
+	int ch_id;
+        struct gv7601_channel *ch;
+        struct device *dev;
+
+        ch = to_gv7601( sd );
+
+        dev = gv7601_get_dev( ch );
+        if ( NULL != dev ) {
+             dev_dbg( dev, "GV7601 deinitialization\n");
+        }
+
+#if 0
+        del_timer_sync( &gv7601_timer );
+#endif
+
+        module_put(THIS_MODULE);
+
+        return 0;
+}
+
+static int gv7601_s_std(struct v4l2_subdev *sd, v4l2_std_id std)
+{
+
+	v4l2_dbg(1, debug, sd, "Start of adv7611_setstd 0x%llx..\n", std );
+
+	v4l2_dbg(1, debug, sd, "End of adv7611 set standard...\n");
+
+        return 0;
+}
+
+
+static int gv7601_querystd(struct v4l2_subdev *sd, v4l2_std_id *id)
+{
+     struct spi_device     *spi = NULL;
+     struct gv7601_channel *ch  = NULL;
+
+     u16 std_lock_value;
+     u16 sync_lock_value;
+     u16 words_per_actline_value;
+     u16 words_per_line_value;
+     u16 lines_per_frame_value;
+     u16 actlines_per_frame_value;
+     u16 interlaced_flag;
+     int status;
+     u16 sd_audio_status_value;
+     u16 hd_audio_status_value;
+     u16 sd_audio_config_value;
+     u16 hd_audio_config_value;
+     u16 readback_value;
+
+     ch = to_gv7601( sd );
+     spi = gv7601_get_spi( ch );
+     if ( NULL == spi ) {
+          return -ENODEV;
+     }
+
+
+//     *id = V4L2_STD_1080P_60;
+//     return 0;
+
+     status = gv7601_read_register( spi,
+                                    GV7601_REG_STD_LOCK,
+                                    &std_lock_value );
+     actlines_per_frame_value = std_lock_value & GV7601_REG_STD_LOCK_ACT_LINES_MASK;
+     interlaced_flag = std_lock_value & GV7601_REG_STD_LOCK_INT_PROG_MASK;
+     interlaced_flag = !!interlaced_flag;
+
+     if ( 0 == status ) {
+          status = gv7601_read_register( spi,
+                                         GV7601_REG_HVLOCK,
+                                         &sync_lock_value );
+     }
+     if ( 0 == status ) {
+          status = gv7601_read_register( spi,
+                                         GV7601_REG_WORDS_PER_ACTLINE,
+                                         &words_per_actline_value );
+          words_per_actline_value &= GV7601_REG_WORDS_PER_ACTLINE_MASK;
+     }
+     if ( 0 == status ) {
+          status = gv7601_read_register( spi,
+                                         GV7601_REG_WORDS_PER_LINE,
+                                         &words_per_line_value );
+          words_per_line_value &= GV7601_REG_WORDS_PER_LINE_MASK;
+     }
+     if ( 0 == status ) {
+          status = gv7601_read_register( spi,
+                                         GV7601_REG_LINES_PER_FRAME,
+                                         &lines_per_frame_value );
+          lines_per_frame_value &= GV7601_REG_LINES_PER_FRAME_MASK;
+     }
+
+     if ( 0 == status ) {
+             v4l2_dbg(1, debug, sd, "Words per line %u/%u Lines per frame %u/%u\n",
+                      (unsigned int) words_per_actline_value,
+                      (unsigned int) words_per_line_value,
+                      (unsigned int) actlines_per_frame_value,
+                      (unsigned int) lines_per_frame_value );
+             v4l2_dbg(1, debug, sd, "SyncLock: %s %s StdLock: 0x%04x\n",
+                   (sync_lock_value & GV7601_REG_HVLOCK_VLOCK_MASK) ? "Vsync" : "NoVsync",
+                   (sync_lock_value & GV7601_REG_HVLOCK_HLOCK_MASK) ? "Hsync" : "NoHsync",
+                   (unsigned int)(std_lock_value) );
+     }
+
+     if ( 0 == status ) {
+          status = gv7601_read_register( spi, GV7601_REG_SD_AUDIO_STATUS, &sd_audio_status_value );
+          v4l2_dbg(1, debug, sd, "SD audio status 0x%x\n", (unsigned int)sd_audio_status_value );
+     }
+     if ( 0 == status ) {
+          status = gv7601_read_register( spi, GV7601_REG_HD_AUDIO_STATUS, &hd_audio_status_value );
+          v4l2_dbg(1, debug, sd, "HD audio status 0x%x\n", (unsigned int)hd_audio_status_value );
+     }
+
+     if ( 0 == lines_per_frame_value ) {
+          return -EINVAL;
+     }
+
+     if ( interlaced_flag != 0
+          && lines_per_frame_value == 525 ) {
+          *id = V4L2_STD_525_60;
+     }
+     else if ( interlaced_flag != 0
+               && lines_per_frame_value == 625 ) {
+          *id = V4L2_STD_625_50;
+     }
+     else if ( interlaced_flag == 0
+               && lines_per_frame_value == 525 ) {
+          *id = V4L2_STD_525P_60;
+     }
+     else if ( interlaced_flag == 0
+               && lines_per_frame_value == 625 ) {
+          *id = V4L2_STD_625P_50;
+     }
+     else if ( interlaced_flag == 0
+               && 749 <= lines_per_frame_value
+               && lines_per_frame_value <= 750 ) {
+
+          if ( words_per_line_value > 1650  ) {
+               *id = V4L2_STD_720P_50;
+          } else {
+               *id = V4L2_STD_720P_60;
+          }
+     }
+     else if ( interlaced_flag == 0
+               && 1124 <= lines_per_frame_value
+               && lines_per_frame_value <= 1125 ) {
+          if ( words_per_line_value >= 2200+550 ) {
+               *id = V4L2_STD_1080P_24;
+          }
+          else if ( words_per_line_value >= 2200+440 ) {
+               *id = V4L2_STD_1080P_25;
+          }
+          else {
+//               *id = V4L2_STD_1080P_30;
+               *id = V4L2_STD_1080P_60;
+          }
+     }
+     else if ( interlaced_flag == 1
+               && 1124 <= lines_per_frame_value
+               && lines_per_frame_value <= 1125 ) {
+
+          if ( words_per_line_value >= 2200+440 ) {
+               *id = V4L2_STD_1080I_50;
+          }
+          else {
+               *id = V4L2_STD_1080I_60;
+          }
+     }
+     else {
+          dev_err( &spi->dev, "Std detection failed: interlaced_flag: %u words per line %u/%u Lines per frame %u/%u SyncLock: %s %s StdLock: 0x%04x\n",
+                   (unsigned int) interlaced_flag,
+                   (unsigned int) words_per_actline_value,
+                   (unsigned int) words_per_line_value,
+                   (unsigned int) actlines_per_frame_value,
+                   (unsigned int) lines_per_frame_value,
+                   (sync_lock_value & GV7601_REG_HVLOCK_VLOCK_MASK) ? "Vsync" : "NoVsync",
+                   (sync_lock_value & GV7601_REG_HVLOCK_HLOCK_MASK) ? "Hsync" : "NoHsync",
+                   (unsigned int)(std_lock_value) );
+          return -EINVAL;
+     }
+
+     sd_audio_config_value = 0xaaaa; // 16-bit, right-justified
+
+     if ( 0 == status ) {
+          status = gv7601_write_register( spi,
+                                          GV7601_REG_SD_AUDIO_CONFIG,
+                                          sd_audio_config_value );
+     }
+     if ( 0 == status ) {
+          status = gv7601_read_register( spi,
+                                         GV7601_REG_SD_AUDIO_CONFIG,
+                                         &readback_value );
+          if ( 0 == status ) {
+               if ( sd_audio_config_value != readback_value ) {
+                    dev_dbg( &spi->dev, "SD audio readback failed, wanted x%04x, got x%04x\n",
+                             (unsigned int) sd_audio_config_value,
+                             (unsigned int) readback_value
+                         );
+               }
+          }
+     }
+
+     if ( 0 == status ) {
+          hd_audio_config_value = 0x0aa4; // 16-bit, right-justified
+
+          status = gv7601_write_register( spi,
+                                     GV7601_REG_HD_AUDIO_CONFIG,
+                                     hd_audio_config_value );
+
+     }
+
+     if ( 0 == status ) {
+          status = gv7601_read_register( spi,
+                                         GV7601_REG_HD_AUDIO_CONFIG,
+                                         &readback_value );
+          if ( 0 == status ) {
+               if ( hd_audio_config_value != readback_value ) {
+                    dev_dbg( &spi->dev, "HD audio readback failed, wanted x%04x, got x%04x\n",
+                             (unsigned int) hd_audio_config_value,
+                             (unsigned int) readback_value
+                         );
+               }
+          }
+     }
+
+
+     switch ( *id ) {
+     case V4L2_STD_525_60:
+     case V4L2_STD_625_50:
+          dev_dbg( &spi->dev, "Set SD-SDI input, 8-bits width\n");
+//          dec_device->if_type = INTERFACE_TYPE_BT656;
+          gv7601_write_register( spi,
+                                 GV7601_REG_ANC_CONFIG,
+                                 2 );
+
+          z3_fpga_si_20bit( 0 );
+          break;
+
+     default:
+          dev_dbg( &spi->dev, "Set HD-SDI input, 16-bits width\n");
+//          dec_device->if_type = INTERFACE_TYPE_BT1120;
+          gv7601_write_register( spi,
+                                 GV7601_REG_ANC_CONFIG,
+                                 0 );
+          z3_fpga_si_20bit( 1 );
+          break;
+     }
+
+#if 0
+     status = gv7601_write_register( spi,
+                                     GV7601_REG_AUDIO_CONFIG,
+                                     (GV7601_REG_AUDIO_CONFIG_SCLK_INV_MASK | GV7601_REG_AUDIO_CONFIG_MCLK_SEL_128FS)
+          );
+#endif
+
+     return 0;
+}
+
+static int gv7601_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	v4l2_dbg(1, debug, sd, "Start of gv7601_s_stream %d\n", enable );
+
+        return 0;
+}
+
+
+
+/*-------------------------------------------------------------------------*/
+
+int gv7601_char_open (struct inode *inode, struct file *file)
+{
+        int ch_id = 0; //iminor(inode)
+        struct gv7601_channel *ch;
+
+ 	if (file->f_mode == FMODE_WRITE) {
+		printk (KERN_ERR "TX Not supported\n");
+		return -EACCES;
+	}
+
+        if ( ch_id >= GV7601_NUM_CHANNELS ){
+            printk(KERN_ERR "gv7601: Bad channel ID\n");
+             return -EINVAL;
+        }
+
+        ch = &gv7601_channel_info[ch_id];
+
+        file->private_data =  ch;
+
+	if (atomic_inc_return(&reference_count) > 1) {
+                printk(KERN_ERR "gv7601: already open\n");
+		atomic_dec(&reference_count);
+		return -EACCES;
+	}
+
+	return 0;
+}
+
+
+int gv7601_char_release (struct inode *inode, struct file *file)
+{
+	atomic_dec(&reference_count);
+	return 0;
+}
+
+
+
+ssize_t gv7601_char_read (struct file *file,
+                          char __user *buff,
+                          size_t size,
+                          loff_t *loff)
+{
+
+     struct gv7601_channel *channel = file->private_data;
+     struct spi_device     *spi;
+     int                    status;
+
+     if ( NULL == channel ) {
+          printk( KERN_ERR "gv7601: No channel\n" );
+          return -ENODEV;
+     }
+
+     if ( NULL == (spi = gv7601_get_spi(channel)) ) {
+          printk( KERN_ERR "gv7601: No spi dev\n" );
+          return -ENODEV;
+     }
+
+     /* we only allow one key read at a time */
+     size = (size/2)*2;
+     if (size > GV7601_ANC_BANK_SIZE) {
+          size = GV7601_ANC_BANK_SIZE;
+     }
+
+begin:
+     /* Step 2: start writing to other bank */
+     gv7601_write_register( spi,
+                            GV7601_REG_ANC_CONFIG,
+                            GV7601_ANC_CONFIG_ANC_DATA_SWITCH );
+
+
+     status = gv7601_read_buffer(spi, GV7601_ANC_BANK_REG, channel->anc_buf, size/2);
+     if ( 0 != status ) {
+          printk( KERN_ERR "gv7601: Read buffer fail\n" );
+          return status;
+     }
+
+     /* Step 3: switch reads to other bank */
+     gv7601_write_register( spi,
+                            GV7601_REG_ANC_CONFIG,
+                            0 );
+
+     if ( channel->anc_buf[1] != 0 ) {
+          /* there is a key to be read.. */
+          if (copy_to_user(buff, channel->anc_buf, size) != 0)
+               return -EFAULT;
+     } else {
+
+          /* tell non blocking applications to come again */
+          if (file->f_flags & O_NONBLOCK) {
+               return -EAGAIN;
+          } else { /* ask blocking applications to sleep comfortably */
+               msleep(20);
+               goto begin;
+          }
+     }
+
+     return size;
+}
+
+
+
+long gv7601_char_ioctl ( struct file *filp, unsigned int cmd, unsigned long arg )
+{
+     return -ENOTTY;
+}
+
+static struct file_operations gv7601_char_fops = {
+     .owner   = THIS_MODULE,
+     .open    = gv7601_char_open,
+     .read    = gv7601_char_read,
+     .release = gv7601_char_release,
+     .unlocked_ioctl   = gv7601_char_ioctl,
+};
+
+
+
+/*-------------------------------------------------------------------------*/
+
+
+static int gv7601_probe(struct spi_device *spi)
+{
+     struct gv7601_spidata	*spidata;
+     int			status = 0;
+     struct gv7601_channel      *channel;
+     struct v4l2_subdev         *sd;
+
+     dev_dbg( &spi->dev, "Enter gv7601_probe\n" );
+
+     /* Allocate driver data */
+     spidata = kzalloc(sizeof(*spidata), GFP_KERNEL);
+     if (!spidata)
+          return -ENOMEM;
+
+     /* Initialize the driver data */
+     spidata->spi = spi;
+     mutex_init(&spidata->buf_lock);
+
+     channel = &gv7601_channel_info[0];
+     channel->spidata = spidata;
+     sd = &channel->sd;
+
+     v4l2_spi_subdev_init( sd, spi, &gv7601_ops );
+
+#if 1
+     if ( 0 == status ) {
+          status = alloc_chrdev_region(&dev_entry, 0, 1, DRIVER_NAME);
+          if (status < 0) {
+               printk("\ngv7601: Module intialization failed.\
+		could not register character device");
+               return -ENODEV;
+          }
+          /* Initialize of character device */
+          cdev_init(&c_dev, &gv7601_char_fops);
+          c_dev.owner = THIS_MODULE;
+          c_dev.ops = &gv7601_char_fops;
+
+          /* addding character device */
+          status = cdev_add(&c_dev, dev_entry, 1);
+
+          if (status) {
+               printk(KERN_ERR "gv7601 :Error %d adding cdev\
+				 ..error no:", status);
+               unregister_chrdev_region(dev_entry, 1);
+               return status;
+          }
+
+          /* registeration of     character device */
+          register_chrdev(MAJOR(dev_entry), DRIVER_NAME, &gv7601_char_fops);
+     }
+
+     if ( 0 == status ) {
+	gv7601_class = class_create(THIS_MODULE, "gv7601");
+
+	if (!gv7601_class) {
+             cdev_del(&c_dev);
+             unregister_chrdev_region(dev_entry, 1);
+             unregister_chrdev(MAJOR(dev_entry), DRIVER_NAME);
+
+             status =-EIO;
+	}
+     }
+
+     if ( 0 == status ) {
+          device_create(gv7601_class, &spi->dev, dev_entry, channel, DRIVER_NAME);
+     }
+#endif
+
+     if ( 0 == status ) {
+             status = gv7601_initialize(sd);
+     }
+
+     printk (KERN_ERR "gv7601_probe returns %d\n",status );
+     return status;
+}
+
+static int gv7601_remove(struct spi_device *spi)
+{
+	struct v4l2_subdev *sd = spi_get_drvdata(spi);
+        struct gv7601_channel *ch  = NULL;
+
+        ch = to_gv7601( sd );
+
+        gv7601_deinitialize(sd);
+
+        kfree( ch->spidata );
+        ch->spidata = NULL;
+
+	v4l2_device_unregister_subdev(sd);
+
+	return 0;
+}
+
+
+static struct spi_driver gv7601_spi = {
+	.driver = {
+		.name =		"gv7601",
+		.owner =	THIS_MODULE,
+	},
+	.probe =	gv7601_probe,
+	.remove =	__devexit_p(gv7601_remove),
+
+	/* NOTE:  suspend/resume methods are not necessary here.
+	 * We don't do anything except pass the requests to/from
+	 * the underlying controller.  The refrigerator handles
+	 * most issues; the controller driver handles the rest.
+	 */
+};
+
+
+static int __init gv7601_init(void)
+{
+     int status;
+
+     status = spi_register_driver(&gv7601_spi);
+
+     return status;
+}
+
+static void __exit gv7601_exit(void)
+{
+	spi_unregister_driver(&gv7601_spi);
+}
+
+
+
+
+
+
+module_init(gv7601_init);
+module_exit(gv7601_exit);
+MODULE_LICENSE("GPL");
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/gv7601.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/gv7601.h	2012-09-23 16:05:57.000322027 -0600
@@ -0,0 +1,171 @@
+#ifndef _GV7601_H
+#define _GV7601_H
+
+
+#ifdef __KERNEL__
+#include <linux/spi/spi.h>
+#include <linux/device.h>
+#include <linux/videodev.h>
+#include <linux/videodev2.h>
+#endif				/* __KERNEL__ */
+
+#include <media/davinci/videohd.h> // For HD std (V4L2_STD_1080I, etc)
+
+typedef enum {
+     GV7601_VID_STD_1920_1080_60FPS = 0x2B,
+     GV7601_VID_STD_1920_1080_50FPS = 0x2D,
+     GV7601_VID_STD_1920_1080_60FPS_DBLSAMPLED = 0x2A,
+     GV7601_VID_STD_1920_1080_50FPS_DBLSAMPLED = 0x2C,
+     GV7601_VID_STD_1280_720_60FPS = 0x20,
+     GV7601_VID_STD_1280_720_50FPS = 0x24,
+
+     GV7601_VID_STD_1920_1080_30FPS = 0x0B,
+     GV7601_VID_STD_1920_1080_25FPS = 0x0D,
+} gv7601_vid_std_t;
+
+
+#define GV7601_NUM_CHANNELS  1
+
+#define GV7601_MAX_NO_CONTROLS  0
+#define GV7601_MAX_NO_INPUTS    1
+#define GV7601_MAX_NO_STANDARDS 11
+
+
+/* Video core registers */
+
+#define GV7601_REG_VIDEO_CONFIG           0x00
+
+#define GV7601_REG_VIDEO_CONFIG_TRS_REMAP_DISABLE_MASK       0x4000
+#define GV7601_REG_VIDEO_CONFIG_EDH_FLAG_DISABLE_MASK        0x1000
+#define GV7601_REG_VIDEO_CONFIG_EDH_CRC_DISABLE_MASK         0x0800
+#define GV7601_REG_VIDEO_CONFIG_H_CONFIG_MASK                0x0400 /* 1=TRS-based blanking, 0=active-line blanking */
+
+#define GV7601_REG_VIDEO_CONFIG_ANC_DATA_DISABLE_MASK        0x0200
+#define GV7601_REG_VIDEO_CONFIG_AUDIO_DISABLE_MASK           0x0100
+#define GV7601_REG_VIDEO_CONFIG_861_PIN_DISABLE_MASK         0x0080
+#define GV7601_REG_VIDEO_CONFIG_TIMING_861_MASK              0x0040 /* 1=CEA-861 timing, 0=F/V/H timing */
+#define GV7601_REG_VIDEO_CONFIG_ILLEGAL_REMAP_DISABLE_MASK   0x0010
+#define GV7601_REG_VIDEO_CONFIG_ANC_CRC_DISABLE_MASK         0x0008
+#define GV7601_REG_VIDEO_CONFIG_CRC_INS_DISABLE_MASK         0x0004
+#define GV7601_REG_VIDEO_CONFIG_LINENUM_INS_DISABLE_MASK     0x0002
+#define GV7601_REG_VIDEO_CONFIG_TRS_INS_DISABLE_MASK         0x0001
+
+
+
+
+#define GV7601_REG_ERROR_STATUS_LATCHED   0x02
+
+
+#define GV7601_REG_VID_STD_DETECT         0x06
+
+#define GV7601_REG_VID_STD_DETECT_MASK    0x3f00
+#define GV7601_REG_VID_STD_DETECT_SHIFT        8
+
+#define GV7601_REG_STAT_2_1_0_CONFIG      0x08
+#define GV7601_REG_STAT_5_4_3_CONFIG      0x09
+
+#define GV7601_STAT_CONFIG_HORIZ          0x00 // horiz blank signal or HSYNC
+#define GV7601_STAT_CONFIG_VERT           0x01 // vert blank signal or VSYNC
+#define GV7601_STAT_CONFIG_F_DE           0x02 // field signal or DE
+#define GV7601_STAT_CONFIG_LOCKED         0x03 // locked indication
+#define GV7601_STAT_Y_ANC                 0x04 // Luma anciallary indication
+#define GV7601_STAT_C_ANC                 0x05 // Chroma anciallary indication
+#define GV7601_STAT_DATA_ERROR            0x06 // Data error
+#define GV7601_STAT_VIDEO_ERROR           0x07 // Video error
+#define GV7601_STAT_AUDIO_ERROR           0x08 // Audio error
+#define GV7601_STAT_EDH_DETECT            0x09 // EDH detected
+#define GV7601_STAT_CARRIER_DETECT        0x0A // Carrier detected
+#define GV7601_STAT_RATE_DET0             0x0B // Rate detect bit 0
+#define GV7601_STAT_RATE_DET1             0x0C // Rate detect bit 1
+
+#define GV7601_REG_ANC_CONFIG             0x0a
+
+#define GV7601_ANC_CONFIG_ANC_DATA_SWITCH 0x08
+
+#define GV7601_REG_ANC_LINEA              0x0b
+#define GV7601_REG_ANC_LINEB              0x0c
+#define GV7601_REG_ANC_TYPE1              0x0f
+#define GV7601_REG_ANC_TYPE2              0x10
+#define GV7601_REG_ANC_TYPE3              0x11
+#define GV7601_REG_ANC_TYPE4              0x12
+#define GV7601_REG_ANC_TYPE5              0x13
+
+#define GV7601_REG_WORDS_PER_ACTLINE      0x1f // words per active line
+#define GV7601_REG_WORDS_PER_ACTLINE_MASK 0x3fff
+
+#define GV7601_REG_WORDS_PER_LINE         0x20 // words per line (including blanking)
+#define GV7601_REG_WORDS_PER_LINE_MASK    0x3fff
+
+#define GV7601_REG_LINES_PER_FRAME        0x21 // lines per frame (including blanking)
+#define GV7601_REG_LINES_PER_FRAME_MASK   0x7ff
+
+#define GV7601_REG_STD_LOCK               0x22
+
+#define GV7601_REG_STD_LOCK_RATESEL_MASK  0xc000
+
+#define GV7601_REG_STD_LOCK_RATESEL_HD     0x0000
+#define GV7601_REG_STD_LOCK_RATESEL_SD1    0x1000
+#define GV7601_REG_STD_LOCK_RATESEL_FULLHD 0x2000
+#define GV7601_REG_STD_LOCK_RATESEL_SD2    0x3000
+
+#define GV7601_REG_STD_LOCK_RATESEL_SHIFT     14
+#define GV7601_REG_STD_LOCK_M_MASK        0x2000
+#define GV7601_REG_STD_LOCK_M_SHIFT           13
+#define GV7601_REG_STD_LOCK_MASK          0x1000
+#define GV7601_REG_STD_LOCK_SHIFT             12
+#define GV7601_REG_STD_LOCK_INT_PROG_MASK  0x0800
+#define GV7601_REG_STD_LOCK_INT_PROG_SHIFT     11
+
+#define GV7601_REG_STD_LOCK_ACT_LINES_MASK 0x7ff
+
+#define GV7601_REG_HVLOCK                 0x23
+#define GV7601_REG_HVLOCK_VLOCK_MASK      0x0002
+#define GV7601_REG_HVLOCK_HLOCK_MASK      0x0001
+
+#define GV7601_REG_SYNC_POL                   0x26
+#define GV7601_REG_SYNC_POL_VSYNC_INV_MASK    0x0004
+#define GV7601_REG_SYNC_POL_VSYNC_INV_SHIFT        2
+#define GV7601_REG_SYNC_POL_HSYNC_INV_MASK    0x0002
+#define GV7601_REG_SYNC_POL_HSYNC_INV_SHIFT        1
+#define GV7601_REG_SYNC_POL_TRS_861_MASK      0x0001 // BT.656 timing (7 extra lines of blanks) for 525i
+
+
+#define GV7601_REG_AUDIO_CONFIG                   0x39
+#define GV7601_REG_AUDIO_CONFIG_SCLK_INV_MASK   0x0010
+#define GV7601_REG_AUDIO_CONFIG_SCLK_INV_SHIFT       4
+#define GV7601_REG_AUDIO_CONFIG_MCLK_INV_MASK   0x0008
+#define GV7601_REG_AUDIO_CONFIG_MCLK_INV_SHIFT       3
+
+#define GV7601_REG_AUDIO_CONFIG_MCLK_SEL_MASK   0x0003
+#define GV7601_REG_AUDIO_CONFIG_MCLK_SEL_128FS  0x0000
+#define GV7601_REG_AUDIO_CONFIG_MCLK_SEL_256FS  0x0001
+#define GV7601_REG_AUDIO_CONFIG_MCLK_SEL_512FS  0x0002
+
+#define GV7601_REG_DRIVE_STRENGTH                 0x6d
+
+#define GV7601_REG_DRIVE_STRENGTH_4MA             0x00
+#define GV7601_REG_DRIVE_STRENGTH_6MA             0x01
+#define GV7601_REG_DRIVE_STRENGTH_8MA             0x02
+#define GV7601_REG_DRIVE_STRENGTH_10MA            0x03
+
+/* HD Audio registers - regs 0x200-0x297*/
+
+#define GV7601_REG_HD_AUDIO_CONFIG                0x200
+
+#define GV7601_REG_HD_AUDIO_MUTE                  0x205
+#define GV7601_REG_HD_AUDIO_STATUS                0x206
+
+
+/* SD Audio registers - regs 0x400-0x496*/
+
+#define GV7601_REG_SD_AUDIO_MUTE                  0x400
+#define GV7601_REG_SD_AUDIO_STATUS                0x406
+#define GV7601_REG_SD_AUDIO_CONFIG                0x408
+
+
+/* ANC data extraction - regs 0x800-0xBFF */
+#define GV7601_ANC_BANK_REG                      0x800
+
+#define GV7601_ANC_BANK_SIZE                     0x400
+
+#endif
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/netra/Makefile
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/netra/Makefile	2012-09-23 16:05:57.000322027 -0600
@@ -0,0 +1,3 @@
+obj-m +=  netra_autodetect.o
+
+netra_autodetect-y := dummy_vpif.o
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/netra/dummy_vpif.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/netra/dummy_vpif.c	2012-09-23 16:05:57.000322027 -0600
@@ -0,0 +1,1264 @@
+/*
+ * Dummy vpif - This code emulates a real video device with v4l2 api and real subdevs
+ *
+ * Copyright (c) 2011 Z3 Technology
+ *      John Whittington <johnw@z3technology.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the BSD Licence, GNU General Public License
+ * as published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version
+ */
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/mm.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/random.h>
+#include <linux/version.h>
+#include <linux/mutex.h>
+#include <linux/videodev2.h>
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/kthread.h>
+#include <linux/highmem.h>
+#include <linux/freezer.h>
+#include <linux/i2c.h>
+
+#include <media/videobuf-vmalloc.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-chip-ident.h>
+#include <media/tvp7002.h>
+
+#include <mach/z3_fpga.h>
+#include <mach/z3_app.h>
+
+#include "../adv9880.h"
+
+#define Z3NETRA_MODULE_NAME "z3netra"
+
+#define NUM_INPUTS         8
+
+#define MAX_SUBDEVS        8
+
+#define VPIF_MAX_I2C_ADAPTERS 2
+
+#define VIVI_MAJOR_VERSION 0
+#define VIVI_MINOR_VERSION 6
+#define VIVI_RELEASE 0
+#define VIVI_VERSION \
+	KERNEL_VERSION(VIVI_MAJOR_VERSION, VIVI_MINOR_VERSION, VIVI_RELEASE)
+
+MODULE_DESCRIPTION("Video Technology Magazine Virtual Video Capture Board");
+MODULE_AUTHOR("Mauro Carvalho Chehab, Ted Walther and John Sokol");
+MODULE_LICENSE("Dual BSD/GPL");
+
+static unsigned video_nr = 0;
+module_param(video_nr, uint, 0644);
+MODULE_PARM_DESC(video_nr, "videoX start number, -1 is autodetect");
+
+static unsigned n_devs = 1;
+module_param(n_devs, uint, 0644);
+MODULE_PARM_DESC(n_devs, "number of video devices to create");
+
+static unsigned debug = 1;
+module_param(debug, uint, 0644);
+MODULE_PARM_DESC(debug, "activates debug info");
+
+static unsigned int vid_limit = 16;
+module_param(vid_limit, uint, 0644);
+MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
+
+
+/* supported controls */
+static struct v4l2_queryctrl vivi_qctrl[] = {
+	{
+		.id            = V4L2_CID_AUDIO_VOLUME,
+		.name          = "Volume",
+		.minimum       = 0,
+		.maximum       = 65535,
+		.step          = 65535/100,
+		.default_value = 65535,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+	}, {
+		.id            = V4L2_CID_BRIGHTNESS,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Brightness",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 1,
+		.default_value = 127,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	}, {
+		.id            = V4L2_CID_CONTRAST,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Contrast",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 0x1,
+		.default_value = 0x10,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	}, {
+		.id            = V4L2_CID_SATURATION,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Saturation",
+		.minimum       = 0,
+		.maximum       = 255,
+		.step          = 0x1,
+		.default_value = 127,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	}, {
+		.id            = V4L2_CID_HUE,
+		.type          = V4L2_CTRL_TYPE_INTEGER,
+		.name          = "Hue",
+		.minimum       = -128,
+		.maximum       = 127,
+		.step          = 0x1,
+		.default_value = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
+	}
+};
+
+#define dprintk(dev, level, fmt, arg...) \
+	v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
+
+/* ------------------------------------------------------------------
+	Basic structures
+   ------------------------------------------------------------------*/
+
+
+#if defined( CONFIG_VIDEO_ADV9880 ) || defined( CONFIG_VIDEO_ADV9880_MODULE )
+
+/* Inputs available at the ADV9880 */
+static struct v4l2_input adv9880_1_inputs[] = {
+     {
+          .index = 0,
+          .name = "COMPONENT",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ADV9880_ALL
+     },
+     {
+          .index = 1,
+          .name = "HDMI",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ADV9880_ALL
+     },
+};
+
+/* Inputs available at the ADV9880 */
+static struct v4l2_input adv9880_2_inputs[] = {
+     {
+          .index = 0,
+          .name = "COMPONENT",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ADV9880_ALL
+     },
+     {
+          .index = 1,
+          .name = "HDMI",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ADV9880_ALL
+     },
+};
+#endif
+
+#if defined( CONFIG_VIDEO_ADV7611 ) || defined( CONFIG_VIDEO_ADV7611_MODULE )
+
+/* Inputs available at the ADV7611 */
+static struct v4l2_input adv7611_4c_inputs[] = {
+     {
+          .index = 0,
+          .name = "HDMI1",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ADV9880_ALL | V4L2_STD_VESA_ALL
+     },
+};
+static struct v4l2_input adv7611_4d_inputs[] = {
+     {
+          .index = 1,
+          .name = "HDMI2",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ADV9880_ALL | V4L2_STD_VESA_ALL
+     },
+};
+
+#endif
+
+#if defined( CONFIG_VIDEO_TVP7002 ) || defined( CONFIG_VIDEO_TVP7002_MODULE )
+
+/* Inputs available at the TVP7002 */
+static struct v4l2_input tvp7002_5c_inputs[] = {
+     {
+          .index = 0,
+          .name = "COMPONENT1",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ADV9880_ALL
+     },
+};
+static struct v4l2_input tvp7002_5d_inputs[] = {
+     {
+          .index = 1,
+          .name = "COMPONENT2",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ADV9880_ALL
+     },
+};
+
+static struct tvp7002_config  tvp7002_config = {
+	.clk_polarity  = 0,
+        .hs_polarity   = 0,
+        .vs_polarity   = 0,
+        .fid_polarity  = 0,
+        .sog_polarity  = 0,
+};
+
+#endif
+
+
+ #if defined( CONFIG_VIDEO_GV7601 ) || defined( CONFIG_VIDEO_GV7601_MODULE )
+
+static struct v4l2_input gv7601_inputs[] = {
+     {
+          .index = 0,
+          .name = "HD-SDI",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ADV9880_ALL
+     },
+};
+
+#endif
+
+
+#if defined( CONFIG_VIDEO_TVP5150 ) || defined( CONFIG_VIDEO_TVP5150_MODULE )
+
+/* Inputs available at the TVP5150 */
+static struct v4l2_input tvp5150_5c_inputs[] = {
+     {
+          .index = 0,
+          .name = "COMPOSITE1",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ALL
+     },
+};
+static struct v4l2_input tvp5150_5d_inputs[] = {
+     {
+          .index = 1,
+          .name = "COMPOSITE2",
+          .type = V4L2_INPUT_TYPE_CAMERA,
+          .std = V4L2_STD_ALL
+     },
+};
+#endif
+
+struct vivi_fmt {
+	char  *name;
+	u32   fourcc;          /* v4l2 format id */
+	int   depth;
+};
+
+static struct vivi_fmt formats[] = {
+	{
+		.name     = "4:2:2, packed, YUYV",
+		.fourcc   = V4L2_PIX_FMT_YUYV,
+		.depth    = 16,
+	},
+	{
+		.name     = "4:2:2, packed, UYVY",
+		.fourcc   = V4L2_PIX_FMT_UYVY,
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB565 (LE)",
+		.fourcc   = V4L2_PIX_FMT_RGB565, /* gggbbbbb rrrrrggg */
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB565 (BE)",
+		.fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB555 (LE)",
+		.fourcc   = V4L2_PIX_FMT_RGB555, /* gggbbbbb arrrrrgg */
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB555 (BE)",
+		.fourcc   = V4L2_PIX_FMT_RGB555X, /* arrrrrgg gggbbbbb */
+		.depth    = 16,
+	},
+};
+
+struct sg_to_addr {
+	int pos;
+	struct scatterlist *sg;
+};
+
+/* buffer for one video frame */
+struct vivi_buffer {
+	/* common v4l buffer stuff -- must be first */
+	struct videobuf_buffer vb;
+
+	struct vivi_fmt        *fmt;
+};
+
+struct vivi_dmaqueue {
+	struct list_head       active;
+
+	/* thread for generating video stream*/
+	struct task_struct         *kthread;
+	wait_queue_head_t          wq;
+	/* Counters to control fps rate */
+	int                        frame;
+	int                        ini_jiffies;
+};
+
+static LIST_HEAD(vpif_devlist);
+
+struct vpif_dev {
+	struct list_head           vpif_devlist;
+	struct v4l2_device 	   v4l2_dev;
+
+	spinlock_t                 slock;
+	struct mutex		   mutex;
+
+	int                        users;
+
+	/* various device info */
+	struct video_device        *vfd;
+
+	struct vivi_dmaqueue       vidq;
+
+	/* Several counters */
+	int                        h, m, s, ms;
+	unsigned long              jiffies;
+	char                       timestr[13];
+
+	int			   mv_count;	/* Controls bars movement */
+
+	/* Input Number */
+	int			   input;
+
+	/* Number of sub devices connected to vpfe */
+	int num_subdevs;
+	/* i2c bus adapter no */
+	struct i2c_adapter *i2c_adaps[VPIF_MAX_I2C_ADAPTERS];
+	/* information about each subdev */
+	struct vpfe_subdev_info *sub_devs;
+
+	/* sub devices */
+	struct v4l2_subdev **sd;
+
+	struct vpfe_subdev_info *current_subdev;
+	/* current input at the sub device */
+	int current_input;
+
+	/* Control 'registers' */
+	int 			   qctl_regs[ARRAY_SIZE(vivi_qctrl)];
+};
+
+struct vivi_fh {
+	struct vpif_dev            *dev;
+
+	/* video capture */
+	struct vivi_fmt            *fmt;
+	unsigned int               width, height;
+	struct videobuf_queue      vb_vidq;
+
+	enum v4l2_buf_type         type;
+	unsigned char              bars[8][3];
+	int			   input; 	/* Input Number on bars */
+};
+
+
+struct vpfe_subdev_info {
+	/* Sub device name */
+	char name[32];
+	/* Sub device group id (same if decoders share video port) */
+	int grp_id;
+	/* Number of inputs supported */
+	int num_inputs;
+	/* inputs available at the sub device */
+	struct v4l2_input *inputs;
+	/* i2c data */
+	struct i2c_board_info i2c_board_info;
+        struct i2c_adapter *i2c_adap;
+        /* spi data */
+        struct spi_board_info spi_board_info;
+        struct spi_master *spi_master;
+
+         /* Which V4L2 subdev */
+        struct v4l2_subdev *v4l2_sd;
+ };
+
+ /*
+  * vpfe_get_subdev_input_index - Get subdev index and subdev input index for a
+  * given app input index
+  */
+ static int vpfe_get_subdev_input_index(struct vpif_dev *vpif_dev,
+                                         int *subdev_index,
+                                         int *subdev_input_index,
+                                         int app_input_index)
+ {
+         struct vpfe_subdev_info *sdinfo;
+         int i, j = 0;
+
+         for (i = 0; i < vpif_dev->num_subdevs; i++) {
+                 sdinfo = &vpif_dev->sub_devs[i];
+                 if (app_input_index < (j + sdinfo->num_inputs)) {
+                         *subdev_index = i;
+                         *subdev_input_index = app_input_index - j;
+                         return 0;
+                 }
+                 j += sdinfo->num_inputs;
+         }
+         return -EINVAL;
+ }
+
+ static struct dv_preset_entry {
+         int          preset;
+         v4l2_std_id  id;
+ } dv_presets_table[] = {
+         { V4L2_DV_480P59_94, V4L2_STD_525P_60 },
+         { V4L2_DV_576P50,    V4L2_STD_625P_50 },
+
+         { V4L2_DV_720P25,    V4L2_STD_720P_25 },
+         { V4L2_DV_720P24,    V4L2_STD_720P_25 },
+         { V4L2_DV_720P50,    V4L2_STD_720P_50 },
+         { V4L2_DV_1080I29_97,V4L2_STD_1080I_60|V4L2_STD_HD_DIV_1001 },
+         { V4L2_DV_720P59_94, V4L2_STD_720P_60|V4L2_STD_HD_DIV_1001 },
+         { V4L2_DV_720P60,    V4L2_STD_720P_60 },
+
+         { V4L2_DV_1080I60,   V4L2_STD_1080I_60 },
+         { V4L2_DV_1080I30,   V4L2_STD_1080I_60 },
+         { V4L2_DV_1080I29_97,   V4L2_STD_1080I_60|V4L2_STD_HD_DIV_1001 },
+         { V4L2_DV_1080I50,   V4L2_STD_1080I_50 },
+         { V4L2_DV_1080I25,   V4L2_STD_1080I_50 },
+
+         { V4L2_DV_1080P24,   V4L2_STD_1080P_24 },
+         { V4L2_DV_1080P25,   V4L2_STD_1080P_25 },
+         { V4L2_DV_1080P30,   V4L2_STD_1080P_30 },
+         { V4L2_DV_1080P50,   V4L2_STD_1080P_50 },
+         { V4L2_DV_1080P60,   V4L2_STD_1080P_60 },
+
+         { V4L2_DV_INVALID,    V4L2_STD_UNKNOWN },
+ };
+
+ static v4l2_std_id vpif_convert_dvpreset_to_std(int preset)
+ {
+         struct dv_preset_entry *entry;
+
+         for ( entry = &dv_presets_table[0];
+               entry->preset != V4L2_DV_INVALID;
+               entry++ ) {
+                 if ( entry->preset == preset )
+                         break;
+         }
+
+         return entry->id;
+ }
+
+ static int vpif_convert_std_to_dvpreset(v4l2_std_id id)
+ {
+         struct dv_preset_entry *entry;
+
+         for ( entry = &dv_presets_table[0];
+               entry->preset != V4L2_DV_INVALID;
+               entry++ ) {
+                 if ( entry->id == id )
+                         break;
+         }
+
+         return entry->preset;
+ }
+
+
+ static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *std_id)
+ {
+         struct vivi_fh *fh = priv;
+         struct vpif_dev *dev = fh->dev;
+         struct vpfe_subdev_info *sdinfo;
+         struct v4l2_subdev *sd;
+         int subdev, index ;
+         int ret = 0;
+
+
+         v4l2_dbg(1, debug, &dev->v4l2_dev, "dummy_vpif_s_std\n");
+
+
+         ret = mutex_lock_interruptible(&dev->mutex);
+         if (ret)
+                 return ret;
+
+         if (vpfe_get_subdev_input_index(dev,
+                                         &subdev,
+                                         &index,
+                                         dev->input) < 0) {
+              v4l2_dbg(1, debug, &dev->v4l2_dev, "input information not found"
+                          " for the subdev\n");
+              ret = -EINVAL;
+              goto unlock_out;
+         }
+         sdinfo = &dev->sub_devs[subdev];
+         sd = sdinfo->v4l2_sd;
+
+         if ( sd->ops->core ) {
+                 if ( sd->ops->core->s_std ) {
+                         ret = sd->ops->core->s_std(sd, *std_id);
+                 }
+                 else if ( sd->ops->video && sd->ops->video->s_dv_preset ) {
+                         struct v4l2_dv_preset dv_preset;
+
+                         memset( &dv_preset, '\0', sizeof(dv_preset) );
+                         dv_preset.preset = vpif_convert_std_to_dvpreset( *std_id );
+                         ret = sd->ops->video->s_dv_preset(sd, &dv_preset);
+                 }
+         }
+
+         if (ret) {
+                 v4l2_err(&dev->v4l2_dev,
+                         "vpfe_doioctl:error in setting std in decoder\n");
+                 ret = -EINVAL;
+                 goto unlock_out;
+         }
+
+
+         /* Start streaming */
+         ret = v4l2_device_call_until_err(&dev->v4l2_dev, sdinfo->grp_id,
+                                          video, s_stream, __sd == sdinfo->v4l2_sd);
+
+         if (ret) {
+                 v4l2_err(&dev->v4l2_dev,
+                         "vpfe_doioctl:error in setting streaming in decoder\n");
+                 ret = -EINVAL;
+                 goto unlock_out;
+         } else {
+                 switch (sdinfo->grp_id)
+                 {
+                 case 1:
+                         z3_fpga_set_pll_vidin_reference(Z3_FPGA_PLL_VIDIN0_REFERENCE);
+                         break;
+                 case 2:
+                         z3_fpga_set_pll_vidin_reference(Z3_FPGA_PLL_VIDIN1_REFERENCE);
+                         break;
+                 }
+         }
+
+
+ unlock_out:
+         mutex_unlock(&dev->mutex);
+         return ret;
+ }
+
+
+
+ /* only one input in this sample driver */
+ static int vidioc_enum_input(struct file *file, void *priv,
+                                 struct v4l2_input *inp)
+ {
+         struct vpif_dev *vpif_dev = video_drvdata(file);
+         struct vpfe_subdev_info *sdinfo;
+         int subdev, index ;
+
+         v4l2_dbg(1, debug, &vpif_dev->v4l2_dev, "vpfe_enum_input\n");
+
+         if (vpfe_get_subdev_input_index(vpif_dev,
+                                         &subdev,
+                                         &index,
+                                         inp->index) < 0) {
+              v4l2_dbg(1, debug, &vpif_dev->v4l2_dev, "input information not found"
+                          " for the subdev\n");
+                 return -EINVAL;
+         }
+         sdinfo = &vpif_dev->sub_devs[subdev];
+         sdinfo->inputs[index].index = inp->index;
+         memcpy(inp, &sdinfo->inputs[index], sizeof(struct v4l2_input));
+         return 0;
+ }
+
+ static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
+ {
+         struct vivi_fh *fh = priv;
+         struct vpif_dev *dev = fh->dev;
+
+         *i = dev->input;
+
+         return (0);
+ }
+
+ static int vidioc_s_input(struct file *file, void *priv, unsigned int input_index)
+ {
+         struct vivi_fh *fh = priv;
+         struct vpif_dev *dev = fh->dev;
+         struct vpfe_subdev_info *sdinfo = NULL;
+         int subdev, index ;
+         int ret = 0;
+
+         v4l2_dbg(1, debug, &dev->v4l2_dev, "vpfe_s_input %d\n", input_index);
+
+         if (input_index >= NUM_INPUTS)
+                 return -EINVAL;
+
+
+         ret = mutex_lock_interruptible(&dev->mutex);
+         if (ret)
+                 return ret;
+
+         if (vpfe_get_subdev_input_index(dev,
+                                         &subdev,
+                                         &index,
+                                         input_index) < 0) {
+              v4l2_dbg(1, debug, &dev->v4l2_dev, "input information not found"
+                          " for the subdev\n");
+              ret = -EINVAL;
+              goto unlock_out;
+         }
+         sdinfo = &dev->sub_devs[subdev];
+
+         dev->input = input_index;
+         dev->current_subdev = sdinfo;
+
+ unlock_out:
+         mutex_unlock(&dev->mutex);
+         return ret;
+ }
+
+ static int vidioc_g_ctrl(struct file *file, void *priv,
+                          struct v4l2_control *ctrl)
+ {
+         struct vivi_fh *fh = priv;
+         struct vpif_dev *vpif_dev = fh->dev;
+         struct vpfe_subdev_info *sdinfo = NULL;
+         struct v4l2_subdev *sd = NULL;
+         int ret = 0;
+
+         v4l2_dbg(1, debug, &vpif_dev->v4l2_dev, "dummy_vpif_g_ctrl\n");
+
+         ret = mutex_lock_interruptible(&vpif_dev->mutex);
+         if (ret)
+                 return ret;
+
+         ret = -ENOSYS;
+
+         sdinfo = vpif_dev->current_subdev;
+         if ( sdinfo ) {
+                 sd = sdinfo->v4l2_sd;
+         }
+
+         if ( sd
+              && sd->ops
+              && sd->ops->core ) {
+                 if ( sd->ops->core->g_ctrl ) {
+                         ret = sd->ops->core->g_ctrl(sd, ctrl);
+                 }
+         }
+
+ unlock_out:
+         mutex_unlock(&vpif_dev->mutex);
+         return ret;
+ }
+
+
+ static int vidioc_s_ctrl(struct file *file, void *priv,
+                                 struct v4l2_control *ctrl)
+ {
+         struct vivi_fh *fh = priv;
+         struct vpif_dev *vpif_dev = fh->dev;
+         struct vpfe_subdev_info *sdinfo = NULL;
+         struct v4l2_subdev *sd = NULL;
+         int ret = 0;
+
+         v4l2_dbg(1, debug, &vpif_dev->v4l2_dev, "dummy_vpif_s_ctrl\n");
+
+         ret = mutex_lock_interruptible(&vpif_dev->mutex);
+         if (ret)
+                 return ret;
+
+         ret = -ENOSYS;
+
+         sdinfo = vpif_dev->current_subdev;
+         if ( sdinfo ) {
+                 sd = sdinfo->v4l2_sd;
+         }
+
+         if ( sd
+              && sd->ops
+              && sd->ops->core ) {
+                 if ( sd->ops->core->s_ctrl ) {
+                         ret = sd->ops->core->s_ctrl(sd, ctrl);
+                 }
+         }
+
+ unlock_out:
+         mutex_unlock(&vpif_dev->mutex);
+         return ret;
+ }
+
+ static int vidioc_querystd(struct file *file, void *priv, v4l2_std_id *std_id)
+ {
+         struct vpif_dev *vpif_dev = video_drvdata(file);
+         struct vpfe_subdev_info *sdinfo;
+         int ret = 0;
+
+         struct v4l2_subdev *sd;
+
+         v4l2_dbg(1, debug, &vpif_dev->v4l2_dev, "vpfe_querystd\n");
+
+         ret = mutex_lock_interruptible(&vpif_dev->mutex);
+         if (ret)
+                 return ret;
+
+         sdinfo = vpif_dev->current_subdev;
+         sd = sdinfo->v4l2_sd;
+
+         /* Call querystd function of decoder device */
+
+         if ( sd->ops->video ) {
+                 if ( sd->ops->video->querystd ) {
+                         ret = sd->ops->video->querystd(sd, std_id);
+                 }
+                 else if ( sd->ops->video->query_dv_preset ) {
+                         struct v4l2_dv_preset qdvpreset;
+
+                         ret = sd->ops->video->query_dv_preset(sd, &qdvpreset);
+
+                         if ( 0 == ret ) {
+                                 *std_id = vpif_convert_dvpreset_to_std( qdvpreset.preset );
+                                 if ( *std_id == V4L2_STD_UNKNOWN ) {
+                                         ret = -EINVAL;
+                                 }
+                         }
+                 }
+         }
+
+         ret = (ret == -ENOIOCTLCMD) ? 0 : ret;
+
+         mutex_unlock(&vpif_dev->mutex);
+         return ret;
+ }
+
+
+ /* ------------------------------------------------------------------
+         File operations for the device
+    ------------------------------------------------------------------*/
+
+ static int vivi_open(struct file *file)
+ {
+         struct vpif_dev *dev = video_drvdata(file);
+         struct vivi_fh *fh = NULL;
+         int retval = 0;
+
+         mutex_lock(&dev->mutex);
+         dev->users++;
+
+         if (dev->users > 1) {
+                 dev->users--;
+                 mutex_unlock(&dev->mutex);
+                 return -EBUSY;
+         }
+
+         dprintk(dev, 1, "open %s type=%s users=%d\n",
+                 video_device_node_name(dev->vfd),
+                 v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
+
+         /* allocate + initialize per filehandle data */
+         fh = kzalloc(sizeof(*fh), GFP_KERNEL);
+         if (NULL == fh) {
+                 dev->users--;
+                 retval = -ENOMEM;
+         }
+         mutex_unlock(&dev->mutex);
+
+         if (retval)
+                 return retval;
+
+         file->private_data = fh;
+         fh->dev      = dev;
+
+         fh->type     = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+         fh->fmt      = &formats[0];
+         fh->width    = 640;
+         fh->height   = 480;
+
+         /* Resets frame counters */
+         dev->h = 0;
+         dev->m = 0;
+         dev->s = 0;
+         dev->ms = 0;
+         dev->mv_count = 0;
+         dev->jiffies = jiffies;
+         sprintf(dev->timestr, "%02d:%02d:%02d:%03d",
+                         dev->h, dev->m, dev->s, dev->ms);
+
+         return 0;
+ }
+
+ static int vivi_close(struct file *file)
+ {
+         struct vivi_fh         *fh = file->private_data;
+         struct vpif_dev *dev       = fh->dev;
+ //	struct vivi_dmaqueue *vidq = &dev->vidq;
+         struct video_device  *vdev = video_devdata(file);
+
+         kfree(fh);
+
+         mutex_lock(&dev->mutex);
+         dev->users--;
+         mutex_unlock(&dev->mutex);
+
+         dprintk(dev, 1, "close called (dev=%s, users=%d)\n",
+                 video_device_node_name(vdev), dev->users);
+
+         return 0;
+ }
+
+ static const struct v4l2_file_operations vivi_fops = {
+         .owner		= THIS_MODULE,
+         .open           = vivi_open,
+         .release        = vivi_close,
+         .read           = NULL,
+         .poll		= NULL,
+         .ioctl          = video_ioctl2, /* V4L2 ioctl handler */
+         .mmap           = NULL,
+ };
+
+ static const struct v4l2_ioctl_ops vivi_ioctl_ops = {
+ //	.vidioc_querycap      = vidioc_querycap,
+ //	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+ //	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+ //	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+ //	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+ //	.vidioc_reqbufs       = vidioc_reqbufs,
+ //	.vidioc_querybuf      = vidioc_querybuf,
+ //	.vidioc_qbuf          = vidioc_qbuf,
+ //	.vidioc_dqbuf         = vidioc_dqbuf,
+         .vidioc_s_std         = vidioc_s_std,
+         .vidioc_enum_input    = vidioc_enum_input,
+         .vidioc_g_input       = vidioc_g_input,
+         .vidioc_s_input       = vidioc_s_input,
+ //	.vidioc_queryctrl     = vidioc_queryctrl,
+         .vidioc_querystd      = vidioc_querystd,
+         .vidioc_g_ctrl        = vidioc_g_ctrl,
+         .vidioc_s_ctrl        = vidioc_s_ctrl,
+ //	.vidioc_streamon      = vidioc_streamon,
+ //	.vidioc_streamoff     = vidioc_streamoff,
+ #ifdef CONFIG_VIDEO_V4L1_COMPAT
+ //	.vidiocgmbuf          = vidiocgmbuf,
+ #endif
+ };
+
+ static struct video_device vivi_template = {
+         .name		= "dummy_vpif",
+         .fops           = &vivi_fops,
+         .ioctl_ops 	= &vivi_ioctl_ops,
+         .release	= video_device_release,
+
+         .tvnorms              = V4L2_STD_ADV9880_ALL | V4L2_STD_VESA_ALL,
+         .current_norm         = V4L2_STD_NTSC_M,
+ };
+
+ /* -----------------------------------------------------------------
+         Initialization and module stuff
+    ------------------------------------------------------------------*/
+
+ static int vivi_release(void)
+ {
+         struct vpif_dev *dev;
+         struct list_head *list;
+         int    i;
+
+         while (!list_empty(&vpif_devlist)) {
+                 list = vpif_devlist.next;
+                 list_del(list);
+                 dev = list_entry(list, struct vpif_dev, vpif_devlist);
+
+                 v4l2_info(&dev->v4l2_dev, "unregistering %s\n",
+                         video_device_node_name(dev->vfd));
+                 video_unregister_device(dev->vfd);
+                 v4l2_device_unregister(&dev->v4l2_dev);
+
+                 for ( i=0; i<VPIF_MAX_I2C_ADAPTERS; i++ ) {
+                         if ( dev->i2c_adaps[i] != NULL ) {
+                                 i2c_put_adapter( dev->i2c_adaps[i] );
+                         }
+                 }
+                 kfree(dev);
+         }
+
+         return 0;
+ }
+
+
+
+ static int __init vivi_create_instance(int inst)
+ {
+         struct vpif_dev *dev;
+         struct video_device *vfd;
+         struct vpfe_subdev_info *sdinfo;
+         int ret, i;
+         int num_subdevs = 0;
+         int i2c_adapter_id = 0;
+
+         u16 z3_board_id = z3_fpga_board_id();
+
+         dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+         if (!dev)
+                 return -ENOMEM;
+
+         snprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),
+                         "%s-%03d", Z3NETRA_MODULE_NAME, inst);
+         ret = v4l2_device_register(NULL, &dev->v4l2_dev);
+         if (ret)
+                 goto free_dev;
+
+         /* init video dma queues */
+         INIT_LIST_HEAD(&dev->vidq.active);
+         init_waitqueue_head(&dev->vidq.wq);
+
+         /* initialize locks */
+         spin_lock_init(&dev->slock);
+         mutex_init(&dev->mutex);
+
+         ret = -ENOMEM;
+         vfd = video_device_alloc();
+         if (!vfd)
+                 goto unreg_dev;
+
+         *vfd = vivi_template;
+         vfd->debug = debug;
+
+         ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);
+         if (ret < 0)
+                 goto rel_vdev;
+
+         video_set_drvdata(vfd, dev);
+
+
+         dev->sd = kzalloc(sizeof(struct v4l2_subdev *) * MAX_SUBDEVS,
+                           GFP_KERNEL);
+         if (NULL == dev->sd) {
+                 v4l2_err(&dev->v4l2_dev,
+                         "unable to allocate memory for subdevice pointers\n");
+                 ret = -ENOMEM;
+                 goto rel_vdev;
+         }
+
+         dev->sub_devs = kzalloc(sizeof(dev->sub_devs[0]) * MAX_SUBDEVS,
+                           GFP_KERNEL);
+         if (NULL == dev->sd) {
+                 v4l2_err(&dev->v4l2_dev,
+                         "unable to allocate memory for subdevice pointers\n");
+                 ret = -ENOMEM;
+                 goto probe_sd_out;
+         }
+
+
+         for ( i2c_adapter_id = 1;
+               i2c_adapter_id <= VPIF_MAX_I2C_ADAPTERS;
+               i2c_adapter_id++ ) {
+                 dev->i2c_adaps[i2c_adapter_id-1] = i2c_get_adapter(i2c_adapter_id);
+                 if ( NULL == dev->i2c_adaps[i2c_adapter_id-1] ) {
+                         break;
+                 }
+         }
+
+
+ #if defined( CONFIG_VIDEO_ADV7611 ) || defined( CONFIG_VIDEO_ADV7611_MODULE )
+         if ( z3_board_id == Z3_BOARD_ID_NONE
+              || z3_board_id == Z3_BOARD_ID_APP_02
+              || z3_board_id == Z3_BOARD_ID_APP_21
+              || z3_board_id == Z3_BOARD_ID_APP_41
+              || z3_board_id == Z3_BOARD_ID_APP_31 ) {
+                 strcpy( dev->sub_devs[num_subdevs].name, "adv7611" );
+                 strcpy( dev->sub_devs[num_subdevs].i2c_board_info.type, "adv7611" );
+                 dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x4c;
+                 dev->sub_devs[num_subdevs].grp_id = 1;
+                 dev->sub_devs[num_subdevs].num_inputs = 1;
+                 dev->sub_devs[num_subdevs].inputs = adv7611_4c_inputs;
+                 dev->sub_devs[num_subdevs].i2c_adap = dev->i2c_adaps[0];
+                 ++num_subdevs;
+         }
+
+         if ( z3_board_id == Z3_BOARD_ID_NONE
+              || z3_board_id == Z3_BOARD_ID_APP_02
+              || z3_board_id == Z3_BOARD_ID_APP_41 ) {
+
+                 strcpy( dev->sub_devs[num_subdevs].name, "adv7611" );
+                 strcpy( dev->sub_devs[num_subdevs].i2c_board_info.type, "adv7611" );
+                 dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x4d;
+                 dev->sub_devs[num_subdevs].grp_id = 2;
+                 dev->sub_devs[num_subdevs].num_inputs = 1;
+                 dev->sub_devs[num_subdevs].inputs = adv7611_4d_inputs;
+                 dev->sub_devs[num_subdevs].i2c_adap = dev->i2c_adaps[0];
+
+                 ++num_subdevs;
+         }
+#endif
+
+#if defined( CONFIG_VIDEO_ADV9880 ) || defined( CONFIG_VIDEO_ADV9880_MODULE )
+                 if ( z3_board_id == Z3_BOARD_ID_NONE ) {
+                         /* Populate sub_devs array */
+                         strcpy( dev->sub_devs[num_subdevs].name, "adv9880" );
+                         strcpy( dev->sub_devs[num_subdevs].i2c_board_info.type, "adv9880" );
+                         dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x4c;
+                         dev->sub_devs[num_subdevs].grp_id = 1;
+                         dev->sub_devs[num_subdevs].num_inputs = 2;
+                         dev->sub_devs[num_subdevs].inputs = adv9880_1_inputs;
+                         dev->sub_devs[num_subdevs].i2c_adap = dev->i2c_adaps[0];
+
+                         ++num_subdevs;
+
+                         strcpy( dev->sub_devs[num_subdevs].name, "adv9880" );
+                         strcpy( dev->sub_devs[num_subdevs].i2c_board_info.type, "adv9880" );
+                         dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x4c;
+                         dev->sub_devs[num_subdevs].grp_id = 2;
+                         dev->sub_devs[num_subdevs].num_inputs = 2;
+                         dev->sub_devs[num_subdevs].inputs = adv9880_2_inputs;
+                         dev->sub_devs[num_subdevs].i2c_adap = dev->i2c_adaps[1];
+                 }
+                 ++num_subdevs;
+#endif
+
+#if defined( CONFIG_VIDEO_TVP7002 ) || defined( CONFIG_VIDEO_TVP7002_MODULE )
+                 if ( z3_board_id == Z3_BOARD_ID_NONE
+                      || z3_board_id == Z3_BOARD_ID_APP_02
+                      || z3_board_id == Z3_BOARD_ID_APP_31 ) {
+                         strcpy( dev->sub_devs[num_subdevs].name, "tvp7002" );
+                         strcpy( dev->sub_devs[num_subdevs].i2c_board_info.type, "tvp7002" );
+                         dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x5c;
+                         dev->sub_devs[num_subdevs].i2c_board_info.platform_data = &tvp7002_config;
+                         dev->sub_devs[num_subdevs].grp_id = 1;
+                         dev->sub_devs[num_subdevs].num_inputs = 1;
+                         dev->sub_devs[num_subdevs].inputs = tvp7002_5c_inputs;
+                         dev->sub_devs[num_subdevs].i2c_adap = dev->i2c_adaps[0];
+                         ++num_subdevs;
+                 }
+
+                 if ( z3_board_id == Z3_BOARD_ID_NONE
+                      || z3_board_id == Z3_BOARD_ID_APP_21
+                      || z3_board_id == Z3_BOARD_ID_APP_02 ) {
+
+                         strcpy( dev->sub_devs[num_subdevs].name, "tvp7002" );
+                         strcpy( dev->sub_devs[num_subdevs].i2c_board_info.type, "tvp7002" );
+                         if (  z3_board_id == Z3_BOARD_ID_APP_21 ) {
+// I2C address got changed after protos
+//                                 dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x5c;
+                                 dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x5d;
+                         } else {
+                                 dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x5d;
+                         }
+                         dev->sub_devs[num_subdevs].i2c_board_info.platform_data = &tvp7002_config;
+                         dev->sub_devs[num_subdevs].grp_id = 2;
+                         dev->sub_devs[num_subdevs].num_inputs = 1;
+                         dev->sub_devs[num_subdevs].inputs = tvp7002_5d_inputs;
+                         dev->sub_devs[num_subdevs].i2c_adap = dev->i2c_adaps[0];
+
+                         ++num_subdevs;
+                 }
+#endif
+
+
+#if defined( CONFIG_VIDEO_GV7601 ) || defined( CONFIG_VIDEO_GV7601_MODULE )
+                 if ( z3_board_id == Z3_BOARD_ID_APP_31 ) {
+                         strcpy( dev->sub_devs[num_subdevs].name, "gv7601" );
+
+                         strcpy( dev->sub_devs[num_subdevs].spi_board_info.modalias, "gv7601" );
+//                         dev->sub_devs[num_subdevs].spi_board_info.mode = SPI_MODE_1;
+                         dev->sub_devs[num_subdevs].spi_board_info.mode = SPI_MODE_3;
+                         dev->sub_devs[num_subdevs].spi_board_info.irq = 0;
+                         dev->sub_devs[num_subdevs].spi_board_info.max_speed_hz =  100 * 1000;
+                         dev->sub_devs[num_subdevs].spi_board_info.bus_num = 1;
+                         dev->sub_devs[num_subdevs].spi_board_info.chip_select = 1;
+
+                         dev->sub_devs[num_subdevs].grp_id = 2;
+                         dev->sub_devs[num_subdevs].num_inputs = 1;
+                         dev->sub_devs[num_subdevs].inputs = gv7601_inputs;
+                         dev->sub_devs[num_subdevs].spi_master =
+                                 spi_busnum_to_master(dev->sub_devs[num_subdevs].spi_board_info.bus_num);
+
+                         ++num_subdevs;
+
+
+                         strcpy( dev->sub_devs[num_subdevs].name, "gv7600" );
+
+                         strcpy( dev->sub_devs[num_subdevs].spi_board_info.modalias, "gv7600" );
+//                         dev->sub_devs[num_subdevs].spi_board_info.mode = SPI_MODE_1;
+                         dev->sub_devs[num_subdevs].spi_board_info.mode = SPI_MODE_3;
+                         dev->sub_devs[num_subdevs].spi_board_info.irq = 0;
+                         dev->sub_devs[num_subdevs].spi_board_info.max_speed_hz =  100 * 1000;
+                         dev->sub_devs[num_subdevs].spi_board_info.bus_num = 1;
+                         dev->sub_devs[num_subdevs].spi_board_info.chip_select = 0;
+
+                         dev->sub_devs[num_subdevs].grp_id = 10;
+                         dev->sub_devs[num_subdevs].num_inputs = 0;
+                         dev->sub_devs[num_subdevs].inputs = NULL;
+                         dev->sub_devs[num_subdevs].spi_master =
+                                 spi_busnum_to_master(dev->sub_devs[num_subdevs].spi_board_info.bus_num);
+
+                         ++num_subdevs;
+
+                 }
+
+#endif
+
+#if defined( CONFIG_VIDEO_TVP5150 ) || defined( CONFIG_VIDEO_TVP5150_MODULE )
+                 if ( z3_board_id == Z3_BOARD_ID_NONE
+                      || z3_board_id == Z3_BOARD_ID_APP_02 ) {
+                         strcpy( dev->sub_devs[num_subdevs].name, "tvp5150" );
+                         strcpy( dev->sub_devs[num_subdevs].i2c_board_info.type, "tvp5150" );
+                         dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x5c;
+                         dev->sub_devs[num_subdevs].i2c_board_info.platform_data = NULL;
+                         dev->sub_devs[num_subdevs].grp_id = 1;
+                         dev->sub_devs[num_subdevs].num_inputs = 1;
+                         dev->sub_devs[num_subdevs].inputs = tvp5150_5c_inputs;
+                         dev->sub_devs[num_subdevs].i2c_adap = dev->i2c_adaps[1];
+                         ++num_subdevs;
+                 }
+
+                 if ( z3_board_id == Z3_BOARD_ID_NONE
+                      || z3_board_id == Z3_BOARD_ID_APP_02 ) {
+
+                         strcpy( dev->sub_devs[num_subdevs].name, "tvp5150" );
+                         strcpy( dev->sub_devs[num_subdevs].i2c_board_info.type, "tvp5150" );
+                         dev->sub_devs[num_subdevs].i2c_board_info.addr = 0x5d;
+                         dev->sub_devs[num_subdevs].i2c_board_info.platform_data = NULL;
+                         dev->sub_devs[num_subdevs].grp_id = 2;
+                         dev->sub_devs[num_subdevs].num_inputs = 1;
+                         dev->sub_devs[num_subdevs].inputs = tvp5150_5d_inputs;
+                         dev->sub_devs[num_subdevs].i2c_adap = dev->i2c_adaps[1];
+
+                         ++num_subdevs;
+                 }
+#endif
+
+                 for (i = 0; num_subdevs > 0 && i < num_subdevs; i++) {
+                         //		struct v4l2_input *inps;
+
+                         sdinfo = &dev->sub_devs[i];
+
+                         /* Load up the subdevice */
+                         if ( sdinfo->i2c_adap ) {
+                                 dev->sd[i] =
+                                         v4l2_i2c_new_subdev_board(&dev->v4l2_dev,
+                                                                   sdinfo->i2c_adap,
+                                                                   &sdinfo->i2c_board_info,
+                                                                   NULL,
+                                                                   0 );
+                         }
+                         else if ( sdinfo->spi_master  ) {
+                                 dev->sd[i] =
+                                         v4l2_spi_new_subdev(&dev->v4l2_dev,
+                                                             sdinfo->spi_master,
+                                                             &sdinfo->spi_board_info,
+                                                             0 );
+                         }
+
+                         if (dev->sd[i]) {
+                                 v4l2_info(&dev->v4l2_dev,
+                                           "v4l2 sub device %s registered grp %d\n",
+                                           sdinfo->name, sdinfo->grp_id);
+                                 dev->sd[i]->grp_id = sdinfo->grp_id;
+
+                                 sdinfo->v4l2_sd = dev->sd[i];
+
+                                 dev->num_subdevs++;
+                         } else {
+                                 v4l2_info(&dev->v4l2_dev,
+                                           "v4l2 sub device %s register fails\n",
+                                           sdinfo->name);
+
+                                 memcpy( &dev->sub_devs[i],
+                                         &dev->sub_devs[i+1],
+                                         ((num_subdevs-(i+1)) * sizeof(dev->sub_devs[0])) );
+                                 num_subdevs--;
+                                 i--;
+                         }
+                 }
+
+                 /* set first sub device as current one */
+                 dev->current_subdev = &dev->sub_devs[0];
+                 dev->num_subdevs = num_subdevs;
+
+                 /* Set all controls to their default value. */
+                 for (i = 0; i < ARRAY_SIZE(vivi_qctrl); i++)
+                         dev->qctl_regs[i] = vivi_qctrl[i].default_value;
+
+                 /* Now that everything is fine, let's add it to device list */
+                 list_add_tail(&dev->vpif_devlist, &vpif_devlist);
+
+                 if (video_nr != -1)
+                         video_nr++;
+
+                 dev->vfd = vfd;
+                 v4l2_info(&dev->v4l2_dev, "V4L2 device registered as %s\n",
+                           video_device_node_name(vfd));
+                 return 0;
+
+         probe_sd_out:
+                 kfree(dev->sd);
+         rel_vdev:
+
+                 video_device_release(vfd);
+         unreg_dev:
+                 v4l2_device_unregister(&dev->v4l2_dev);
+         free_dev:
+                 kfree(dev);
+                 return ret;
+         }
+
+/* This routine allocates from 1 to n_devs virtual drivers.
+
+   The real maximum number of virtual drivers will depend on how many drivers
+   will succeed. This is limited to the maximum number of devices that
+   videodev supports, which is equal to VIDEO_NUM_DEVICES.
+ */
+static int __init vivi_init(void)
+{
+	int ret = 0, i;
+
+	if (n_devs <= 0)
+		n_devs = 1;
+
+	for (i = 0; i < n_devs; i++) {
+		ret = vivi_create_instance(i);
+		if (ret) {
+			/* If some instantiations succeeded, keep driver */
+			if (i)
+				ret = 0;
+			break;
+		}
+	}
+
+	if (ret < 0) {
+		printk(KERN_INFO "Error %d while loading vivi driver\n", ret);
+		return ret;
+	}
+
+
+	/* n_devs will reflect the actual number of allocated devices */
+	n_devs = i;
+
+	printk(KERN_INFO "Z3 Netra video decoders ver %u.%u.%u successfully loaded, %u devs.\n",
+			(VIVI_VERSION >> 16) & 0xFF, (VIVI_VERSION >> 8) & 0xFF,
+                        (VIVI_VERSION & 0xFF), n_devs
+                );
+
+	return ret;
+}
+
+static void __exit vivi_exit(void)
+{
+	vivi_release();
+}
+
+module_init(vivi_init);
+module_exit(vivi_exit);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/tvp7002.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/media/video/tvp7002.c	2012-03-22 23:12:58.000000000 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/tvp7002.c	2012-09-23 16:05:57.000322027 -0600
@@ -32,6 +32,7 @@
 #include <media/v4l2-device.h>
 #include <media/v4l2-chip-ident.h>
 #include <media/v4l2-common.h>
+#include <asm/div64.h>
 #include "tvp7002_reg.h"
 
 MODULE_DESCRIPTION("TI TVP7002 Video and Graphics Digitizer driver");
@@ -60,11 +61,17 @@
 #define TVP7002_CL_SHIFT	8
 #define TVP7002_CL_MASK		0x0f
 
+#define TVP7002_IN_MUX_SEL_2_EXTCLK_MASK 0x08
+
 /* Debug functions */
-static int debug;
-module_param(debug, bool, 0644);
+static int debug = 0;
+module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "Debug level (0-2)");
 
+static int force_intclk = 0;
+module_param(force_intclk, int, 0644);
+MODULE_PARM_DESC(force_intclk, "Force internal clock");
+
 /* Structure for register values */
 struct i2c_reg_value {
 	u8 reg;
@@ -102,10 +109,12 @@
 	{ TVP7002_SYNC_DETECT_STAT, 0xff, TVP7002_READ },
 	{ TVP7002_OUT_FORMATTER, 0x47, TVP7002_WRITE },
 	{ TVP7002_MISC_CTL_1, 0x01, TVP7002_WRITE },
-	{ TVP7002_MISC_CTL_2, 0x00, TVP7002_WRITE },
+//	{ TVP7002_MISC_CTL_2, 0x00, TVP7002_WRITE },
+	{ TVP7002_MISC_CTL_2, 0x03, TVP7002_WRITE }, // start off in tri-state
 	{ TVP7002_MISC_CTL_3, 0x01, TVP7002_WRITE },
 	{ TVP7002_IN_MUX_SEL_1, 0x00, TVP7002_WRITE },
-	{ TVP7002_IN_MUX_SEL_2, 0x67, TVP7002_WRITE },
+//	{ TVP7002_IN_MUX_SEL_2, 0x67, TVP7002_WRITE }, // internal clock
+	{ TVP7002_IN_MUX_SEL_2, 0x6f, TVP7002_WRITE }, // external clock
 	{ TVP7002_B_AND_G_COARSE_GAIN, 0x77, TVP7002_WRITE },
 	{ TVP7002_R_COARSE_GAIN, 0x07, TVP7002_WRITE },
 	{ TVP7002_FINE_OFF_LSBS, 0x00, TVP7002_WRITE },
@@ -225,10 +234,10 @@
 	{ TVP7002_HPLL_FDBK_DIV_MSBS, 0x89, TVP7002_WRITE },
 	{ TVP7002_HPLL_FDBK_DIV_LSBS, 0x80, TVP7002_WRITE },
 	{ TVP7002_HPLL_CRTL, 0x98, TVP7002_WRITE },
-	{ TVP7002_HPLL_PHASE_SEL, 0x14, TVP7002_WRITE },
-	{ TVP7002_AVID_START_PIXEL_LSBS, 0x06, TVP7002_WRITE },
+	{ TVP7002_HPLL_PHASE_SEL, 0xA0, TVP7002_WRITE },
+	{ TVP7002_AVID_START_PIXEL_LSBS, 0x00, TVP7002_WRITE },
 	{ TVP7002_AVID_START_PIXEL_MSBS, 0x01, TVP7002_WRITE },
-	{ TVP7002_AVID_STOP_PIXEL_LSBS, 0x8a, TVP7002_WRITE },
+	{ TVP7002_AVID_STOP_PIXEL_LSBS, 0x84, TVP7002_WRITE },
 	{ TVP7002_AVID_STOP_PIXEL_MSBS, 0x08, TVP7002_WRITE },
 	{ TVP7002_VBLK_F_0_START_L_OFF, 0x02, TVP7002_WRITE },
 	{ TVP7002_VBLK_F_1_START_L_OFF, 0x02, TVP7002_WRITE },
@@ -320,7 +329,7 @@
 	{ TVP7002_AVID_STOP_PIXEL_MSBS, 0x06, TVP7002_WRITE },
 	{ TVP7002_VBLK_F_0_START_L_OFF, 0x05, TVP7002_WRITE },
 	{ TVP7002_VBLK_F_1_START_L_OFF, 0x00, TVP7002_WRITE },
-	{ TVP7002_VBLK_F_0_DURATION, 0x2D, TVP7002_WRITE },
+	{ TVP7002_VBLK_F_0_DURATION, 0x1E, TVP7002_WRITE },
 	{ TVP7002_VBLK_F_1_DURATION, 0x00, TVP7002_WRITE },
 	{ TVP7002_ALC_PLACEMENT, 0x5a, TVP7002_WRITE },
 	{ TVP7002_CLAMP_START, 0x32, TVP7002_WRITE },
@@ -340,10 +349,22 @@
 	u16 lines_per_frame;
 	u16 cpl_min;
 	u16 cpl_max;
+	u16 cpl_min_ext_clk;
+	u16 cpl_max_ext_clk;
 };
 
 /* Struct list for digital video presets */
-static const struct tvp7002_preset_definition tvp7002_presets[] = {
+static struct tvp7002_preset_definition tvp7002_presets[] = {
+	{
+		V4L2_DV_720P59_94,
+		tvp7002_parms_720P60,
+		V4L2_COLORSPACE_REC709,
+		V4L2_FIELD_NONE,
+		1,
+		0x2EE,
+		0, // need external clock to detect
+		0,
+	},
 	{
 		V4L2_DV_720P60,
 		tvp7002_parms_720P60,
@@ -355,6 +376,16 @@
 		153
 	},
 	{
+		V4L2_DV_1080I29_97,
+		tvp7002_parms_1080I60,
+		V4L2_COLORSPACE_REC709,
+		V4L2_FIELD_INTERLACED,
+		0,
+		0x465,
+		0, //need external clock to detect
+		0,
+	},
+	{
 		V4L2_DV_1080I60,
 		tvp7002_parms_1080I60,
 		V4L2_COLORSPACE_REC709,
@@ -503,6 +534,7 @@
 
 	c = v4l2_get_subdevdata(sd);
 
+        v4l2_dbg(1, debug, sd, "Write reg x%02x val %02x\n", (int)addr, (int)value );
 	for (retry = 0; retry < I2C_RETRY_COUNT; retry++) {
 		error = i2c_smbus_write_byte_data(c, addr, value);
 
@@ -722,7 +754,7 @@
 static int tvp7002_query_dv_preset(struct v4l2_subdev *sd,
 						struct v4l2_dv_preset *qpreset)
 {
-	const struct tvp7002_preset_definition *presets = tvp7002_presets;
+	struct tvp7002_preset_definition *presets = tvp7002_presets;
 	struct tvp7002 *device;
 	u8 progressive;
 	u32 lpfr;
@@ -733,9 +765,63 @@
 	u8 cpl_lsb;
 	u8 cpl_msb;
 	int index;
+        u32 int_clk_freq = 6500000;
+        u32 ext_clk_freq = 125000100;
+        u8 in_mux_sel_2;
+        u64 cpl64;
 
 	device = to_tvp7002(sd);
 
+	for (index = 0; index < NUM_PRESETS; index++) {
+
+
+                switch ( presets[index].preset )
+                {
+                case V4L2_DV_720P59_94:
+                        lpfr = presets[index].lines_per_frame;
+                        cpl64 = ext_clk_freq;
+                        cpl64 *= 1001;
+                        do_div( cpl64, (lpfr*60000));
+
+                        presets[index].cpl_min_ext_clk = cpl64-1;
+                        presets[index].cpl_max_ext_clk = cpl64+1;
+                        break;
+                case V4L2_DV_1080I29_97:
+                        lpfr = presets[index].lines_per_frame;
+                        cpl64 = ext_clk_freq;
+                        cpl64 *= 1001;
+                        do_div( cpl64, (lpfr*30000));
+
+                        presets[index].cpl_min_ext_clk = cpl64-1;
+                        presets[index].cpl_max_ext_clk = cpl64+1;
+                        break;
+                default:
+                        presets[index].cpl_min_ext_clk = (presets[index].cpl_min * (ext_clk_freq/100))  / (int_clk_freq/100);
+                        presets[index].cpl_max_ext_clk = (presets[index].cpl_max * (ext_clk_freq/100))  / (int_clk_freq/100);
+                        break;
+
+                }
+
+        }
+
+
+        tvp7002_read_err(sd, TVP7002_IN_MUX_SEL_2,    &in_mux_sel_2, &error);
+	if (error < 0)
+		return error;
+
+        if ( (!!force_intclk) != (!((in_mux_sel_2 & TVP7002_IN_MUX_SEL_2_EXTCLK_MASK))) ) {
+                /* Flip between internal vs external clock */
+                in_mux_sel_2 ^= TVP7002_IN_MUX_SEL_2_EXTCLK_MASK;
+                error = tvp7002_write(sd, TVP7002_IN_MUX_SEL_2, in_mux_sel_2 );
+                if (error < 0)
+                        return error;
+
+                /* Wait for new clock */
+                msleep( 50 );
+        }
+
+
+
 	/* Read standards from device registers */
 	tvp7002_read_err(sd, TVP7002_L_FRAME_STAT_LSBS, &lpf_lsb, &error);
 	tvp7002_read_err(sd, TVP7002_L_FRAME_STAT_MSBS, &lpf_msb, &error);
@@ -760,8 +846,14 @@
 			progressive == presets->progressive) {
 			if (presets->cpl_min == 0xffff)
 				break;
-			if (cpln >= presets->cpl_min && cpln <= presets->cpl_max)
-				break;
+                        if ( 0 != (in_mux_sel_2 & TVP7002_IN_MUX_SEL_2_EXTCLK_MASK) ) // external clock
+                        {
+                                if (cpln >= presets->cpl_min_ext_clk && cpln <= presets->cpl_max_ext_clk)
+                                        break;
+                        } else {
+                                if (cpln >= presets->cpl_min && cpln <= presets->cpl_max)
+                                        break;
+                        }
 		}
 
 	if (index == NUM_PRESETS) {
@@ -862,8 +954,10 @@
 	struct tvp7002 *device = to_tvp7002(sd);
 	int error = 0;
 
-	if (device->streaming == enable)
-		return 0;
+        v4l2_dbg(1, debug, sd, "s_stream %d\n", enable);
+
+//	if (device->streaming == enable)
+//		return 0;
 
 	if (enable) {
 		/* Set output state on (low impedance means stream on) */
@@ -890,7 +984,7 @@
  */
 static int tvp7002_log_status(struct v4l2_subdev *sd)
 {
-	const struct tvp7002_preset_definition *presets = tvp7002_presets;
+	struct tvp7002_preset_definition *presets = tvp7002_presets;
 	struct tvp7002 *device = to_tvp7002(sd);
 	struct v4l2_dv_enum_preset e_preset;
 	struct v4l2_dv_preset detected;
@@ -1043,13 +1137,13 @@
 		goto found_error;
 
 	/* Set polarity information after registers have been set */
-	polarity_a = 0x20 | device->pdata->hs_polarity << 5
-			| device->pdata->vs_polarity << 2;
+	polarity_a = 0x5B;//0x00 | device->pdata->hs_polarity << 5
+		     //	| device->pdata->vs_polarity << 2;
 	error = tvp7002_write(sd, TVP7002_SYNC_CTL_1, polarity_a);
 	if (error < 0)
 		goto found_error;
 
-	polarity_b = device->pdata->fid_polarity << 2
+	polarity_b = 0x00  | device->pdata->fid_polarity << 2
 			| device->pdata->sog_polarity << 1
 			| device->pdata->clk_polarity;
 	error = tvp7002_write(sd, TVP7002_MISC_CTL_3, polarity_b);
Index: kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/vivi.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/drivers/media/video/vivi.c	2012-03-22 23:12:58.000000000 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/drivers/media/video/vivi.c	2012-09-23 16:05:57.000322027 -0600
@@ -416,6 +416,7 @@
 {
 	int line;
 
+#if defined( CONFIG_FONT_8x16 )
 	/* Checks if it is possible to show string */
 	if (y + 16 >= dev->height || x + strlen(text) * 8 >= dev->width)
 		return;
@@ -439,6 +440,7 @@
 			}
 		}
 	}
+#endif
 }
 
 static void vivi_fillbuff(struct vivi_dev *dev, struct vivi_buffer *buf)
@@ -1226,15 +1228,17 @@
  */
 static int __init vivi_init(void)
 {
-	const struct font_desc *font = find_font("VGA8x16");
+	const struct font_desc *font;
 	int ret = 0, i;
 
+#if defined( CONFIG_FONT_8x16 )
+	font = find_font("VGA8x16");
 	if (font == NULL) {
 		printk(KERN_ERR "vivi: could not find font\n");
 		return -ENODEV;
 	}
 	font8x16 = font->data;
-
+#endif
 	if (n_devs <= 0)
 		n_devs = 1;
 
Index: kernel/linux-2.6.37-psp04.04.00.01/include/media/davinci/videohd.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/include/media/davinci/videohd.h	2012-09-23 16:05:57.000322027 -0600
@@ -0,0 +1,75 @@
+/*
+ * videohd.h - Defines temporary HD standards for video drivers
+ *
+ * Copyright (C) 2009 Texas Instruments Incorporated - http://www.ti.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed .as is. WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This header file will hold all Digital TV video HD/ED standards until same is
+ * supported by v4l2 sub system. Moving this to this file will help avoid
+ * unnecessary merge issues. Once the support is available, we could discard
+ * this file
+ */
+#ifndef __VIDEOHD_H
+#define __VIDEOHD_H
+
+/* Z3 - Digital TV standards */
+#define V4L2_STD_720P_60        ((v4l2_std_id)(0x0001000000000000ULL))
+#define V4L2_STD_1080I_60       ((v4l2_std_id)(0x0002000000000000ULL))
+#define V4L2_STD_1080I_50       ((v4l2_std_id)(0x0004000000000000ULL))
+#define V4L2_STD_525P_60        ((v4l2_std_id)(0x0008000000000000ULL))
+#define V4L2_STD_625P_50        ((v4l2_std_id)(0x0010000000000000ULL))
+#define V4L2_STD_720P_25        ((v4l2_std_id)(0x0020000000000000ULL))
+#define V4L2_STD_720P_30        ((v4l2_std_id)(0x0040000000000000ULL))
+#define V4L2_STD_720P_50        ((v4l2_std_id)(0x0080000000000000ULL))
+#define V4L2_STD_1080P_25       ((v4l2_std_id)(0x0100000000000000ULL))
+#define V4L2_STD_1080P_30       ((v4l2_std_id)(0x0200000000000000ULL))
+#define V4L2_STD_1080P_24       ((v4l2_std_id)(0x0400000000000000ULL))
+#define V4L2_STD_1080P_50       ((v4l2_std_id)(0x0800000000000000ULL))
+#define V4L2_STD_1080P_60       ((v4l2_std_id)(0x1000000000000000ULL))
+#define V4L2_STD_HD_DIV_1001    ((v4l2_std_id)(0x2000000000000000ULL))
+#define V4L2_STD_HD_DIV_1000    ((v4l2_std_id)(0x4000000000000000ULL))
+
+
+/* Z3 - Special VESA modes */
+#define V4L2_STD_800x600_60     ((v4l2_std_id)(0x0000000010000000ULL))
+#define V4L2_STD_800x600_72     ((v4l2_std_id)(0x0000000020000000ULL))
+#define V4L2_STD_800x600_75     ((v4l2_std_id)(0x0000000040000000ULL))
+#define V4L2_STD_800x600_85     ((v4l2_std_id)(0x0000000080000000ULL))
+
+#define V4L2_STD_1024x768_60    ((v4l2_std_id)(0x0000000100000000ULL))
+#define V4L2_STD_1024x768_70    ((v4l2_std_id)(0x0000000200000000ULL))
+#define V4L2_STD_1024x768_75    ((v4l2_std_id)(0x0000000400000000ULL))
+#define V4L2_STD_1024x768_85    ((v4l2_std_id)(0x0000000800000000ULL))
+
+#define V4L2_STD_1280x600_60    ((v4l2_std_id)(0x0000001000000000ULL))
+
+#define V4L2_STD_1280x720_60    ((v4l2_std_id)(0x0000002000000000ULL))
+#define V4L2_STD_1280x720_75    ((v4l2_std_id)(0x0000004000000000ULL))
+#define V4L2_STD_1280x720_85    ((v4l2_std_id)(0x0000008000000000ULL))
+
+#define V4L2_STD_1280x768_60    ((v4l2_std_id)(0x0000010000000000ULL))
+#define V4L2_STD_1280x768_75    ((v4l2_std_id)(0x0000020000000000ULL))
+#define V4L2_STD_1280x768_85    ((v4l2_std_id)(0x0000040000000000ULL))
+
+#define V4L2_STD_1280x1024_60   ((v4l2_std_id)(0x0000080000000000ULL))
+#define V4L2_STD_1280x1024_75   ((v4l2_std_id)(0x0000100000000000ULL))
+#define V4L2_STD_1280x1024_85   ((v4l2_std_id)(0x0000200000000000ULL))
+
+#define V4L2_STD_1280x800_60    ((v4l2_std_id)(0x0000400000000000ULL))
+
+#define V4L2_STD_VESA_ALL ( 	\
+    V4L2_STD_800x600_60 | V4L2_STD_800x600_72 | V4L2_STD_800x600_75 | V4L2_STD_800x600_85 | \
+	V4L2_STD_1024x768_60 | V4L2_STD_1024x768_70 | V4L2_STD_1024x768_75 | V4L2_STD_1024x768_85 | \
+	V4L2_STD_1280x600_60 | V4L2_STD_1280x720_60 | V4L2_STD_1280x720_75 | V4L2_STD_1280x720_85 | \
+	V4L2_STD_1280x768_60 | V4L2_STD_1280x768_75 | V4L2_STD_1280x768_85 | V4L2_STD_1280x800_60 | \
+	V4L2_STD_1280x1024_60 | V4L2_STD_1280x1024_75 | V4L2_STD_1280x1024_85 )
+
+#endif
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/Kconfig
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/Kconfig	2012-03-22 23:13:03.000000000 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/Kconfig	2012-09-23 16:05:57.000322027 -0600
@@ -318,3 +318,19 @@
 
 config SND_SOC_WM9090
 	tristate
+
+config SND_SOC_ADV7611
+        tristate "ADV7611 HDMI receiver audio"
+	default y if VIDEO_ADV7611=y
+	default m if VIDEO_ADV7611=m
+
+config SND_SOC_GV7601
+        tristate "GV7601 SDI receiver audio"
+	default y if VIDEO_GV7601=y
+	default m if VIDEO_GV7601=m
+
+config SND_SOC_GV7600
+        tristate "GV7600 SDI receiver audio"
+	default y if VIDEO_GV7600=y
+	default m if VIDEO_GV7600=m
+
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/Makefile
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/Makefile	2012-03-22 23:13:03.000000000 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/Makefile	2012-09-23 16:05:57.000322027 -0600
@@ -5,6 +5,7 @@
 snd-soc-ad1980-objs := ad1980.o
 snd-soc-ad73311-objs := ad73311.o
 snd-soc-ads117x-objs := ads117x.o
+snd-soc-adv7611-objs := adv7611.o
 snd-soc-ak4104-objs := ak4104.o
 snd-soc-ak4535-objs := ak4535.o
 snd-soc-ak4642-objs := ak4642.o
@@ -66,6 +67,8 @@
 snd-soc-wm-hubs-objs := wm_hubs.o
 snd-soc-jz4740-codec-objs := jz4740.o
 snd-soc-ti81xx-hdmi-objs := ti81xx_hdmi.o
+snd-soc-gv7601-objs := gv7601.o
+snd-soc-gv7600-objs := gv7600.o
 
 # Amp
 snd-soc-max9877-objs := max9877.o
@@ -84,6 +87,7 @@
 obj-$(CONFIG_SND_SOC_AK4535)	+= snd-soc-ak4535.o
 obj-$(CONFIG_SND_SOC_AK4642)	+= snd-soc-ak4642.o
 obj-$(CONFIG_SND_SOC_AK4671)	+= snd-soc-ak4671.o
+obj-$(CONFIG_SND_SOC_ADV7611)   += snd-soc-adv7611.o
 obj-$(CONFIG_SND_SOC_CQ0093VC) += snd-soc-cq93vc.o
 obj-$(CONFIG_SND_SOC_CS42L51)	+= snd-soc-cs42l51.o
 obj-$(CONFIG_SND_SOC_CS4270)	+= snd-soc-cs4270.o
@@ -147,3 +151,7 @@
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
 obj-$(CONFIG_SND_SOC_WM2000)	+= snd-soc-wm2000.o
 obj-$(CONFIG_SND_SOC_WM9090)	+= snd-soc-wm9090.o
+
+# Z3
+obj-$(CONFIG_SND_SOC_GV7600)   += snd-soc-gv7600.o
+obj-$(CONFIG_SND_SOC_GV7601)   += snd-soc-gv7601.o
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/adv7611.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/adv7611.c	2012-09-23 16:05:57.000322027 -0600
@@ -0,0 +1,98 @@
+/*
+ * ALSA SoC ADV7611 HDMI receiver audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <mach/z3_fpga.h>
+
+MODULE_LICENSE("GPL");
+
+#define ADV7611_SOUND_RATES	SNDRV_PCM_RATE_8000_96000
+#define ADV7611_SOUND_FORMATS	SNDRV_PCM_FMTBIT_S32_LE
+
+
+static struct snd_soc_codec_driver soc_codec_adv7611_sound;
+
+
+static int adv7611_sound_hw_params(struct snd_pcm_substream *substream,
+                                   struct snd_pcm_hw_params *params,
+                                   struct snd_soc_dai *dai)
+{
+        /* This is where we need to drive the digital bus,
+           when we are sharing the bus with another codec
+         */
+
+        z3_fpga_set_aic_disable( 1 );
+
+        return 0;
+}
+
+static int adv7611_sound_set_dai_fmt(struct snd_soc_dai *codec_dai,
+                                     unsigned int fmt)
+{
+        return 0;
+}
+
+static struct snd_soc_dai_ops adv7611_sound_dai_ops = {
+        .hw_params = adv7611_sound_hw_params,
+	/* .digital_mute	= adv7611_sound_mute, */
+	/* .set_sysclk	= adv7611_sound_set_dai_sysclk, */
+	.set_fmt	= adv7611_sound_set_dai_fmt,
+};
+
+
+static struct snd_soc_dai_driver adv7611_sound_dai = {
+	.name		= "adv7611-hifi",
+	.capture 	= {
+		.stream_name	= "Capture",
+		.channels_min	= 2,
+		.channels_max	= 8,
+		.rates		= ADV7611_SOUND_RATES,
+		.formats	= ADV7611_SOUND_FORMATS,
+	},
+	.ops = &adv7611_sound_dai_ops,
+};
+
+static int adv7611_sound_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_adv7611_sound,
+			&adv7611_sound_dai, 1);
+}
+
+static int adv7611_sound_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver adv7611_sound_driver = {
+	.probe		= adv7611_sound_probe,
+	.remove		= adv7611_sound_remove,
+	.driver		= {
+		.name	= "adv7611-sound",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init adv7611_sound_modinit(void)
+{
+	return platform_driver_register(&adv7611_sound_driver);
+}
+
+static void __exit adv7611_sound_exit(void)
+{
+	platform_driver_unregister(&adv7611_sound_driver);
+}
+
+module_init(adv7611_sound_modinit);
+module_exit(adv7611_sound_exit);
+
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-evm.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-evm.c	2012-09-23 16:05:56.972322027 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-evm.c	2012-09-23 16:05:57.000322027 -0600
@@ -30,6 +30,9 @@
 #else
 #include <plat/asp.h>
 #include <asm/hardware/edma.h>
+#include <mach/z3_fpga.h>
+#include <mach/z3_app.h>
+#include <linux/reboot.h>
 #endif
 
 #include "../codecs/tlv320aic3x.h"
@@ -37,8 +40,11 @@
 #include "davinci-i2s.h"
 #include "davinci-mcasp.h"
 
-#define AUDIO_FORMAT (SND_SOC_DAIFMT_DSP_B | \
-		SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_IB_NF)
+//#define AUDIO_FORMAT (SND_SOC_DAIFMT_DSP_B | SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_IB_NF)
+
+#define AUDIO_FORMAT (SND_SOC_DAIFMT_I2S |                    \
+		SND_SOC_DAIFMT_CBM_CFM | SND_SOC_DAIFMT_NB_NF)
+
 static int evm_hw_params(struct snd_pcm_substream *substream,
 			 struct snd_pcm_hw_params *params)
 {
@@ -63,11 +69,17 @@
 	else if (machine_is_davinci_da830_evm() ||
 				machine_is_davinci_da850_evm() ||
 				machine_is_ti8168evm() ||
-				machine_is_dm8168z3() ||
-				machine_is_ti8148evm() ||
 				machine_is_dm385evm())
 		sysclk = 24576000;
+//		sysclk = 24500000;
 
+        else if ( machine_is_ti8148evm() ) {
+#if defined(CONFIG_MACH_Z3_DM814X_MOD)
+		sysclk = 31250000;
+#else
+		sysclk = 24576000;
+#endif
+        }
 	else
 		return -EINVAL;
 
@@ -89,6 +101,58 @@
 	return 0;
 }
 
+static int evm_sdi_out_hw_params(struct snd_pcm_substream *substream,
+                                 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+        unsigned int codec_slave_format = (SND_SOC_DAIFMT_I2S |
+                                           SND_SOC_DAIFMT_CBS_CFS |
+                                           SND_SOC_DAIFMT_NB_NF);
+
+	int ret = 0;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, codec_slave_format);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, codec_slave_format);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static int evm_sdi_in_hw_params(struct snd_pcm_substream *substream,
+                                 struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+
+        unsigned int codec_slave_format = (SND_SOC_DAIFMT_RIGHT_J |
+                                           SND_SOC_DAIFMT_CBM_CFM |
+                                           SND_SOC_DAIFMT_NB_NF);
+
+	int ret = 0;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, codec_slave_format);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, codec_slave_format);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
 static int evm_spdif_hw_params(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params)
 {
@@ -99,14 +163,78 @@
 	return snd_soc_dai_set_fmt(cpu_dai, AUDIO_FORMAT);
 }
 
+static int evm_ext_master_hw_params(struct snd_pcm_substream *substream,
+				struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+        int ret=0;
+        unsigned int ext_master_format = (SND_SOC_DAIFMT_I2S |
+                                          SND_SOC_DAIFMT_CBM_CFM |
+                                          SND_SOC_DAIFMT_NB_NF);
+
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, ext_master_format);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret= snd_soc_dai_set_fmt(cpu_dai, ext_master_format);
+
+        return ret;
+}
+
+static int evm_codec_slave_ext_master_hw_params(struct snd_pcm_substream *substream,
+                                        struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+        int ret=0;
+        unsigned int codec_format = (SND_SOC_DAIFMT_I2S |
+                                     SND_SOC_DAIFMT_CBS_CFS |
+                                     SND_SOC_DAIFMT_NB_NF);
+        unsigned int ext_master_format = (SND_SOC_DAIFMT_I2S |
+                                          SND_SOC_DAIFMT_CBM_CFM |
+                                          SND_SOC_DAIFMT_NB_NF);
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, codec_format);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret= snd_soc_dai_set_fmt(cpu_dai, ext_master_format);
+
+        return ret;
+}
+
 static struct snd_soc_ops evm_ops = {
 	.hw_params = evm_hw_params,
 };
 
+static struct snd_soc_ops evm_sdi_out_ops = {
+	.hw_params = evm_sdi_out_hw_params,
+};
+
+static struct snd_soc_ops evm_sdi_in_ops = {
+	.hw_params = evm_sdi_in_hw_params,
+};
+
 static struct snd_soc_ops evm_spdif_ops = {
 	.hw_params = evm_spdif_hw_params,
 };
 
+static struct snd_soc_ops evm_ext_master_ops = {
+	.hw_params = evm_ext_master_hw_params,
+};
+
+static struct snd_soc_ops evm_switch_ops = {
+	.hw_params = evm_hw_params, /* may be changed at init time */
+};
+
 /* davinci-evm machine dapm widgets */
 static const struct snd_soc_dapm_widget aic3x_dapm_widgets[] = {
 	SND_SOC_DAPM_HP("Headphone Jack", NULL),
@@ -165,6 +293,29 @@
 	return 0;
 }
 
+static int evm_aic3x_2nd_init(struct snd_soc_pcm_runtime *rtd)
+{
+        return 0;
+}
+
+/* Logic for a adv7611 aic3x as connected on a davinci-evm */
+static int evm_adv7611_init(struct snd_soc_pcm_runtime *rtd)
+{
+        return 0;
+}
+
+/* Logic for a gv7601 aic3x as connected on a davinci-evm */
+static int evm_gv7601_init(struct snd_soc_pcm_runtime *rtd)
+{
+        return 0;
+}
+
+/* Logic for a gv7600 as connected on a davinci-evm */
+static int evm_gv7600_init(struct snd_soc_pcm_runtime *rtd)
+{
+        return 0;
+}
+
 /* davinci-evm digital audio interface glue - connects codec <--> CPU */
 static struct snd_soc_dai_link dm6446_evm_dai = {
 	.name = "TLV320AIC3X",
@@ -239,16 +390,18 @@
 	.ops = &evm_ops,
 };
 
+
 static struct snd_soc_dai_link ti81xx_evm_dai[] = {
-	{
-		.name = "TLV320AIC3X",
-		.stream_name = "AIC3X",
-		.codec_dai_name = "tlv320aic3x-hifi",
-		.codec_name = "tlv320aic3x-codec.1-0018",
-		.platform_name = "davinci-pcm-audio",
-		.init = evm_aic3x_init,
-		.ops = &evm_ops,
-	},
+        {
+                .name = "TLV320AIC3X",
+                .stream_name = "AIC3X",
+                .cpu_dai_name= "davinci-mcasp.2",
+                .codec_dai_name = "tlv320aic3x-hifi",
+                .codec_name = "tlv320aic3x-codec.1-0018",
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_aic3x_init,
+                .ops = &evm_switch_ops, // may be master or slave
+        },
 #ifdef CONFIG_SND_SOC_TI81XX_HDMI
 	{
 		.name = "HDMI_SOC_LINK",
@@ -261,6 +414,114 @@
 #endif
 };
 
+static struct snd_soc_dai_link z3_dm81xx_app_02_dai[] = {
+        {
+                .name = "TLV320AIC3X_2",
+                .stream_name = "AIC3X_2",
+                .cpu_dai_name= "davinci-mcasp.1",
+                .codec_dai_name = "tlv320aic3x-hifi",
+                .codec_name = "tlv320aic3x-codec.2-0018",
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_aic3x_2nd_init,
+                .ops = &evm_ops,
+        },
+#if (defined(CONFIG_VIDEO_ADV7611) || defined(CONFIG_VIDEO_ADV7611_MODULE))
+        {
+                .name = "ADV7611_SOUND",
+                .stream_name = "ADV7611",
+                .cpu_dai_name= "davinci-mcasp.0",
+                .codec_dai_name = "adv7611-hifi",
+                .codec_name = "adv7611-sound.1",
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_adv7611_init,
+                .ops = &evm_ext_master_ops,
+        },
+        {
+                .name = "ADV7611_SOUND_2",
+                .stream_name = "ADV7611_2",
+                .cpu_dai_name= "davinci-mcasp.1",
+                .codec_dai_name = "adv7611-hifi",
+                .codec_name = "adv7611-sound.2",
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_adv7611_init,
+                .ops = &evm_ext_master_ops,
+        },
+#endif
+};
+
+static struct snd_soc_dai_link z3_dm81xx_app_32_dai[] = {
+        {
+                .name = "ADV7611_SOUND",
+                .stream_name = "ADV7611",
+                .cpu_dai_name= "davinci-mcasp.2",
+                .codec_dai_name = "adv7611-hifi",
+                .codec_name = "adv7611-sound.1", // distinguish by I2C address?
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_adv7611_init,
+                .ops = &evm_ext_master_ops,
+        },
+        {
+                .name = "GV7601_SOUND",
+                .stream_name = "GV7601",
+                .cpu_dai_name= "davinci-mcasp.0",
+                .codec_dai_name = "gv7601-hifi",
+                .codec_name = "gv7601-sound", // distinguish by I2C address?
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_gv7601_init,
+                .ops = &evm_sdi_in_ops,
+        },
+        {
+                .name = "GV7600_SOUND",
+                .stream_name = "GV7600",
+                .cpu_dai_name= "davinci-mcasp.1",
+                .codec_dai_name = "gv7600-hifi",
+                .codec_name = "gv7600-sound", // distinguish by I2C address?
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_gv7600_init,
+                .ops = &evm_sdi_out_ops,
+        },
+};
+
+static struct snd_soc_dai_link z3_dm81xx_app_22_dai[] = {
+        {
+                .name = "ADV7611_SOUND",
+                .stream_name = "ADV7611",
+                .cpu_dai_name= "davinci-mcasp.0",
+                .codec_dai_name = "adv7611-hifi",
+                .codec_name = "adv7611-sound.1",
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_adv7611_init,
+                .ops = &evm_ext_master_ops,
+        },
+};
+
+
+static struct snd_soc_dai_link z3_dm81xx_app_41_dai[] = {
+#if (defined(CONFIG_VIDEO_ADV7611) || defined(CONFIG_VIDEO_ADV7611_MODULE))
+        {
+                .name = "ADV7611_SOUND",
+                .stream_name = "ADV7611",
+                .cpu_dai_name= "davinci-mcasp.0",
+                .codec_dai_name = "adv7611-hifi",
+                .codec_name = "adv7611-sound.1",
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_adv7611_init,
+                .ops = &evm_ext_master_ops,
+        },
+        {
+                .name = "ADV7611_SOUND_2",
+                .stream_name = "ADV7611_2",
+                .cpu_dai_name= "davinci-mcasp.1",
+                .codec_dai_name = "adv7611-hifi",
+                .codec_name = "adv7611-sound.2",
+                .platform_name = "davinci-pcm-audio",
+                .init = evm_adv7611_init,
+                .ops = &evm_ext_master_ops,
+        },
+#endif
+};
+
+
 /* davinci dm6446 evm audio machine driver */
 static struct snd_soc_card dm6446_snd_soc_card_evm = {
 	.name = "DaVinci DM6446 EVM",
@@ -307,23 +568,59 @@
 	.num_links = ARRAY_SIZE(ti81xx_evm_dai),
 };
 
+static struct snd_soc_card z3_dm81xx_app_02_snd_soc_card = {
+        .name = "APP02",
+        .dai_link = z3_dm81xx_app_02_dai,
+        .num_links = ARRAY_SIZE(z3_dm81xx_app_02_dai),
+};
+
+static struct snd_soc_card z3_dm81xx_app_32_snd_soc_card = {
+        .name = "APP32",
+        .dai_link = z3_dm81xx_app_32_dai,
+        .num_links = ARRAY_SIZE(z3_dm81xx_app_32_dai),
+};
+
+static struct snd_soc_card z3_dm81xx_app_22_snd_soc_card = {
+        .name = "APP22",
+        .dai_link = z3_dm81xx_app_22_dai,
+        .num_links = ARRAY_SIZE(z3_dm81xx_app_22_dai),
+};
+
 static void ti81xx_evm_dai_fixup(void)
 {
-	if (machine_is_ti8168evm() || machine_is_ti8148evm()) {
-		ti81xx_evm_dai[0].cpu_dai_name = "davinci-mcasp.2";
+        int i;
+
+	if (machine_is_ti8168evm()) {
+        } else if (machine_is_ti8148evm()) {
+                for (i=0; i<ARRAY_SIZE(z3_dm81xx_app_02_dai); i++ ) {
+                        if (!strcmp( z3_dm81xx_app_02_dai[i].name, "TLV320AIC3X_2" ) ) {
+                                z3_dm81xx_app_02_dai[i].codec_name = "tlv320aic3x-codec.3-0018";
+                        }
+                }
 	} else if (machine_is_dm385evm()) {
 		ti81xx_evm_dai[0].cpu_dai_name = "davinci-mcasp.1";
-	} else {
-		ti81xx_evm_dai[0].cpu_dai_name = NULL;
+//	} else {
+//		ti81xx_evm_dai[0].cpu_dai_name = NULL;
 	}
 }
 
+static struct snd_soc_card z3_dm81xx_app_41_snd_soc_card = {
+        .name = "APP41",
+        .dai_link = z3_dm81xx_app_41_dai,
+        .num_links = ARRAY_SIZE(z3_dm81xx_app_41_dai),
+};
+
 static struct platform_device *evm_snd_device;
 static int __init evm_init(void)
 {
 	struct snd_soc_card *evm_snd_dev_data;
 	int index;
 	int ret;
+#ifdef CONFIG_ARCH_TI81XX
+        int board_id = z3_fpga_board_id() ;
+#endif
+
+        printk( KERN_DEBUG "ALSA init: board_id=%u\n", board_id );
 
 	if (machine_is_davinci_evm()) {
 		evm_snd_dev_data = &dm6446_snd_soc_card_evm;
@@ -344,10 +641,22 @@
 		evm_snd_dev_data = &da850_snd_soc_card;
 		index = 0;
 	} else if (machine_is_ti8168evm() || machine_is_ti8148evm()
-		    || machine_is_dm385evm() || machine_is_dm8168z3()) {
+					|| machine_is_dm385evm()) {
 		ti81xx_evm_dai_fixup();
 		evm_snd_dev_data = &ti81xx_snd_soc_card;
 		index = 0;
+
+                switch ( board_id )  {
+                case Z3_BOARD_ID_APP_31:
+                        /* Slave on-board PCM when sample rate generator is supported */
+                        evm_switch_ops.hw_params = evm_codec_slave_ext_master_hw_params;
+                        z3_fpga_set_aic_ext_master(1);
+                        break;
+                default:
+                        break;
+
+                }
+
 	} else
 		return -EINVAL;
 
@@ -360,6 +669,44 @@
 	if (ret)
 		platform_device_put(evm_snd_device);
 
+        if (machine_is_ti8168evm() || machine_is_ti8148evm()) {
+#ifdef CONFIG_ARCH_TI81XX
+                evm_snd_dev_data = NULL;
+
+                switch ( board_id )  {
+                case Z3_BOARD_ID_APP_02:
+                        evm_snd_dev_data = &z3_dm81xx_app_02_snd_soc_card;
+                        break;
+                case Z3_BOARD_ID_APP_21:
+                        evm_snd_dev_data = &z3_dm81xx_app_22_snd_soc_card;
+                        break;
+                case Z3_BOARD_ID_APP_41:
+                        evm_snd_dev_data = &z3_dm81xx_app_41_snd_soc_card;
+                        break;
+                case Z3_BOARD_ID_APP_31:
+                        evm_snd_dev_data = &z3_dm81xx_app_32_snd_soc_card;
+                        break;
+                default:
+                        break;
+
+                }
+
+                if ( NULL != evm_snd_dev_data ) {
+                        ++index;
+                        evm_snd_device = platform_device_alloc("soc-audio", index);
+                        if (!evm_snd_device)
+                                return -ENOMEM;
+
+                        platform_set_drvdata(evm_snd_device, evm_snd_dev_data);
+                        ret = platform_device_add(evm_snd_device);
+                        if (ret)
+                                platform_device_put(evm_snd_device);
+
+                }
+#endif
+
+	}
+
 	return ret;
 }
 
 static int davinci_hdmi_dai_startup(struct snd_pcm_substream *substream,
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.c	2012-09-23 16:05:56.972322027 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.c	2012-09-23 16:05:57.004322027 -0600
@@ -29,6 +29,11 @@
 #include <sound/initval.h>
 #include <sound/soc.h>
 
+
+#include <mach/z3_fpga.h>
+#include <mach/z3_app.h>
+
+
 #include "davinci-pcm.h"
 #include "davinci-mcasp.h"
 
@@ -135,6 +140,8 @@
 #define AHCLKR		BIT(30)
 #define AFSR		BIT(31)
 
+#define MCASP_BITCLK_FS_PINS_MASK (ACLKX|ACLKR|AFSX|AFSR)
+
 /*
  * DAVINCI_MCASP_PDIR_REG - Pin Direction Register Bits
  */
@@ -187,9 +194,9 @@
 /*
  * DAVINCI_MCASP_RXFMCTL_REG - Receive Frame Control Register Bits
  */
-#define FSRPOL		BIT(0)
-#define AFSRE		BIT(1)
-#define FSRDUR		BIT(4)
+#define FSRPOL		BIT(0)     // 0=rising edge, 1=falling edge
+#define AFSRE		BIT(1)     // 0=external, 1=internally generated
+#define FSRDUR		BIT(4)     // 0=single bit, 1=single word
 #define FSRMOD(val)	(val<<7)
 
 /*
@@ -210,6 +217,8 @@
 #define RX_ASYNC	BIT(6)
 #define ACLKRPOL	BIT(7)
 
+#define ACLKRDIVMASK    0x1f
+
 /*
  * DAVINCI_MCASP_AHCLKXCTL_REG - High Frequency Transmit Clock Control
  *     Register Bits
@@ -228,6 +237,8 @@
 #define AHCLKRPOL	BIT(14)
 #define AHCLKRE		BIT(15)
 
+#define AHCLKRDIVMASK   0xfff
+
 /*
  * DAVINCI_MCASP_XRSRCTL_BASE_REG -  Serializer Control Register Bits
  */
@@ -302,6 +313,8 @@
 
 #define DAVINCI_MCASP_NUM_SERIALIZER	16
 
+#define DAVINCI_CPU_MAX_MCASP           3
+
 static inline void mcasp_set_bits(void __iomem *reg, u32 val)
 {
 	__raw_writel(__raw_readl(reg) | val, reg);
@@ -331,21 +344,101 @@
 {
 	int i = 0;
 
+        /* Look in real GBLCTL_REG for update - shadow reg is not accurate */
+        void __iomem *gblctl_reg = (void __iomem *) ((((unsigned long)regs) & 0xffffff00) + DAVINCI_MCASP_GBLCTL_REG);
+
 	mcasp_set_bits(regs, val);
 
 	/* programming GBLCTL needs to read back from GBLCTL and verfiy */
 	/* loop count is to avoid the lock-up */
-	for (i = 0; i < 1000; i++) {
-		if ((mcasp_get_reg(regs) & val) == val)
+	for (i = 0; i < 100; i++) {
+		if ((mcasp_get_reg(gblctl_reg) & val) == val)
 			break;
+                udelay(1);
 	}
 
-	if (i == 1000 && ((mcasp_get_reg(regs) & val) != val))
+	if (i == 100 && ((mcasp_get_reg(gblctl_reg) & val) != val))
 		printk(KERN_ERR "GBLCTL write error\n");
 }
 
+
+static void mcasp_set_board_clks(struct davinci_audio_dev *dev)
+{
+        int board_id = z3_fpga_board_id();
+
+        switch ( dev->id )
+        {
+        case 0:
+        default:
+                dev->mclk_out = 0;
+                dev->use_tx_clk_for_rx = 0;
+                break;
+        case 1:
+                dev->mclk_out = AHCLKR|AHCLKX;
+                dev->use_tx_clk_for_rx = 0;
+                break;
+        case 2:
+                switch ( board_id )
+                {
+                case Z3_BOARD_ID_APP_31:
+                        if (z3_fpga_get_aic_disable() == 0 ) {
+                                if (z3_fpga_get_aic_ext_master() == 0 ) {
+                                        dev->mclk_out = AHCLKX;
+                                } else {
+                                        dev->mclk_out = 0;
+                                }
+                                dev->use_tx_clk_for_rx = 1;
+                        } else {
+                                dev->mclk_out = 0;
+                                dev->use_tx_clk_for_rx = 1;
+                        }
+                        break;
+
+                default:
+                        dev->mclk_out = AHCLKX;
+                        dev->use_tx_clk_for_rx = 1;
+                        break;
+                }
+                break;
+        }
+
+}
+
+static void mcasp_enable_mclk(struct davinci_audio_dev *dev)
+{
+        mcasp_set_board_clks(dev);
+
+        if ( AHCLKX == (AHCLKX & dev->mclk_out ) ) {
+                // on the Z3 board, the AHCLKX is used as the MCLK to the codec
+                // so we have to turn it on even for rx
+                mcasp_mod_bits( dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXDIV(7), AHCLKXDIVMASK);
+//                mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXDIV(0), ACLKXDIVMASK);
+                //printk("turn on txhclk with glbctlx reg\n");
+                mcasp_set_bits(dev->base + DAVINCI_MCASP_PDIR_REG, AHCLKX);
+
+                mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);
+                //printk("turn on txhclk - done\n");
+        } else {
+                mcasp_mod_bits( dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXDIV(0), AHCLKXDIVMASK);
+                mcasp_clr_bits(dev->base + DAVINCI_MCASP_PDIR_REG, AHCLKX);
+                mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);
+        }
+
+        if ( AHCLKR == (AHCLKR & dev->mclk_out ) ) {
+                mcasp_mod_bits( dev->base + DAVINCI_MCASP_AHCLKRCTL_REG, AHCLKRDIV(7), AHCLKRDIVMASK);
+                mcasp_set_bits(dev->base + DAVINCI_MCASP_PDIR_REG, AHCLKR);
+                mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);
+        } else {
+                mcasp_mod_bits( dev->base + DAVINCI_MCASP_AHCLKRCTL_REG, AHCLKRDIV(0), AHCLKRDIVMASK);
+                mcasp_clr_bits(dev->base + DAVINCI_MCASP_PDIR_REG, AHCLKR);
+                mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);
+        }
+}
+
 static void mcasp_start_rx(struct davinci_audio_dev *dev)
 {
+        mcasp_enable_mclk( dev );
+
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXCLKRST);
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXSERCLR);
@@ -364,8 +457,12 @@
 	u8 offset = 0, i;
 	u32 cnt;
 
-        mcasp_mod_bits( dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXDIV(7), AHCLKXDIVMASK);
-        mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXDIV(0), ACLKXDIVMASK);
+        mcasp_enable_mclk( dev );
+
+	mcasp_mod_bits( dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXDIV(7), AHCLKXDIVMASK);
+	mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXDIV(dev->aclkdiv), ACLKXDIVMASK);
+
+        mcasp_mod_bits(dev->base + DAVINCI_MCASP_PDIR_REG, dev->pdir_tx_mask, MCASP_BITCLK_FS_PINS_MASK);
 
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);
 	mcasp_set_ctl_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXCLKRST);
@@ -408,13 +505,23 @@
 
 static void mcasp_stop_rx(struct davinci_audio_dev *dev)
 {
-	mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, 0);
+        if ( AHCLKR == (AHCLKR & dev->mclk_out ) ) {
+                mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, RXHCLKRST);
+        } else {
+                mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLR_REG, 0);
+        }
 	mcasp_set_reg(dev->base + DAVINCI_MCASP_RXSTAT_REG, 0xFFFFFFFF);
 }
 
 static void mcasp_stop_tx(struct davinci_audio_dev *dev)
 {
-	mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, 0);
+        mcasp_mod_bits(dev->base + DAVINCI_MCASP_PDIR_REG, 0, MCASP_BITCLK_FS_PINS_MASK);
+
+        if ( AHCLKX == (AHCLKX & dev->mclk_out ) ) {
+                mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, TXHCLKRST);
+        } else {
+                mcasp_set_reg(dev->base + DAVINCI_MCASP_GBLCTLX_REG, 0);
+        }
 	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXSTAT_REG, 0xFFFFFFFF);
 }
 
@@ -438,8 +545,31 @@
 {
 	struct davinci_audio_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
 	void __iomem *base = dev->base;
+        u32 normal_fs_polarity;
+        u32 inverted_fs_polarity;
+
+
+        mcasp_enable_mclk( dev );
+
+        dev->pdir_tx_mask = 0;
 
 	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFM:
+		/* codec is clock and frame slave */
+		mcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);
+		mcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, AFSXE);
+
+		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);
+		mcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);
+
+//		mcasp_mod_bits(base + DAVINCI_MCASP_PDIR_REG, , MCASP_BITCLK_FS_PINS_MASK);
+                dev->pdir_tx_mask = (ACLKX|ACLKR);
+
+                mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRDIV(dev->aclkdiv), ACLKRDIVMASK);
+                mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXDIV(dev->aclkdiv), ACLKXDIVMASK);
+
+		break;
+
 	case SND_SOC_DAIFMT_CBS_CFS:
 		/* codec is clock and frame slave */
 		mcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXE);
@@ -448,7 +578,12 @@
 		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);
 		mcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);
 
-		mcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG, (0x7 << 26));
+//		mcasp_mod_bits(base + DAVINCI_MCASP_PDIR_REG, MCASP_BITCLK_FS_PINS_MASK, MCASP_BITCLK_FS_PINS_MASK);
+                dev->pdir_tx_mask = MCASP_BITCLK_FS_PINS_MASK;
+
+                mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRDIV(dev->aclkdiv), ACLKRDIVMASK);
+                mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXDIV(dev->aclkdiv), ACLKXDIVMASK);
+
 		break;
 	case SND_SOC_DAIFMT_CBM_CFS:
 		/* codec is clock master and frame slave */
@@ -458,7 +593,7 @@
 		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);
 		mcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);
 
-		mcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG, (0x2d << 26));
+		mcasp_mod_bits(base + DAVINCI_MCASP_PDIR_REG, (AFSX|AFSR), MCASP_BITCLK_FS_PINS_MASK);
 		break;
 	case SND_SOC_DAIFMT_CBM_CFM:
 		/* codec is clock and frame master */
@@ -468,56 +603,87 @@
 		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRE);
 		mcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, AFSRE);
 
-		mcasp_clr_bits(base + DAVINCI_MCASP_PDIR_REG, (0x3f << 26));
-
-        /* AHCLKX drives MCLK */
-        mcasp_mod_bits( dev->base + DAVINCI_MCASP_AHCLKXCTL_REG, AHCLKXDIV(7), AHCLKXDIVMASK);
-        mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXDIV(0), ACLKXDIVMASK);
-		mcasp_set_bits(base + DAVINCI_MCASP_PDIR_REG, (0x2 << 26));
-
+		mcasp_mod_bits(base + DAVINCI_MCASP_PDIR_REG, 0, MCASP_BITCLK_FS_PINS_MASK);
 		break;
 
 	default:
 		return -EINVAL;
 	}
 
+	switch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK ) ) {
+	case SND_SOC_DAIFMT_I2S:
+                normal_fs_polarity = FSXPOL;
+                inverted_fs_polarity = 0;
+                break;
+        default:
+                normal_fs_polarity = 0;
+                inverted_fs_polarity = FSXPOL;
+                break;
+        }
+
+
 	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
 	case SND_SOC_DAIFMT_IB_NF:
 		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);
-		mcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);
+		mcasp_mod_bits(base + DAVINCI_MCASP_TXFMCTL_REG, normal_fs_polarity, FSXPOL);
 
-		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
-		mcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);
+		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
+		mcasp_mod_bits(base + DAVINCI_MCASP_RXFMCTL_REG, normal_fs_polarity, FSRPOL);
 		break;
 
 	case SND_SOC_DAIFMT_NB_IF:
 		mcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);
-		mcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);
+		mcasp_mod_bits(base + DAVINCI_MCASP_TXFMCTL_REG, inverted_fs_polarity, FSXPOL);
 
-		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
-		mcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);
+		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
+		mcasp_mod_bits(base + DAVINCI_MCASP_RXFMCTL_REG, inverted_fs_polarity, FSRPOL);
 		break;
 
 	case SND_SOC_DAIFMT_IB_IF:
 		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);
-		mcasp_set_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);
+		mcasp_mod_bits(base + DAVINCI_MCASP_TXFMCTL_REG, inverted_fs_polarity, FSXPOL);
 
-		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
-		mcasp_set_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);
+		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
+		mcasp_mod_bits(base + DAVINCI_MCASP_RXFMCTL_REG, inverted_fs_polarity, FSRPOL);
 		break;
 
 	case SND_SOC_DAIFMT_NB_NF:
 		mcasp_set_bits(base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXPOL);
-		mcasp_clr_bits(base + DAVINCI_MCASP_TXFMCTL_REG, FSXPOL);
+		mcasp_mod_bits(base + DAVINCI_MCASP_TXFMCTL_REG, normal_fs_polarity, FSXPOL);
 
-		mcasp_clr_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
-		mcasp_clr_bits(base + DAVINCI_MCASP_RXFMCTL_REG, FSRPOL);
+		mcasp_set_bits(base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRPOL);
+		mcasp_mod_bits(base + DAVINCI_MCASP_RXFMCTL_REG, normal_fs_polarity, FSRPOL);
 		break;
 
 	default:
 		return -EINVAL;
 	}
 
+	switch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK ) ) {
+	case SND_SOC_DAIFMT_I2S:
+        default:
+		mcasp_set_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);
+		mcasp_set_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);
+                break;
+	case SND_SOC_DAIFMT_DSP_A:
+	case SND_SOC_DAIFMT_DSP_B:
+		mcasp_clr_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);
+		mcasp_clr_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);
+                break;
+        }
+
+	switch (fmt & (SND_SOC_DAIFMT_FORMAT_MASK ) ) {
+	case SND_SOC_DAIFMT_I2S:
+                mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, FSRDLY(1), FSRDLY(0x3));
+                mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, FSXDLY(1), FSXDLY(0x3));
+                break;
+
+        default:
+                mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG, FSRDLY(0), FSRDLY(0x3));
+                mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG, FSXDLY(0), FSXDLY(0x3));
+                break;
+        }
+
 	return 0;
 }
 
@@ -532,41 +698,48 @@
 		fmt = 0x03;
 		rotate = 6;
 		mask = 0x000000ff;
+                dev->aclkdiv = 0x1f;
 		break;
 
 	case DAVINCI_AUDIO_WORD_12:
 		fmt = 0x05;
 		rotate = 5;
 		mask = 0x00000fff;
+                dev->aclkdiv = 0xf;
 		break;
 
 	case DAVINCI_AUDIO_WORD_16:
 		fmt = 0x07;
 		rotate = 4;
 		mask = 0x0000ffff;
+                dev->aclkdiv = 0xf;
 		break;
 
 	case DAVINCI_AUDIO_WORD_20:
 		fmt = 0x09;
 		rotate = 3;
+                dev->aclkdiv = 0x7;
 		mask = 0x000fffff;
 		break;
 
 	case DAVINCI_AUDIO_WORD_24:
 		fmt = 0x0B;
 		rotate = 2;
+                dev->aclkdiv = 0x7;
 		mask = 0x00ffffff;
 		break;
 
 	case DAVINCI_AUDIO_WORD_28:
 		fmt = 0x0D;
 		rotate = 1;
+                dev->aclkdiv = 0x7;
 		mask = 0x0fffffff;
 		break;
 
 	case DAVINCI_AUDIO_WORD_32:
 		fmt = 0x0F;
 		rotate = 0;
+                dev->aclkdiv = 0x7;
 		mask = 0xffffffff;
 		break;
 
@@ -574,6 +747,11 @@
 		return -EINVAL;
 	}
 
+        if ( dev->rrot_nibbles_additional ) {
+                rotate += dev->rrot_nibbles_additional;
+                rotate &= 7;
+        }
+
 	mcasp_mod_bits(dev->base + DAVINCI_MCASP_RXFMT_REG,
 					RXSSZ(fmt), RXSSZ(0x0F));
 	mcasp_mod_bits(dev->base + DAVINCI_MCASP_TXFMT_REG,
@@ -585,6 +763,10 @@
 	mcasp_set_reg(dev->base + DAVINCI_MCASP_TXMASK_REG, mask);
 	mcasp_set_reg(dev->base + DAVINCI_MCASP_RXMASK_REG, mask);
 
+        mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKRCTL_REG, ACLKRDIV(dev->aclkdiv), ACLKRDIVMASK);
+        mcasp_mod_bits( dev->base + DAVINCI_MCASP_ACLKXCTL_REG, ACLKXDIV(dev->aclkdiv), ACLKXDIVMASK);
+
+
 	return 0;
 }
 
@@ -654,7 +836,11 @@
 	for (i = 0; i < active_slots; i++)
 		mask |= (1 << i);
 
-	mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);
+        if ( dev->use_tx_clk_for_rx ) {
+                mcasp_clr_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);
+        } else {
+                mcasp_set_bits(dev->base + DAVINCI_MCASP_ACLKXCTL_REG, TX_ASYNC);
+        }
 
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		/* bit stream is MSB first  with no delay */
@@ -671,7 +857,6 @@
 			printk(KERN_ERR "playback tdm slot %d not supported\n",
 				dev->tdm_slots);
 
-		mcasp_clr_bits(dev->base + DAVINCI_MCASP_TXFMCTL_REG, FSXDUR);
 	} else {
 		/* bit stream is MSB first with no delay */
 		/* DSP_B mode */
@@ -687,7 +872,7 @@
 			printk(KERN_ERR "capture tdm slot %d not supported\n",
 				dev->tdm_slots);
 
-		mcasp_clr_bits(dev->base + DAVINCI_MCASP_RXFMCTL_REG, FSRDUR);
+
 	}
 }
 
@@ -735,6 +920,8 @@
 	int word_length;
 	u8 fifo_level;
 
+        mcasp_set_board_clks(dev);
+
 	davinci_hw_common_param(dev, substream->stream);
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
 		fifo_level = dev->txnumevt;
@@ -833,38 +1020,106 @@
 
 };
 
-static struct snd_soc_dai_driver davinci_mcasp_dai[] = {
-	{
-		.name		= "davinci-mcasp.0",
-		.playback	= {
-			.channels_min	= 2,
-			.channels_max 	= 2,
-			.rates 		= DAVINCI_MCASP_RATES,
-			.formats 	= SNDRV_PCM_FMTBIT_S8 |
-						SNDRV_PCM_FMTBIT_S16_LE |
-						SNDRV_PCM_FMTBIT_S32_LE,
-		},
-		.capture 	= {
-			.channels_min 	= 2,
-			.channels_max 	= 2,
-			.rates 		= DAVINCI_MCASP_RATES,
-			.formats	= SNDRV_PCM_FMTBIT_S8 |
-						SNDRV_PCM_FMTBIT_S16_LE |
-						SNDRV_PCM_FMTBIT_S32_LE,
-		},
-		.ops 		= &davinci_mcasp_dai_ops,
-
-	},
-	{
-		"davinci-mcasp.1",
-		.playback 	= {
-			.channels_min	= 1,
-			.channels_max	= 384,
-			.rates		= DAVINCI_MCASP_RATES,
-			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
-		},
-		.ops 		= &davinci_mcasp_dai_ops,
-	},
+static struct snd_soc_dai_driver davinci_mcasp_dai[DAVINCI_CPU_MAX_MCASP][2] = {
+        {
+                {
+                        .name		= "davinci-mcasp.0",
+                        .playback	= {
+                                .channels_min	= 2,
+                                .channels_max 	= 2,
+                                .rates 		= DAVINCI_MCASP_RATES,
+                                .formats 	= SNDRV_PCM_FMTBIT_S8 |
+                                SNDRV_PCM_FMTBIT_S16_LE |
+                                SNDRV_PCM_FMTBIT_S32_LE,
+                        },
+                        .capture 	= {
+                                .channels_min 	= 2,
+                                .channels_max 	= 2,
+                                .rates 		= DAVINCI_MCASP_RATES,
+                                .formats	= SNDRV_PCM_FMTBIT_S8 |
+                                SNDRV_PCM_FMTBIT_S16_LE |
+                                SNDRV_PCM_FMTBIT_S32_LE,
+                        },
+                        .ops 		= &davinci_mcasp_dai_ops,
+
+                },
+                {
+                        .name		= "davinci-mcasp.0",
+                        .playback 	= {
+                                .channels_min	= 1,
+                                .channels_max	= 384,
+                                .rates		= DAVINCI_MCASP_RATES,
+                                .formats	= SNDRV_PCM_FMTBIT_S16_LE,
+                        },
+                        .ops 		= &davinci_mcasp_dai_ops,
+                },
+        },
+        {
+                {
+                        .name		= "davinci-mcasp.1",
+                        .playback	= {
+                                .channels_min	= 2,
+                                .channels_max 	= 2,
+                                .rates 		= DAVINCI_MCASP_RATES,
+                                .formats 	= SNDRV_PCM_FMTBIT_S8 |
+                                SNDRV_PCM_FMTBIT_S16_LE |
+                                SNDRV_PCM_FMTBIT_S32_LE,
+                        },
+                        .capture 	= {
+                                .channels_min 	= 2,
+                                .channels_max 	= 2,
+                                .rates 		= DAVINCI_MCASP_RATES,
+                                .formats	= SNDRV_PCM_FMTBIT_S8 |
+                                SNDRV_PCM_FMTBIT_S16_LE |
+                                SNDRV_PCM_FMTBIT_S32_LE,
+                        },
+                        .ops 		= &davinci_mcasp_dai_ops,
+
+                },
+                {
+                        .name		= "davinci-mcasp.1",
+                        .playback 	= {
+                                .channels_min	= 1,
+                                .channels_max	= 384,
+                                .rates		= DAVINCI_MCASP_RATES,
+                                .formats	= SNDRV_PCM_FMTBIT_S16_LE,
+                        },
+                        .ops 		= &davinci_mcasp_dai_ops,
+                },
+        },
+        {
+                {
+                        .name		= "davinci-mcasp.2",
+                        .playback	= {
+                                .channels_min	= 2,
+                                .channels_max 	= 2,
+                                .rates 		= DAVINCI_MCASP_RATES,
+                                .formats 	= SNDRV_PCM_FMTBIT_S8 |
+                                SNDRV_PCM_FMTBIT_S16_LE |
+                                SNDRV_PCM_FMTBIT_S32_LE,
+                        },
+                        .capture 	= {
+                                .channels_min 	= 2,
+                                .channels_max 	= 2,
+                                .rates 		= DAVINCI_MCASP_RATES,
+                                .formats	= SNDRV_PCM_FMTBIT_S8 |
+                                SNDRV_PCM_FMTBIT_S16_LE |
+                                SNDRV_PCM_FMTBIT_S32_LE,
+                        },
+                        .ops 		= &davinci_mcasp_dai_ops,
+
+                },
+                {
+                        .name		= "davinci-mcasp.2",
+                        .playback 	= {
+                                .channels_min	= 1,
+                                .channels_max	= 384,
+                                .rates		= DAVINCI_MCASP_RATES,
+                                .formats	= SNDRV_PCM_FMTBIT_S16_LE,
+                        },
+                        .ops 		= &davinci_mcasp_dai_ops,
+                },
+        },
 
 };
 
@@ -904,6 +1159,9 @@
 
 	clk_enable(dev->clk);
 	dev->clk_active = 1;
+        dev->id = pdev->id;
+
+        mcasp_set_board_clks(dev);
 
 	dev->base = ioremap(mem->start, resource_size(mem));
 	if (!dev->base) {
@@ -920,6 +1178,7 @@
 	dev->version = pdata->version;
 	dev->txnumevt = pdata->txnumevt;
 	dev->rxnumevt = pdata->rxnumevt;
+    dev->rrot_nibbles_additional = pdata->rrot_nibbles;
 
 	dma_data = &dev->dma_params[SNDRV_PCM_STREAM_PLAYBACK];
 	dma_data->asp_chan_q = pdata->asp_chan_q;
@@ -956,9 +1215,15 @@
 		goto err_iounmap;
 	}
 
+	if (!pdev->id > DAVINCI_CPU_MAX_MCASP) {
+		dev_err(&pdev->dev, "mcasp id out of range (%u>=%u)\n", pdev->id, DAVINCI_CPU_MAX_MCASP);
+		ret = -ENODEV;
+		goto err_iounmap;
+	}
+
 	dma_data->channel = res->start;
 	dev_set_drvdata(&pdev->dev, dev);
-	ret = snd_soc_register_dai(&pdev->dev, &davinci_mcasp_dai[pdata->op_mode]);
+	ret = snd_soc_register_dai(&pdev->dev, &davinci_mcasp_dai[pdev->id][pdata->op_mode]);
 
 	if (ret != 0)
 		goto err_iounmap;
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.h
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.h	2012-03-22 23:13:03.000000000 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/davinci/davinci-mcasp.h	2012-09-23 16:05:57.004322027 -0600
@@ -32,7 +32,7 @@
 #define DAVINCI_MCASP_I2S_DAI	0
 #define DAVINCI_MCASP_DIT_DAI	1
 
-enum {
+typedef enum {
 	DAVINCI_AUDIO_WORD_8 = 0,
 	DAVINCI_AUDIO_WORD_12,
 	DAVINCI_AUDIO_WORD_16,
@@ -40,7 +40,7 @@
 	DAVINCI_AUDIO_WORD_24,
 	DAVINCI_AUDIO_WORD_32,
 	DAVINCI_AUDIO_WORD_28,  /* This is only valid for McASP */
-};
+} davinci_mcasp_audio_word_t;
 
 struct davinci_audio_dev {
 	struct davinci_pcm_dma_params dma_params[2];
@@ -48,7 +48,14 @@
 	int sample_rate;
 	struct clk *clk;
 	unsigned int codec_fmt;
-	u8 clk_active;
+	u8          clk_active;
+        u8          aclkdiv;
+        u32         pdir_tx_mask;
+
+    /* Hardware options */
+    u32 mclk_out; // Bit mask of HCLK pins to drive master clock for codec
+    u32 use_tx_clk_for_rx;
+    int id;
 
 	/* McASP specific data */
 	int	tdm_slots;
@@ -56,6 +63,7 @@
 	u8	num_serializer;
 	u8	*serial_dir;
 	u8	version;
+    u8      rrot_nibbles_additional;
 
 	/* McASP FIFO related */
 	u8	txnumevt;
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/gv7600.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/gv7600.c	2012-07-30 19:36:11.000000000 -0600
@@ -0,0 +1,96 @@
+/*
+ * ALSA SoC GV7600 SDI transmitter audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <mach/z3_fpga.h>
+
+MODULE_LICENSE("GPL");
+
+#define GV7600_SOUND_RATES	SNDRV_PCM_RATE_8000_96000
+#define GV7600_SOUND_FORMATS	SNDRV_PCM_FMTBIT_S32_LE
+
+
+static struct snd_soc_codec_driver soc_codec_gv7600_sound;
+
+
+static int gv7600_sound_hw_params(struct snd_pcm_substream *substream,
+                                   struct snd_pcm_hw_params *params,
+                                   struct snd_soc_dai *dai)
+{
+        /* This is where we need to drive the digital bus,
+           when we are sharing the bus with another codec
+         */
+
+        return 0;
+}
+
+static int gv7600_sound_set_dai_fmt(struct snd_soc_dai *codec_dai,
+                                     unsigned int fmt)
+{
+        return 0;
+}
+
+static struct snd_soc_dai_ops gv7600_sound_dai_ops = {
+        .hw_params = gv7600_sound_hw_params,
+	/* .digital_mute	= gv7600_sound_mute, */
+	/* .set_sysclk	= gv7600_sound_set_dai_sysclk, */
+	.set_fmt	= gv7600_sound_set_dai_fmt,
+};
+
+
+static struct snd_soc_dai_driver gv7600_sound_dai = {
+	.name		= "gv7600-hifi",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 2,
+		.channels_max	= 4,
+		.rates		= GV7600_SOUND_RATES,
+		.formats	= GV7600_SOUND_FORMATS,
+	},
+	.ops = &gv7600_sound_dai_ops,
+};
+
+static int gv7600_sound_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_gv7600_sound,
+			&gv7600_sound_dai, 1);
+}
+
+static int gv7600_sound_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver gv7600_sound_driver = {
+	.probe		= gv7600_sound_probe,
+	.remove		= gv7600_sound_remove,
+	.driver		= {
+		.name	= "gv7600-sound",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init gv7600_sound_modinit(void)
+{
+	return platform_driver_register(&gv7600_sound_driver);
+}
+
+static void __exit gv7600_sound_exit(void)
+{
+	platform_driver_unregister(&gv7600_sound_driver);
+}
+
+module_init(gv7600_sound_modinit);
+module_exit(gv7600_sound_exit);
+
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/gv7601.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/gv7601.c	2012-07-30 19:36:11.000000000 -0600
@@ -0,0 +1,100 @@
+/*
+ * ALSA SoC GV7601 SDI receiver audio driver
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <mach/z3_fpga.h>
+
+MODULE_LICENSE("GPL");
+
+#define GV7601_SOUND_RATES	SNDRV_PCM_RATE_8000_96000
+#define GV7601_SOUND_FORMATS	SNDRV_PCM_FMTBIT_S32_LE
+
+
+static struct snd_soc_codec_driver soc_codec_gv7601_sound;
+
+
+static int gv7601_sound_hw_params(struct snd_pcm_substream *substream,
+                                   struct snd_pcm_hw_params *params,
+                                   struct snd_soc_dai *dai)
+{
+        /* This is where we need to drive the digital bus,
+           when we are sharing the bus with another codec
+         */
+
+        return 0;
+}
+
+static int gv7601_sound_set_dai_fmt(struct snd_soc_dai *codec_dai,
+                                     unsigned int fmt)
+{
+        return 0;
+}
+
+static struct snd_soc_dai_ops gv7601_sound_dai_ops = {
+        .hw_params = gv7601_sound_hw_params,
+	/* .digital_mute	= gv7601_sound_mute, */
+	/* .set_sysclk	= gv7601_sound_set_dai_sysclk, */
+	.set_fmt	= gv7601_sound_set_dai_fmt,
+};
+
+
+static struct snd_soc_dai_driver gv7601_sound_dai = {
+	.name		= "gv7601-hifi",
+	.capture 	= {
+		.stream_name	= "Capture",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= GV7601_SOUND_RATES,
+		.formats	= GV7601_SOUND_FORMATS,
+	},
+	.ops = &gv7601_sound_dai_ops,
+};
+
+static int gv7601_sound_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_codec(&pdev->dev, &soc_codec_gv7601_sound,
+			&gv7601_sound_dai, 1);
+}
+
+static int gv7601_sound_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_codec(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver gv7601_sound_driver = {
+	.probe		= gv7601_sound_probe,
+	.remove		= gv7601_sound_remove,
+	.driver		= {
+		.name	= "gv7601-sound",
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init gv7601_sound_modinit(void)
+{
+        int ret;
+
+	ret = platform_driver_register(&gv7601_sound_driver);
+
+        return ret;
+}
+
+static void __exit gv7601_sound_exit(void)
+{
+	platform_driver_unregister(&gv7601_sound_driver);
+}
+
+module_init(gv7601_sound_modinit);
+module_exit(gv7601_sound_exit);
+
Index: kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/tlv320aic3x.c
===================================================================
--- kernel.orig/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/tlv320aic3x.c	2012-03-22 23:13:03.000000000 -0600
+++ kernel/linux-2.6.37-psp04.04.00.01/sound/soc/codecs/tlv320aic3x.c	2012-09-23 16:20:28.948325372 -0600
@@ -50,6 +50,7 @@
 #include <sound/initval.h>
 #include <sound/tlv.h>
 #include <sound/tlv320aic3x.h>
+#include <mach/z3_fpga.h>
 
 #include "tlv320aic3x.h"
 
@@ -816,6 +817,20 @@
 	u16 d, pll_d = 1;
 	u8 reg;
 	int clk;
+        int ret;
+
+        if ( z3_fpga_get_aic_ext_master( ) ) {
+                bypass_pll = 1;
+
+                ret = z3_fpga_set_aic_ext_master_sample_rate(params_rate(params));
+                if ( ret != 0 ) {
+                        printk(KERN_ERR "%s(): unable to setup fpga master at rate %u\n", __func__, params_rate(params));
+                        return ret;
+                }
+        }
+
+        /* enable access to bus */
+        z3_fpga_set_aic_disable( 0 );
 
 	/* select data word length */
 	data = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLB) & (~(0x3 << 4));
@@ -1005,6 +1020,14 @@
 	case SND_SOC_DAIFMT_CBS_CFS:
 		aic3x->master = 0;
 		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+		aic3x->master = 0;
+		iface_areg |= WORD_CLK_MASTER;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+		aic3x->master = 1;
+		iface_areg |= BIT_CLK_MASTER;
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -1040,6 +1063,22 @@
 	return 0;
 }
 
+
+static void aic3x_pcm_shutdown(struct snd_pcm_substream *substream,
+                               struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct aic3x_priv *aic3x = snd_soc_codec_get_drvdata(codec);
+
+        u8 iface_areg;
+
+        /* Tri-state bit clock and frame sync */
+	iface_areg = snd_soc_read(codec, AIC3X_ASD_INTF_CTRLA) & 0x3f;
+        aic3x->master = 0;
+	snd_soc_write(codec, AIC3X_ASD_INTF_CTRLA, iface_areg);
+}
+
 static int aic3x_init_3007(struct snd_soc_codec *codec)
 {
 	u8 tmp1, tmp2, *cache = codec->reg_cache;
@@ -1232,6 +1271,7 @@
 	.digital_mute	= aic3x_mute,
 	.set_sysclk	= aic3x_set_dai_sysclk,
 	.set_fmt	= aic3x_set_dai_fmt,
+    .shutdown       = aic3x_pcm_shutdown,
 };
 
 static struct snd_soc_dai_driver aic3x_dai = {
